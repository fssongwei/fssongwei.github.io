<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>David&#39;s Blog</title>
  
  <subtitle>Eat, Sleep, Code, Repeat</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.david916.com/"/>
  <updated>2020-12-24T10:13:14.458Z</updated>
  <id>http://blog.david916.com/</id>
  
  <author>
    <name>Wei Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Virtual DOM和Diff算法总结</title>
    <link href="http://blog.david916.com/2020/12/24/Virtual%20DOM%E5%92%8CDiff%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.david916.com/2020/12/24/Virtual DOM和Diff算法总结/</id>
    <published>2020-12-24T10:11:26.960Z</published>
    <updated>2020-12-24T10:13:14.458Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><img src="https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/虚拟dom.png" alt="Virtual DOM" style="zoom:50%;"><p>App（JS程序）可以通过DOM操作创建或更改DOM元素，DOM元素也可以通过监听并触发事件来影响JS</p><p>然而对于对于用js写的每个组件，我们需要自行<strong>手动</strong>去完成DOM更新和事件处理，效率低下</p><p>（e.g. 我用js写了一个复杂的大组件，现在想改其中一个小部分（子组件），我可以：1. 直接覆盖DOM树上整个大组件的节点，不需要引入额外代码，但DOM操作复杂性能低，或2. 通过一系列DOM查找，找到要修改的子组件所在的DOM节点，然后覆盖这个小节点，但是需要手动引入大量额外操作或代码）</p><p>React为解决上述问题引入了Virtual Dom：</p><ol><li>js创建组件后通过<code>React.createElement</code>函数生成虚拟DOM树，然后通过Virtual DOM来创建或更改真实的DOM树</li><li>DOM触发的事件会先冒泡至Virtual DOM，再由Virtual DOM转发到具体的js组件或函数去处理事件</li></ol><h4 id="Virtual-Dom优势"><a href="#Virtual-Dom优势" class="headerlink" title="Virtual Dom优势"></a>Virtual Dom优势</h4><ol><li><p>我们只需建立js组件并维护其状态，Virtual DOM会自动完成DOM更新和事件处理，从而<strong>提升开发效率</strong></p></li><li><p>Virtual DOM通过<strong>Diff算法</strong>来比较新旧Virtual DOM树，从而得出最高效的DOM更新和操作步骤，因而<strong>提升性能</strong></p><p>（实际上Virtual DOM最终还是要进行实际的DOM操作，因而不会直接提升DOM操作的性能）</p></li><li><p>不同平台可以根据Virtual DOM画出对应平台的UI层（e.g. react-native），从而实现了<strong>跨平台能力</strong></p></li></ol><h4 id="Virtual-DOM节点对象属性"><a href="#Virtual-DOM节点对象属性" class="headerlink" title="Virtual DOM节点对象属性"></a>Virtual DOM节点对象属性</h4><ol><li>type：组件类型：原生HTML元素（div, span）/ Function Component / Class Component</li><li>key：组件的唯一标识（用于Diff算法）</li><li>ref：指向原生的DOM节点</li><li>props：传入组件的props（注意children也是props的一个属性，即子组件由此访问）</li><li>owner：父组件的Virtual DOM节点</li></ol><h4 id="Virtual-DOM事件处理"><a href="#Virtual-DOM事件处理" class="headerlink" title="Virtual DOM事件处理"></a>Virtual DOM事件处理</h4><ol><li><p>react所有组件的事件（非原生事件，以下称react事件）都是挂载在document上</p></li><li><p>直到事件触发后冒泡至document后，react才开始执行react事件</p></li><li><p>执行顺序：非挂载在document上的原生事件 =&gt; react事件 =&gt; 挂载在document上的原生事件</p><p>（不建议混用react事件和原生事件） <a href="https://juejin.cn/post/6844903790198571021#heading-4" target="_blank" rel="noopener">ref</a></p></li></ol><h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><p>归纳三点（如果不想看后续详细介绍）：</p><ol><li>同级节点（具有相同父节点的子节点）为一组进行比较（tree diff）</li><li>节点间通过比较节点类型进行快速判断（component diff）</li><li>使用key对于同组节点进行比较和移动操作，避免重复删除和重建节点（element diff）</li></ol><p>Virtual DOM带来的性能提升主要源于React实现的高效Diff算法。Diff算法主要用于计算从一颗树变换到另一个树所需要的最少操作次数（添加/删除/移动节点）。</p><p>传统Diff算法平均复杂度为n^3，react引入的改进版Diff算法平均复杂度降至n</p><p>用户触发的事件均可能造成DOM树的变动，主要分为以下几种：</p><ol><li>同一层级（具有相同父节点的兄弟节点）的DOM节点之间的变动：e.g. 新增/插入/删除/随机排序列表项</li><li>一个DOM节点影响另一个DOM节点（例如redux状态共享，父子节点通过props/callback状态共享）</li><li>DOM节点间的跨层级移动（例如同级的AB节点，A节点移动至B的子节点）（此种情况出现次数极少，忽略不计）</li></ol><p>基于上述变动方式，React设计了如下步骤用于计算如何变换DOM树：</p><ol><li><p>tree diff</p><p>由于DOM节点间的跨层级移动出现极少，因此可以完全忽略此种情况，比较两颗树时只对同一层次对应的节点进行比较</p><p><img src="https://pic1.zhimg.com/80/0c08dbb6b1e0745780de4d208ad51d34_720w.png" alt="tree diff"></p><p>（如上图：根节点和根节点比较，同一层次具有相同父节点的节点为一组进行比较）</p><p><img src="https://pic2.zhimg.com/80/d712a73769688afe1ef1a055391d99ed_720w.png" alt="tree diff 2"></p><p>而对于跨层级移动的节点（上图A），则会经历一次节点销毁和节点重建的过程，效率较低。但由于此种情况出现极少，整体而言react diff算法效率还是较高</p></li><li><p>component diff</p><p>上面tree diff进行同级比较时，需要判断两个节点是否相同，如果不同则会被替换或销毁</p><p>react判断节点（以及其子节点）是否相同，不会通过递归的方式一一比较子节点，而是直接通过判断两个节点的类型（class，即组件名）是否相同，对于不同的节点进行操作</p><p>（react官方的解答是，对于不同类型的组件节点，存在相同DOM树的概率极低，因而不用浪费时间在后续比较）</p><p>对于类型相同的节点，则继续递归其子节点进行判断，但是react也允许用户使用<code>shouldComponentUpdate()</code> 来判断是否需要对该节点进行后续<code>diff</code>运算，从而提高效率</p></li><li><p>element diff</p><p>对于同一层级（具有相同父节点的）节点的新增/插入/删除/乱序等操作，传统的diff算法会按顺序一一通过component diff进行比较，对不同的节点进行删除/重建/替换操作，效率较低：</p><p><img src="https://pic2.zhimg.com/80/7541670c089b84c59b84e9438e92a8e9_720w.png" alt="element diff 1"></p><p>(e.g. 当上面节点顺序由ABCD改为BADC时，传统Diff算法流程：删除A，重建B，插入B，删除B，重建A，插入A，删除C，重建D，插入D，删除D，重建C，插入C共12步，即每个节点都需要删除再重建，尤其重建的效率非常低)</p><p>实际上针对上述情况，只需要进行两部移动（将A移动到B后面，将D移动到C后面）即可完成，这也是react element diff算法给出的操作结果：</p><ol><li><p>每个同级节点具有独特的key</p></li><li><p>遍历每个新Virtual DOM的节点（索引记为i），如果旧Virtual DOM树同一层级具有相同的节点（需要结合key和component diff判断是否相同），且该节点当前所在索引 i 在其旧索引位置的前面，则将该节点从真实DOM树上<strong>往后移动</strong></p><p>（即仅对存在的节点向后移动，而不对节点向前移动）</p><p>（e.g. 上面A节点在新树的索引为1，旧树的索引为0，则将A在DOM树上往后移）</p><p>对于不存在于旧DOM的新节点则直接插入到DOM树中，对于不存在于新DOM的旧节点则直接删除</p></li></ol><p>Example:</p><p><img src="https://pic4.zhimg.com/80/c0aa97d996de5e7f1069e97ca3accfeb_720w.png" alt="example1"></p><p>(ABCD节点均在旧DOM树中，b节点新旧索引（0&lt;1）不动，a节点（1&gt;0）往后移动，依次类推)</p><p><img src="https://pic1.zhimg.com/80/7b9beae0cf0a5bc8c2e82d00c43d1c90_720w.png" alt="example2"></p><p>(B节点不动，E节点新增，C节点不冬，A节点后移，D节点删除)</p><p><img src="https://pic2.zhimg.com/80/1b8dac5b9b3e4452dec8d5447d7717ad_720w.png" alt="example3"></p><p>（ABC节点均后移，D节点不动。由于Diff算法只对节点进行后移，因此尽量减少类似将最后一个节点移动到列表首部的操作）</p></li></ol><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://www.conardli.top/blog/article/React深入系列/深入分析虚拟DOM的渲染原理和特性.html" target="_blank" rel="noopener">深入分析虚拟DOM的渲染原理和特性</a></p><p><a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener">React 源码剖析系列 － 不可思议的 react diff</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Virtual-DOM&quot;&gt;&lt;a href=&quot;#Virtual-DOM&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM&quot;&gt;&lt;/a&gt;Virtual DOM&lt;/h3&gt;&lt;img src=&quot;https://lsqimg-1257917459.c
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.david916.com/categories/Note/"/>
    
    
      <category term="React" scheme="http://blog.david916.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 2.0 安全性总结</title>
    <link href="http://blog.david916.com/2020/12/24/OAuth%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.david916.com/2020/12/24/OAuth安全问题/</id>
    <published>2020-12-24T06:20:00.879Z</published>
    <updated>2020-12-24T06:25:08.252Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇关于使用Passport.js实现Google OAuth2.0登录的流程（<a href="https://blog.wei.ai/2020/08/21/使用Passport.js实现Google%20OAuth登录/" target="_blank" rel="noopener">ref</a>），然后自己也写了一个基于OAuth的SSO单点登录模块（<a href="https://blog.wei.ai/2020/12/17/David-Auth%20Spec/" target="_blank" rel="noopener">ref</a>）集成到了自己的几个项目中。最近面试几个大厂都问道了有关OAuth的问题，发现对OAuth一些原理性和安全性的问题还是理解的不是很透彻，在这里继续总结一下：</p><h3 id="什么是OAuth"><a href="#什么是OAuth" class="headerlink" title="什么是OAuth"></a>什么是OAuth</h3><p>OAuth是一种第三方授权协议，委托第三方（e.g. Google，Facebook，Wechat）等对用户进行鉴权，鉴权成功后向应用发送一个信任凭证（即token）。应用可以凭借token去向第三方获取该用户授权开放的身份信息（用户名，邮箱，头像等）。</p><p>OAuth授权只是允许app从第三方处获取部分用户数据等信息，如要实现本地登录等功能，仍然需要app自行将用户信息注册到数据库，并通过session-cookie或JWT登录等方式实现</p><h3 id="OAuth-2-0-流程"><a href="#OAuth-2-0-流程" class="headerlink" title="OAuth 2.0 流程"></a>OAuth 2.0 流程</h3><p>（以下仅展示授权码模式，即Authorization Code）</p><p>简化流程：</p><ol><li>先向google设置redirect_uri名单，并获取appid和secret</li><li>用户发起登录请求，后端将请求重定向到google认证服务器，并附带client_id和redirect_uri</li><li>用户完成google登录，google认证服务器检查redirect_uri是否在名单内，然后重定向至此uri（应用后端）并附带code</li><li>应用后端收到code，使用code, appid和secret向google认证服务器换取token</li><li>后端使用token向google获取用户数据信息，并以此实现自己的注册和登录流程（session-cookie等）</li></ol><h3 id="OAuth解决了哪些安全性问题"><a href="#OAuth解决了哪些安全性问题" class="headerlink" title="OAuth解决了哪些安全性问题"></a>OAuth解决了哪些安全性问题</h3><ol><li><p>为什么使用token而不是将google的账号+密码发送该应用，然后应用通过账号+密码从google获取用户数据</p><p>（即为什么要使用OAuth+Token的形式做第三方授权）</p><ol><li><p>使用账户+密码的缺点（账户泄露、访问权限控制）</p><ul><li>账户密码可能会被不法应用泄露，或者任意一个应用被破解造成泄露</li><li>一个应用可以拥有完整的google账户访问权限，用户无法做出相应限制</li></ul></li><li><p>OAuth + token如何解决上述问题</p><p>如果把账号+密码当做一把永久钥匙，而token则为一把临时钥匙</p><ul><li>Token具有一定的时效，且可以随时由google设置为失效</li><li>可以通过设置scope限制每把token可以获取的用户数据范围</li></ul></li></ol></li><li><p>google为什么要验证回调uri</p><p>OAuth2.0流程第2步重定向至google服务器的过程中，client_id和redirect_uri是可以直接被明文访问到的</p><p>因此攻击者可以以此构建自己的重定向连接，并把redirect_uri替换为自己的服务器后端</p><p>这样当用户完成登录后，假设google不验证redirect_uri是否合法，将直接把code发送给攻击者的后端</p><p>（虽然攻击者即使有了code，如果没有serect仍然无法获取到token，但这相当于多了一道保护屏障）</p></li><li><p>为什么要使用code和secret换token，而不是登录后google直接返回token</p><p>google返回数据（无论是code还是token）的过程中，可能存在以下几种方式使得code或者token泄露：</p><ol><li>google重定向的uri不支持https，则token或code会暴露在从google到应用后端之间途径线路上的所有路由器</li><li>假设后端DNS被污染，token或code会直接被发送到攻击者的服务器</li></ol><p>因此在返回凭据的过程中，使用code和secret作为两道屏障去换取token：</p><ol><li><p>google先向app后端返回code而非token（code可能会因为上述两种方式造成泄露）：</p><p>code只能使用一次，使用第二次时，先前换取的token会自动失效。因此就算攻击者使用code（和通过不知道什么手段获取到的secret）换到了token，当app后端收到code去第二次获取token时，整个code和token都会失效</p></li><li><p>secret只能部署给信任的服务器，服务器以此证明自己是合法的，从而换取token</p></li></ol><p>总结：只返回code，再用code+secret换token，code在重定向的过程中即使泄露，没有secret也无法换取token；即使有了secret，如果使用两次code后token也会自动失效</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写过一篇关于使用Passport.js实现Google OAuth2.0登录的流程（&lt;a href=&quot;https://blog.wei.ai/2020/08/21/使用Passport.js实现Google%20OAuth登录/&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.david916.com/categories/Note/"/>
    
    
      <category term="Web" scheme="http://blog.david916.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>David-Auth Documentation</title>
    <link href="http://blog.david916.com/2020/12/17/David-Auth%20Spec/"/>
    <id>http://blog.david916.com/2020/12/17/David-Auth Spec/</id>
    <published>2020-12-17T15:11:30.941Z</published>
    <updated>2020-12-17T15:54:46.891Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>David-Auth is a SSO login system, which allow the apps under the domain <code>.wei.ai</code> to verify the user identity throw Json Web Token (JWT). The system currently support login ways through email / password, and Google / Facebook OAuth 2.0.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/12/17/K9ANYMU2mVeioSj.png" alt="David-Auth.png" title>                </div>                <div class="image-caption">David-Auth.png</div>            </figure><p><a href="https://test.wei.ai/" target="_blank" rel="noopener">Demo</a></p><p><a href="https://github.com/fssongwei/David-Auth" target="_blank" rel="noopener">Github</a></p><h3 id="Link-To-Login-Panel"><a href="#Link-To-Login-Panel" class="headerlink" title="Link To Login Panel"></a>Link To Login Panel</h3><p>To utilize the David-Auth, the app can set their login link direct to the David-Auth login system on <code>https://auth.wei.ai</code>. A url query string with parameter <code>origin</code> is required (it tells the auth server to redirect back to your app after authorization process finished, otherwise the login panel will show a error message). For example, if your app is running on <code>https://myapp.wei.ai</code>，simply construct the following link: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://auth.wei.ai/?origin=https://myapp.wei.ai"</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="App-Backend-Configuration"><a href="#App-Backend-Configuration" class="headerlink" title="App Backend Configuration"></a>App Backend Configuration</h3><p>After users finish their authorization process, the auth server will issue a JWT token stored in the cookie (which the domain has configured as <code>.wei.ai</code>). The JWT contains the following user data:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">name: String,</span><br><span class="line">  avatar: String,</span><br><span class="line">  googleUserId: String,</span><br><span class="line">  facebookUserId: String,</span><br><span class="line">email: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Detail user infomation data can also be accessed through <code>https://auth.wei.ai/user</code> (JWT Cookie Required)</p><p>The JWT cookie is now set to client browser and will be sent to the app backend server for every request. The app server can extract the JWT from the request cookie header and then verify.</p><p>The JWT issued by the auth server is signed and encrypt by the RSA key. The public key is provided below and can be used to verify if JWT is real:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4Dppu06ECcPsnsr4/nnrRjscF</span><br><span class="line">QuqdeFd2fwYzzvP4pQSt41p0/Dl0kSuqN56eGBKsW8/l3bWdAsLAVLPBSRvWjaor</span><br><span class="line">A0ff0dteK9/RUGIKNLeq39LxV3p8wGnezA9mmY5I2o8HcQxR2jVPbzFGZYEMbmiB</span><br><span class="line">gSDJp94pgfhExoyILQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><p>(You can save the public key into a <code>pub.key</code> file)</p><p>The following example shows the JWT authentication process of a Express App using Passport.js and <code>passport-jwt</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// passportConfig.js</span></span><br><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">"passport"</span>);</span><br><span class="line"><span class="keyword">const</span> JwtStrategy = <span class="built_in">require</span>(<span class="string">"passport-jwt"</span>).Strategy;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> opts = &#123;&#125;;</span><br><span class="line"><span class="comment">// Extract JWT from cookie</span></span><br><span class="line">opts.jwtFromRequest = <span class="function"><span class="keyword">function</span> (<span class="params">req</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> token = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (req &amp;&amp; req.cookies) &#123;</span><br><span class="line">    token = req.cookies[<span class="string">"jwt"</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> token;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// using the public key to verify JWT</span></span><br><span class="line"><span class="keyword">let</span> pubKey = fs.readFileSync(<span class="string">"./keys/pub.key"</span>);</span><br><span class="line">opts.secretOrKey = pubKey;</span><br><span class="line"></span><br><span class="line">passport.use(</span><br><span class="line">  <span class="keyword">new</span> JwtStrategy(opts, (jwt_payload, done) =&gt; &#123;</span><br><span class="line">    <span class="comment">// append the jwt payload data to req.user</span></span><br><span class="line">    done(<span class="literal">null</span>, jwt_payload.data);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">"cookie-parser"</span>);</span><br><span class="line">app.use(cookieParser());</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./passportConfig"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... other config &amp; middlewares</span></span><br><span class="line"></span><br><span class="line">router.get(</span><br><span class="line">  <span class="string">"/someSerectRequest"</span>,</span><br><span class="line">  <span class="comment">// use passport.js JWT middlewares to process authentication</span></span><br><span class="line">  passport.authenticate(<span class="string">"jwt"</span>, &#123; <span class="attr">session</span>: <span class="literal">false</span> &#125;),</span><br><span class="line">  (req, res) =&gt; &#123;</span><br><span class="line">    <span class="comment">// user is authenticated, process the request</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;David-Auth is a SSO login syst
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Web" scheme="http://blog.david916.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Time Tracker - A mobile time tracking app</title>
    <link href="http://blog.david916.com/2020/10/31/TimeTracker/"/>
    <id>http://blog.david916.com/2020/10/31/TimeTracker/</id>
    <published>2020-10-31T03:30:39.434Z</published>
    <updated>2020-11-05T14:04:58.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Time Tracker is an app that helps you to keep track of your daily routine and stay focus. Users can time what they have done in a day. The app will automatically store those records, lists them and analyzes them, and using different well-designed charts to display the results, so that user can have an intuitive knowledge of how much time they have been spending in a specific task, and what are the most time-consuming tasks in a day. For example, I can know if I spend too much time playing games instead of reading books. Meanwhile, when the app is timing, the user can not use the phone (or the timer will stop), which helps users to focus on what they are doing right now.</p><p><a href="https://github.com/fssongwei/TimeTracker" target="_blank" rel="noopener">Github</a></p><p><a href="https://expo.io/@fssongwei/projects/TimeTracker" target="_blank" rel="noopener">Expo</a></p><p><a href="https://timetracker.wei.ai/assets/dist/file/TimeTracker.apk" target="_blank" rel="noopener">Android APK</a></p><p><a href="https://timetracker.wei.ai" target="_blank" rel="noopener">Website</a></p><h2 id="Technologies"><a href="#Technologies" class="headerlink" title="Technologies"></a>Technologies</h2><p>The app is built on React Native with Expo. User data are stored in the AsyncStorage in the local environment, and managed by redux. We choose Ant Design Mobile Native for the UI library. The charts are render by react-native-chart-kit &amp; react-native-svg-charts.</p><h2 id="Functionality"><a href="#Functionality" class="headerlink" title="Functionality"></a>Functionality</h2><ol><li>Add a task recorder (or timer), and user can choose color to label it.</li><li>Timing what the user is doing right now with the specific timer.</li><li>Record and store all the timing results.</li><li>List the timing records. The records are also mark with user pre-defined color.</li><li>User can filter the records with specific date or task.</li><li>Using pie chart to show the time duration distribution of each task in a day / week / month / year.</li><li>Using contribution map (heatmap) to show the activities of recent months.</li><li>Trend function: how much more (or less) time you have spent on a task in this week compares to lask weeks.</li><li>Clear All function: user can delete all records and timer data by one click.</li></ol><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><img src="https://i.loli.net/2020/10/31/9lQ3rTqs8dZWhLz.png" alt="index.png" style="zoom:50%;"><img src="https://i.loli.net/2020/10/31/WqHmfJp1McTECwz.png" alt="add.png" style="zoom:50%;"><img src="https://i.loli.net/2020/10/31/KcsMYOSUkJD3LwQ.png" alt="record.png" style="zoom:50%;"><img src="https://i.loli.net/2020/10/31/DXdimv6PBlxw2hj.png" alt="analysis.png" style="zoom:50%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Time Tracker is an app that he
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://blog.david916.com/tags/React/"/>
    
      <category term="ReactNative" scheme="http://blog.david916.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>Classic Bubble Breaker Game</title>
    <link href="http://blog.david916.com/2020/10/07/Bubble%20Breaker/"/>
    <id>http://blog.david916.com/2020/10/07/Bubble Breaker/</id>
    <published>2020-10-07T09:39:38.204Z</published>
    <updated>2020-10-07T09:50:21.431Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>This project is a classic bubble breaker game built on React. While user click on a ball (or a bubble), the game runs the DFS algorithm to find all the other ball that with the same color and connected to it. Once the user click again, the bubbles block wil be eliminated.</p><p>This project uses redux to manange the bubble board status. It also implemented the undo function, which allows users to go back one step after they break a bubble block.</p><p>I also plan to develop an iOS / Android version using react-native, and a wechat widget version using Taro.</p><p><a href="https://github.com/fssongwei/Bubble-Breaker" target="_blank" rel="noopener">github</a></p><p><a href="http://bubble-breaker.wei.ai" target="_blank" rel="noopener">demo</a></p><p><img src="https://i.loli.net/2020/10/07/KDhLA2FZnXuVzpa.png" alt="Bubble Breaker"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;This project is a classic bubb
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://blog.david916.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>iShop - A MERN stack Online Shopping Mall App</title>
    <link href="http://blog.david916.com/2020/09/22/iShop/"/>
    <id>http://blog.david916.com/2020/09/22/iShop/</id>
    <published>2020-09-22T13:31:38.000Z</published>
    <updated>2020-09-26T14:27:30.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>iShop is an online shopping mall web app built on React, Redux &amp; Material UI (Front-end) and Express &amp; MongoDb (Back-end), which implemented the following features:</p><ol><li>Implemented Google and Facebook OAuth 2.0 login &amp; User Register with Passport.js</li><li>User can create product information (includes product intro / category / price / remain amount / photos) to sell their products</li><li>Implemented the credit card payment with Stripe.js. Buyer can add or update the shopping cart, and check out with credit card to buy the products</li><li>Both buyer and seller can manage their transactions and orders through a dashboard</li></ol><p>The app is deployed at Google Cloud Platform using Google App Engine</p><p><a href="https://shop.wei.ai" target="_blank" rel="noopener">Demo</a></p><p><a href="https://github.com/fssongwei/iShop-Client" target="_blank" rel="noopener">Source Code - Front-end</a></p><p><a href="https://github.com/fssongwei/iShop-Server" target="_blank" rel="noopener">Source Code - Back-end</a></p><h3 id="Final-Product"><a href="#Final-Product" class="headerlink" title="Final Product"></a>Final Product</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/22/NSfP2y5t3vodGAn.png" alt="Landing Page & Cart" title>                </div>                <div class="image-caption">Landing Page & Cart</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/22/zW3SewQqYArtLby.png" alt="Product Display" title>                </div>                <div class="image-caption">Product Display</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/22/9jPG46JNolquCdz.png" alt="Checkout" title>                </div>                <div class="image-caption">Checkout</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/22/G7X65t3NTbZDQfy.png" alt="iSell Manage Dashboard" title>                </div>                <div class="image-caption">iSell Manage Dashboard</div>            </figure><p><strong>Read the design and thinking behind this project (in Chinese): <a href="https://blog.wei.ai/2020/09/20/从零开始用MERN搭建一个电商网站/" target="_blank" rel="noopener">link</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;iShop is an online shopping ma
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://blog.david916.com/tags/React/"/>
    
      <category term="Express" scheme="http://blog.david916.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>从零开始用MERN搭建一个电商网站</title>
    <link href="http://blog.david916.com/2020/09/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%94%A8MERN%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99/"/>
    <id>http://blog.david916.com/2020/09/22/从零开始用MERN搭建一个电商网站/</id>
    <published>2020-09-22T13:27:17.000Z</published>
    <updated>2020-12-20T16:27:17.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>最近接触到MERN技术栈，想做一个全栈的项目练练手。正好之前在上网课的时候有提到如何使用第三方服务如stripe搭建一个支付系统，把这个支付系统拓展一下就可以变为一个电商网站（或者二手交易网站）了。整个项目大概花了一星期不到的时间（周一到周六完成开发，周日写这篇文章），一开始以为会是一个简单的CRUD应用，然而做的时候才体会到该项目的复杂性，有很多模块之间相互影响，还有很多安全性、跨域问题需要考虑。感觉现在前端的功能还是非常强大的，基本上很多业务逻辑都可以在前端完成，然后通过RESTFul api从后台获取所需数据即可，开发时间相对以往则大大缩短。该项目虽然简单，但也实现了基本的电商网站功能比如用户登录、卖家创建和管理商品，购物车功能，商品支付与结算，订单管理等功能，整个项目代码量大概在3000多行。</p><p><a href="https://shop.wei.ai" target="_blank" rel="noopener">Demo</a></p><p><a href="https://github.com/fssongwei/iShop-Client" target="_blank" rel="noopener">Source Code - Front-end</a></p><p><a href="https://github.com/fssongwei/iShop-Server" target="_blank" rel="noopener">Source Code - Back-end</a></p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>该项目主要分为用户认证、商品、购物车、支付和订单管理五个模块，采用前后端分离的模式，前端使用axios通过api获取后端数据。前后端的文件结构如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Client</span></span><br><span class="line">├── public</span><br><span class="line">│   └── index.html</span><br><span class="line">└── src</span><br><span class="line">    ├── actions</span><br><span class="line">    │   ├── index.js</span><br><span class="line">    │   └── types.js</span><br><span class="line">    ├── components</span><br><span class="line">    │   ├── App.js</span><br><span class="line">    │   ├── Authentication</span><br><span class="line">    │   │   ├── Login.js</span><br><span class="line">    │   │   └── OAuthPanel.js</span><br><span class="line">    │   ├── Cart</span><br><span class="line">    │   │   ├── CartHooks.js</span><br><span class="line">    │   │   ├── CartMenu.js</span><br><span class="line">    │   │   ├── CartMenuItem.js</span><br><span class="line">    │   │   └── Checkout.js</span><br><span class="line">    │   ├── Checkout</span><br><span class="line">    │   │   ├── CardSection.js</span><br><span class="line">    │   │   ├── Checkout.js</span><br><span class="line">    │   │   ├── CheckoutForm.css</span><br><span class="line">    │   │   ├── CheckoutForm.js</span><br><span class="line">    │   │   ├── InjectedCheckoutForm.js</span><br><span class="line">    │   │   ├── OrderDetail</span><br><span class="line">    │   │   │   ├── AddressForm.js</span><br><span class="line">    │   │   │   ├── Index.js</span><br><span class="line">    │   │   │   └── OrderList.js</span><br><span class="line">    │   │   └── Success.js</span><br><span class="line">    │   ├── Dashboard</span><br><span class="line">    │   │   ├── BuyList.js</span><br><span class="line">    │   │   ├── ComfirmShipment.js</span><br><span class="line">    │   │   ├── FieldFileInput.js</span><br><span class="line">    │   │   ├── IBuy.js</span><br><span class="line">    │   │   ├── OrderDetail.js</span><br><span class="line">    │   │   ├── SellList.js</span><br><span class="line">    │   │   ├── hooks.js</span><br><span class="line">    │   │   └── iSell.js</span><br><span class="line">    │   ├── Header</span><br><span class="line">    │   │   ├── Header.js</span><br><span class="line">    │   │   └── HeaderMenu.js</span><br><span class="line">    │   ├── Landing</span><br><span class="line">    │   │   ├── Filter.js</span><br><span class="line">    │   │   ├── Landing.js</span><br><span class="line">    │   │   └── Searchbar.js</span><br><span class="line">    │   ├── Message.js</span><br><span class="line">    │   └── Products</span><br><span class="line">    │       ├── ProductCreate.js</span><br><span class="line">    │       ├── ProductDetail.js</span><br><span class="line">    │       ├── ProductEdit.js</span><br><span class="line">    │       ├── ProductForm.js</span><br><span class="line">    │       ├── ProductHooks.js</span><br><span class="line">    │       └── ProductList.js</span><br><span class="line">    ├── history.js</span><br><span class="line">    ├── hooks</span><br><span class="line">    │   ├── useProduct.js</span><br><span class="line">    │   ├── useProducts.js</span><br><span class="line">    │   └── useUser.js</span><br><span class="line">    ├── index.js</span><br><span class="line">    ├── reducers</span><br><span class="line">    │   ├── authReducer.js</span><br><span class="line">    │   ├── cartReducer.js</span><br><span class="line">    │   ├── index.js</span><br><span class="line">    │   └── messageReducer.js</span><br><span class="line">    ├── resources</span><br><span class="line">    │   └── categories.js</span><br><span class="line">    └── store.js</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> Server</span></span><br><span class="line">├── index.js</span><br><span class="line">├── middlewares</span><br><span class="line">│   └── requireLogin.js</span><br><span class="line">├── models</span><br><span class="line">│   ├── Cart.js</span><br><span class="line">│   ├── Order.js</span><br><span class="line">│   ├── Product.js</span><br><span class="line">│   ├── Transaction.js</span><br><span class="line">│   └── User.js</span><br><span class="line">├── routers</span><br><span class="line">│   ├── auth.js</span><br><span class="line">│   ├── cart.js</span><br><span class="line">│   ├── order.js</span><br><span class="line">│   ├── payment.js</span><br><span class="line">│   └── product.js</span><br><span class="line">└── services</span><br><span class="line">    └── createPayment.js</span><br></pre></td></tr></table></figure><h3 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h3><h4 id="用户数据和认证模块"><a href="#用户数据和认证模块" class="headerlink" title="用户数据和认证模块"></a>用户数据和认证模块</h4><p>该模块主要负责将新用户注册到数据库，并在前端通过api获取数据时验证用户身份。这一部分为了减轻项目复杂度，我就没有实现用户名和密码注册登录，而是通过Passport.js使用Google和Facebook OAuth进行验证登录。</p><ol><li><p>后端设置一个PassportConfig负责配置passport.js，注册用户，序列化和反序列化用户信息等操作</p><p>（需要先从google developer console获取client-secret和clientID，并在console中配置app url和callback url）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/passportConfig.js</span></span><br><span class="line"><span class="comment">// 1. 创建Strategy</span></span><br><span class="line"><span class="keyword">const</span> gStrategy = <span class="keyword">new</span> GoogleStrategy(</span><br><span class="line">  &#123;</span><br><span class="line">    clientID: process.env.GOOGLE_CLIENT_ID, <span class="comment">// provided by GCP console</span></span><br><span class="line">    clientSecret: process.env.GOOGLE_CLIENT_SECRET,<span class="comment">// provided by GCP console</span></span><br><span class="line">    callbackURL: process.env.GOOGLE_CALLBACK_URL, <span class="comment">// need to be configured in GCP console</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> (accessToken, refreshToken, profile, done) =&gt; &#123; <span class="comment">// 用户授权后，google返回用户数据（在profile中）</span></span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 根据profile中的googleUserId在用户数据库中查找用户</span></span><br><span class="line">      <span class="keyword">let</span> user = <span class="keyword">await</span> User.findOne(&#123; <span class="attr">googleUserId</span>: profile.id &#125;);</span><br><span class="line">      <span class="comment">// ... 判断用户数据库中是否存在user，如果不存在则注册一个新user</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) done(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 2. 序列化和反序列化用户（将用户数据存储在cookie / 从cookie中提取用户数据）</span></span><br><span class="line">passport.serializeUser(<span class="function">(<span class="params">user, done</span>) =&gt;</span> &#123;</span><br><span class="line">  done(<span class="literal">null</span>, user.id);</span><br><span class="line">&#125;);</span><br><span class="line">passport.deserializeUser(<span class="keyword">async</span> (id, done) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> User.findById(id);</span><br><span class="line">    done(<span class="literal">null</span>, user);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) done(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(补充：大陆用户无法直接使用Google服务，因此需要设置代理（如果server部署在大陆服务器上）)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ only required <span class="keyword">in</span> dev environment since I deployed the production environment <span class="keyword">in</span> Google App Engine</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">"development"</span>) &#123; </span><br><span class="line">  <span class="keyword">var</span> HttpsProxyAgent = <span class="built_in">require</span>(<span class="string">"https-proxy-agent"</span>);</span><br><span class="line">  <span class="keyword">const</span> agent = <span class="keyword">new</span> HttpsProxyAgent(</span><br><span class="line">    process.env.HTTP_PROXY || <span class="string">"YOUR_PROXY_ADDRESS"</span></span><br><span class="line">  );</span><br><span class="line">  gStrategy._oauth2.setAgent(agent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>设置登录和callback路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/routers/auth.js</span></span><br><span class="line">router.get(<span class="string">"/auth/google"</span>, passport.authenticate(<span class="string">"google"</span>, &#123; <span class="attr">scope</span>: [<span class="string">"profile"</span>] &#125;));</span><br><span class="line">router.get( <span class="string">"/auth/google/callback"</span>,</span><br><span class="line">  passport.authenticate(<span class="string">"google"</span>), <span class="comment">// 认证并设置cookie</span></span><br><span class="line">  (req, res) =&gt; res.redirect(<span class="string">`<span class="subst">$&#123;process.env.CLIENT_BASE_URL&#125;</span>`</span>); <span class="comment">// 重定向至前端URL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>用户在前端登录时跳转到<code>/auth/google</code>，会重定向至google验证页面。用户完成授权后，会从验证页面重定向回<code>/auth/google/callback</code>并携带授权码code，然后passport使用code获取用户profile等信息，完成用户认证或注册，设置cookie并重定向回前端相应页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录route</span></span><br><span class="line">router.get(<span class="string">"/auth/user"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.isAuthenticated()) res.status(<span class="number">200</span>).send(req.user._doc);</span><br><span class="line">  <span class="keyword">else</span> res.status(<span class="number">401</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"User is not login!"</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 退出登录route</span></span><br><span class="line">router.get(<span class="string">"/auth/logout"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  req.logOut();</span><br><span class="line">  res.status(<span class="number">200</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"Log out success!"</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>前端在Landing Page，以及每个需要登录后才可访问的页面组件中调用<code>GET /auth/user</code> API检查用户登录情况，并将用户数据以全局的方式存储在redux中，以供后续组件访问</p><p>Action Creator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/src/actions/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchAuthStatus = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">async</span> (dispatch) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> axios.get(<span class="string">`<span class="subst">$&#123;process.env.REACT_APP_API_BASE_URL&#125;</span>/auth/user`</span>);</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: FETCH_AUTH_STATUS, <span class="attr">user</span>: user.data &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) dispatch(&#123; <span class="attr">type</span>: FETCH_AUTH_STATUS, <span class="attr">user</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Reducer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> authReducer = <span class="function">(<span class="params">state = [<span class="literal">true</span>, <span class="literal">null</span>], action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === FETCH_AUTH_STATUS) <span class="keyword">return</span> [<span class="literal">false</span>, action.user];</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>OAuth登录具体原理可以在我之前的blog (<a href="https://blog.wei.ai/2020/08/20/使用Passport.js实现Google%20OAuth登录/" target="_blank" rel="noopener">link</a>)中查看。</p><h4 id="商品模块"><a href="#商品模块" class="headerlink" title="商品模块"></a>商品模块</h4><p>这部分主要涉及商品的CRUD操作，相对比较基础，不过也涉及到一些redux-form表单等技术的使用，同时还实现了fuzzy-search模糊检索的功能</p><ol><li><p>商品数据结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> productSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  owner: &#123; <span class="attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">"User"</span> &#125;, <span class="comment">// 创建者</span></span><br><span class="line">  name: <span class="built_in">String</span>, <span class="comment">// 商品名</span></span><br><span class="line">  intro: <span class="built_in">String</span>, <span class="comment">// 商品介绍</span></span><br><span class="line">  price: <span class="built_in">Number</span>, <span class="comment">// 商品单价</span></span><br><span class="line">  quantity: <span class="built_in">Number</span>, <span class="comment">// 库存数量</span></span><br><span class="line">  category: <span class="built_in">String</span>, <span class="comment">// 商品分类</span></span><br><span class="line">  pics: [<span class="built_in">String</span>], <span class="comment">// 商品图片URL列表</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>商品列表获取</p><p>这里我设置了一个query参数，以便前端获取商品列表时筛选所需数据。e.g. 设置<code>query={category: &quot;sport&quot;}</code>可以指定获取category为sport的数据，<code>query={term: &quot;iphone 12&quot;}</code>可以执行fuzzy search等</p><p>因为前端在多处可能会用到商品列表，所以我写了一个通用化的ProductList组件（篇幅太长就不在这放代码，路径为<code>/client/src/components/Products/ProductList.js</code> <a href="https://github.com/fssongwei/iShop-Client/blob/master/src/components/Products/ProductList.js" target="_blank" rel="noopener">link</a>）</p><p>具体而言，该组件从上层组件中接收一个query props，并从redux中获得user登录数据，以及两个action creator <code>popMessage</code> &amp; <code>setCartItem</code> 分别负责弹出提示和添加购物车（后续会补充）。该组件使用一个products hook通过调用异步api获取数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client/src/components/hooks/useProducts.js</span></span><br><span class="line"><span class="keyword">const</span> useProducts = <span class="function">(<span class="params">query</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [products, setProducts] = useState(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchProducts = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(<span class="string">`<span class="subst">$&#123;process.env.REACT_APP_API_BASE_URL&#125;</span>/products`</span>,</span><br><span class="line">          &#123;<span class="attr">params</span>: query,&#125;</span><br><span class="line">        );</span><br><span class="line">        setProducts(response.data);</span><br><span class="line">        setLoading(<span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;;</span><br><span class="line">    fetchProducts();</span><br><span class="line">  &#125;, [query]);</span><br><span class="line">  <span class="keyword">return</span> [loading, products];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后端route</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/products"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> products = &#123;&#125;;</span><br><span class="line">    <span class="comment">// fuzzy search 这里需要安装mongoose_fuzzy_searching包并设置对应的Product Schema</span></span><br><span class="line">    <span class="keyword">if</span> (req.query.term === <span class="string">""</span>) products = <span class="keyword">await</span> Product.find();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.query.term) products = <span class="keyword">await</span> Product.fuzzySearch(req.query.term);</span><br><span class="line">    <span class="keyword">else</span> products = <span class="keyword">await</span> Product.find(req.query);</span><br><span class="line">    res.status(<span class="number">200</span>).send(products);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) res.status(<span class="number">500</span>).send(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>显示商品信息</p><p>使用一个product hook异步调用<code>GET /product/:id</code> API获取具体的商品数据，并使用一个ProductDetail组件显示商品数据</p><p>注意这里ProductDetail组件同时通过redux接收user信息，判断如果该商品由该登录用户所创建，则显示修改商品的按钮，反之则显示添加购物车按钮</p><p>另外还使用了<code>react-material-ui-carousel</code>库用于滚动播放产品图片</p><p>useProduct Hook</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useProduct = <span class="function">(<span class="params">productId</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [product, setProduct] = useState(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = useState(<span class="literal">true</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchProduct = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(</span><br><span class="line">          <span class="string">`<span class="subst">$&#123;process.env.REACT_APP_API_BASE_URL&#125;</span>/products/<span class="subst">$&#123;productId&#125;</span>`</span></span><br><span class="line">        );</span><br><span class="line">        setProduct(response.data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) <span class="built_in">console</span>.log(error);</span><br><span class="line">      setLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    fetchProduct();</span><br><span class="line">  &#125;, [productId]);</span><br><span class="line">  <span class="keyword">return</span> [loading, product];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>GET Product route</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/products/:id"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> product = <span class="keyword">await</span> Product.findById(req.params.id);</span><br><span class="line">    <span class="keyword">if</span> (!product) res.status(<span class="number">404</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"Product not found"</span> &#125;);</span><br><span class="line">    <span class="keyword">else</span> res.status(<span class="number">200</span>).send(product);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>创建和修改商品</p><p>创建和修改可以在前端共享一个ProductForm表单组件，通过使用redux-form管理该表单。</p><p>对于修改表单，则可设置reduxForm的enableReinitialize为true，通过使用useProduct Hook获取product数据后作为initialValues props传入到ProductForm组件中即可。共享该表单组件可以减轻许多任务量。</p><p>另外在后台需要设置两个middlewares <code>requireLogin</code> 和 <code>productUpdateCheck</code> 来检验用户是否登录，用户是否有权限修改该商品，以及用户所更新的信息是否合法等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requireLogin = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (req.isAuthenticated()) next();</span><br><span class="line">  <span class="keyword">else</span> res.status(<span class="number">400</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"Unauthorize access!"</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> productUpdateCheck = <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> product = req.body;</span><br><span class="line">  <span class="keyword">if</span> (!product.name || !product.intro || !product.price ||!product.quantity ||!product.pics ||!product.category) &#123;</span><br><span class="line">    res.status(<span class="number">400</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"Invalid product submit!"</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  product.owner = req.user; <span class="comment">// add product owner</span></span><br><span class="line">  req.product = product;</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>删除商品</p><p>该部分比较简单，只需要从数据库中找到商品，验证商品是否由该用户创建，并删除即可。通过使用一个productOwnershipCheck中间件验证该商品的发布者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> productOwnershipCheck = <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> productId = req.params.id;</span><br><span class="line">    <span class="keyword">let</span> product = <span class="keyword">await</span> Product.findById(productId).populate(<span class="string">"owner"</span>).exec();</span><br><span class="line">    <span class="keyword">if</span> (req.user.id !== product.owner.id)</span><br><span class="line">      req.status(<span class="number">400</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"Unauthorized access!"</span> &#125;);</span><br><span class="line">    <span class="keyword">else</span> next();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    res.status(<span class="number">500</span>).send(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="购物车模块"><a href="#购物车模块" class="headerlink" title="购物车模块"></a>购物车模块</h4><p>这个模块设计到与其他多个模块之间（如用户数据模块、商品模块和后面支付模块）的数据交互，即这些模块都可以影响到购物车模块中的数据，比如用户可以在商品模块中将商品添加到购物车，支付模块需要提取购物车中的商品数据进行结算，同时购物车需要将其中的商品数据定时上传到用户数据模块，以供用户下次登录时使用。个人感觉该模块是这个商城应用中最复杂也是最容易出bug的部分。</p><ol><li><p>该模块的数据通过redux存储在store中以供全局访问，包括两个action creator: <code>setCartItem</code> 和 <code>fetchCartItems</code>：</p><ul><li><code>setCartItem</code>接收一个product对象和amount数值作为参数，用于设置购物车中某样商品的数量</li><li><code>fetchCartItems</code>从后端获取购物车数据（见第三点）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setCartItem = <span class="function">(<span class="params">product, amount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> payload = &#123;&#125;;</span><br><span class="line">  payload.product = product;</span><br><span class="line">  payload.amount = amount;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: SET_CART, <span class="attr">payload</span>: payload &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchCartItems = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">async</span> (dispatch) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> axios.get(<span class="string">`<span class="subst">$&#123;process.env.REACT_APP_API_BASE_URL&#125;</span>/cart`</span>);</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: FETCH_CART_ITEMS, <span class="attr">items</span>: res.data &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducers/cartReducer</span></span><br><span class="line"><span class="keyword">const</span> cartReducer = <span class="function">(<span class="params">state = <span class="literal">null</span>, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === FETCH_CART_ITEMS) <span class="keyword">return</span> action.items;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (action.type === SET_CART) &#123;</span><br><span class="line">    <span class="keyword">let</span> updateItem = action.payload;</span><br><span class="line">    <span class="keyword">let</span> newState = [...state];</span><br><span class="line">    <span class="keyword">let</span> hasItem = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> newState) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.product._id === updateItem.product._id) &#123;</span><br><span class="line">        hasItem = <span class="literal">true</span>;</span><br><span class="line">        item.amount = updateItem.amount;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!hasItem) newState.push(updateItem);</span><br><span class="line">    newState = newState.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.amount &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>后端将购物车中的数据存储到cart数据库中，该数据结构包含购物车所有者userId，以及一个items数组，用于存储每个在购物车中的商品productId以及数量amount：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server/models/Cart.js</span></span><br><span class="line"><span class="keyword">const</span> cartSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  userId: <span class="built_in">String</span>,</span><br><span class="line">  items: [</span><br><span class="line">    &#123;</span><br><span class="line">      productId: <span class="built_in">String</span>,</span><br><span class="line">      amount: <span class="built_in">Number</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>cart在redux中的初始值为null，当值为null时，购物车需要使用<code>fetchCartItems</code>异步调用api获取上次用户访问所保存的购物车中的商品数据并保存在store中</p></li><li><p>创建一个CartMenu组件用于展示cart中的商品信息。对每个购物车中的商品，设置一组可以调节商品数量的按钮：</p><p>(注意该组件在后面结算过程中还会用到，因此需要通用化的设计)</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; &#123;e.preventDefault(); removeItem(); &#125;&#125; &gt; Delete &lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;(e) =&gt; &#123;e.preventDefault(); addItem();&#125;&#125; &gt; Add &lt;/</span>button&gt;</span><br><span class="line">&lt;input</span><br><span class="line">  type=<span class="string">"number"</span></span><br><span class="line">  value=&#123;item.amount&#125;</span><br><span class="line">  <span class="comment">// 这里限制了商品数量不能设置为小于或等于0</span></span><br><span class="line">  onChange=&#123;(e) =&gt; &#123;<span class="keyword">if</span> (<span class="built_in">Number</span>(e.target.value) &gt; <span class="number">0</span>) setAmount(<span class="built_in">Number</span>(e.target.value));&#125;&#125;</span><br><span class="line">  onClick=&#123;(e) =&gt; e.preventDefault()&#125;</span><br><span class="line">/&gt;</span><br><span class="line">&lt;button onClick=&#123;(e) =&gt; &#123;e.preventDefault(); reduceItem();&#125;&#125; &gt; Decrease &lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>当用户点击加减或删除按钮，或者直接输入数字时，通过调用对应的listener或useEffect函数，使用<code>setCartItem</code> action creator对在redux中的cart数据进行更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addItem = <span class="function"><span class="params">()</span> =&gt;</span> setAmount(<span class="built_in">Number</span>(amount) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> reduceItem = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">if</span> (<span class="built_in">Number</span>(amount) - <span class="number">1</span> &gt; <span class="number">0</span>) setAmount(<span class="built_in">Number</span>(amount) - <span class="number">1</span>);&#125;;</span><br><span class="line"><span class="keyword">const</span> removeItem = <span class="function"><span class="params">()</span> =&gt;</span> setAmount(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="function"><span class="params">()</span> =&gt;</span> dispatch(setCartItem(item.product, amount));</span><br><span class="line">  func();</span><br><span class="line">&#125;, [amount]);</span><br></pre></td></tr></table></figure></li><li><p>使用一个useEffect函数监听cart的变化并将cart中数据更新到后端数据库中：</p><p>（这里使用一个timer防止抖动，当用户停止修改购物车一段时间后才进行更新，避免频繁的api调用）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cart === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> update = <span class="function">(<span class="params">cartItems</span>) =&gt;</span> updateCart(cartItems);</span><br><span class="line">  <span class="keyword">const</span> timerID = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cartItems = cart.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        productId: item.product._id,</span><br><span class="line">        amount: item.amount,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    update(cartItems);</span><br><span class="line">  &#125;, <span class="number">5000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;clearTimeout(timerID);&#125;;</span><br><span class="line">&#125;, [cart]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> updateCart = <span class="keyword">async</span> (cart) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> axios.post(<span class="string">`<span class="subst">$&#123;process.env.REACT_APP_API_BASE_URL&#125;</span>/cart?_method=PUT`</span>, cart);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>后端route获取或更新cart</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/cart"</span>, requireLogin, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cart = <span class="keyword">await</span> Cart.findOne(&#123; <span class="attr">userId</span>: req.user.id &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!cart) cart = <span class="keyword">await</span> Cart.create(&#123; <span class="attr">userId</span>: req.user.id, <span class="attr">items</span>: [] &#125;); <span class="comment">// 当购物车不存在时创建购物车</span></span><br><span class="line">    cart.items = <span class="keyword">await</span> checkItems(cart.items);</span><br><span class="line">    <span class="keyword">await</span> cart.save();</span><br><span class="line">    <span class="keyword">let</span> cartItemsWithProduct = <span class="keyword">await</span> getCartItemsWithProduct(cart.items); <span class="comment">// 获取购物车中的商品数据</span></span><br><span class="line">    res.status(<span class="number">200</span>).send(cartItemsWithProduct);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.put(<span class="string">"/cart"</span>, requireLogin, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> items = <span class="keyword">await</span> checkItems(req.body);</span><br><span class="line">    <span class="keyword">let</span> cart = &#123; <span class="attr">userId</span>: req.user.id, <span class="attr">items</span>: items &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get cart</span></span><br><span class="line">    <span class="keyword">await</span> Cart.findOneAndUpdate(&#123; <span class="attr">userId</span>: req.user.id &#125;, cart, &#123;</span><br><span class="line">      upsert: <span class="literal">true</span>,</span><br><span class="line">      useFindAndModify: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.status(<span class="number">200</span>).send(cart);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里使用了两个函数，由于篇幅太长不放代码在此，有兴趣可以参阅源码。其中，getCartItemsWithProduct负责获取cart中商品的详细数据（因为存储在cart中的仅为productId）并整理成数组发送，checkItems负责检查添加到cart中的商品数据是否和商品数据库中的数据一致，防止在传送途中被恶意修改</p></li></ol><h4 id="支付模块"><a href="#支付模块" class="headerlink" title="支付模块"></a>支付模块</h4><p>该模块主要使用stripe.js实现支付功能，需要比较强的安全性。整个check out的过程分为两步：用户点击check out按钮后，从redux中提取购物车的数据，并让用户填写送货地址表单。之后后端需要验证该交易是否合法（验证商品信息和金额等是否被篡改），然后使用stripe创建一个新的支付订单，用户在前端通过stripe完成支付后，后端服务器通过webhook收到stripe发来的订单确认信息，并将订单标记为“已支付”状态</p><ol><li><p>确认和创建订单：这里我们使用一个OrderDetail组件，其中包含AddressForm和OrderList两个组件</p><ul><li>AddressForm组件使用一个redux-form来创建address表单</li><li>OrderList组件包含之前购物车模块中的CartMenu组件，用于显示购物车中的商品数据</li></ul><p>另外我们需要在前端对address表单和cart中的数据进行验证：</p><ul><li><p>创建一个disableButton的state，默认值为false</p></li><li><p>使用一个useEffect函数监听address和cart，只有当两者都合法时才将disableButton设为ture，从而允许点击Next按钮</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (cart === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (cart.length === <span class="number">0</span>) history.push(<span class="string">"/"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!address || !address.firstName || !address.lastName || !address.address1 || </span><br><span class="line">    !address.city || !address.state || !address.zip || !address.country) <span class="keyword">return</span>;</span><br><span class="line">  setDisableButton(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> cart) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.amount &gt; item.product.quantity) &#123;</span><br><span class="line">      setDisableButton(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [address, cart]);</span><br></pre></td></tr></table></figure></li><li><p>信用卡支付页面：当用户点击next按钮后，将cart和address数据打包成一个transaction对象post到后端<code>/payment</code></p><p>后端验证商品信息后在数据库中创建订单，并使用stripe创建一个PaymentIntent对象（stripe用于管理每笔支付的对象），并将其中的client_secret返回给前端：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client checkoutForm.js</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Create PaymentIntent as soon as the page loads</span></span><br><span class="line">  <span class="keyword">const</span> fetchClientSecret = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.post(</span><br><span class="line">      <span class="string">`<span class="subst">$&#123;process.env.REACT_APP_API_BASE_URL&#125;</span>/payment`</span>,</span><br><span class="line">      transaction</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> &#123; client_secret, totalPrice &#125; = response.data;</span><br><span class="line">    setClientSecret(client_secret);</span><br><span class="line">    setTotalPrice(totalPrice);</span><br><span class="line">  &#125;;</span><br><span class="line">  fetchClientSecret();</span><br><span class="line">&#125;, [transaction]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server payment.js</span></span><br><span class="line">router.post(<span class="string">"/payment"</span>, chekTransaction, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> transaction = req.transaction;</span><br><span class="line">    <span class="comment">// split transactions to orders and add to database</span></span><br><span class="line">    <span class="keyword">let</span> createdOrders = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> order <span class="keyword">of</span> transaction.orders) &#123;</span><br><span class="line">      <span class="keyword">let</span> product = <span class="keyword">await</span> Product.findById(order.product.productId);</span><br><span class="line">      <span class="keyword">let</span> createdOrder = <span class="keyword">await</span> Order.create(&#123;</span><br><span class="line">        buyer: req.user,</span><br><span class="line">        owner: product.owner,</span><br><span class="line">        address: transaction.address,</span><br><span class="line">        product: order.product,</span><br><span class="line">        amount: order.amount,</span><br><span class="line">        status: <span class="string">"noPaid"</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      createdOrders.push(createdOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add transactions to database</span></span><br><span class="line">    <span class="keyword">let</span> createdTransaction = <span class="keyword">await</span> Transaction.create(&#123;<span class="attr">buyer</span>: req.user, <span class="attr">orders</span>: createdOrders,&#125;);</span><br><span class="line">    <span class="keyword">const</span> intent = <span class="keyword">await</span> createPayment(transaction.totalPrice, <span class="string">"usd"</span>, createdTransaction.id);</span><br><span class="line">    res.status(<span class="number">200</span>).json(&#123;</span><br><span class="line">      client_secret: intent.client_secret,</span><br><span class="line">      totalPrice: transaction.totalPrice,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) res.status(<span class="number">500</span>).send(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于每笔transaction可能由多个买家发布的商品组成，所以这里将每笔transaction再基于单个商品分为每个order。transaction和order的数据结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> transactionSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  buyer: &#123; <span class="attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">"User"</span> &#125;,</span><br><span class="line">  orders: [&#123; <span class="attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">"Order"</span> &#125;],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> orderSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  buyer: &#123; <span class="attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">"User"</span> &#125;,</span><br><span class="line">  owner: &#123; <span class="attr">type</span>: mongoose.Schema.Types.ObjectId, <span class="attr">ref</span>: <span class="string">"User"</span> &#125;,</span><br><span class="line">  address: &#123;</span><br><span class="line">    firstName: <span class="built_in">String</span>,</span><br><span class="line">    lastName: <span class="built_in">String</span>,</span><br><span class="line">    address1: <span class="built_in">String</span>,</span><br><span class="line">    address2: <span class="built_in">String</span>,</span><br><span class="line">    city: <span class="built_in">String</span>,</span><br><span class="line">    state: <span class="built_in">String</span>,</span><br><span class="line">    country: <span class="built_in">String</span>,</span><br><span class="line">    zip: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  product: &#123;</span><br><span class="line">    productId: <span class="built_in">String</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    price: <span class="built_in">String</span>,</span><br><span class="line">    pic: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  amount: <span class="built_in">Number</span>,</span><br><span class="line">  status: <span class="built_in">String</span>,</span><br><span class="line">  date: &#123; <span class="attr">type</span>: <span class="built_in">Date</span>, <span class="attr">default</span>: <span class="built_in">Date</span>.now &#125;,</span><br><span class="line">  trackCode: <span class="built_in">String</span>,</span><br><span class="line">  shipmentProvider: <span class="built_in">String</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用stripe自带的CardElement组件创建信用卡表单，然后使用之前获取的client secret提交支付请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> payload = <span class="keyword">await</span> stripe.confirmCardPayment(clientSecret, &#123;</span><br><span class="line">  payment_method: &#123;</span><br><span class="line">    card: elements.getElement(CardElement),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>stripe收到支付钱款后，会向一个我们预先定义的webhook发送支付状态等信息，然后我们可以以此设置transaction的status (e.g. nopaid / waiting / paid等)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">router.post(<span class="string">"/webhook"</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> event = req.body;</span><br><span class="line">    <span class="comment">// Handle the event</span></span><br><span class="line">    <span class="keyword">if</span> (event.type === <span class="string">"payment_intent.succeeded"</span>) &#123; <span class="comment">//仅处理支付成功的情况</span></span><br><span class="line">      <span class="keyword">const</span> paymentIntent = event.data.object;</span><br><span class="line">      <span class="keyword">let</span> transactionId = paymentIntent.metadata.transactionId;</span><br><span class="line">      <span class="keyword">let</span> transaction = <span class="keyword">await</span> Transaction.findById(transactionId)</span><br><span class="line">        .populate(<span class="string">"orders"</span>)</span><br><span class="line">        .exec();</span><br><span class="line">      <span class="built_in">console</span>.log(transaction);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> order <span class="keyword">of</span> transaction.orders) &#123;</span><br><span class="line">        order.status = <span class="string">"paid"</span>;</span><br><span class="line">        <span class="keyword">await</span> order.save();</span><br><span class="line">        <span class="keyword">let</span> product = <span class="keyword">await</span> Product.findById(order.product.productId);</span><br><span class="line">        <span class="keyword">if</span> (product) &#123;</span><br><span class="line">          product.quantity -= order.amount;</span><br><span class="line">          <span class="keyword">await</span> product.save();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.json(&#123; <span class="attr">received</span>: <span class="literal">true</span> &#125;); <span class="comment">// Return a 200 response to acknowledge receipt of the event</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>(附注：这个模块包含很多stripe的模板代码，具体可参阅源码和stripe api文档：<a href="https://stripe.com/docs/api" target="_blank" rel="noopener">link</a>)</p><h4 id="订单管理模块"><a href="#订单管理模块" class="headerlink" title="订单管理模块"></a>订单管理模块</h4><p>该模块分为iSell卖家模块和iBuy买家模块，分别维护一个订单order列表。另外，卖家可以在order status为paid时设置已发货信息（如运单号和快递商），买家可于收到货后确认收货，该order的状态变为completed</p><p>后端route代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">"/sell"</span>, requireLogin, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> orders = <span class="keyword">await</span> Order.find(&#123;</span><br><span class="line">      owner: req.user.id,</span><br><span class="line">      status: &#123; <span class="attr">$ne</span>: <span class="string">"noPaid"</span> &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.status(<span class="number">200</span>).send(orders);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">"/buy"</span>, requireLogin, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> orders = <span class="keyword">await</span> Order.find(&#123;</span><br><span class="line">      buyer: req.user.id,</span><br><span class="line">      status: &#123; <span class="attr">$ne</span>: <span class="string">"noPaid"</span> &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    res.status(<span class="number">200</span>).send(orders);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">"/comfirmShipment"</span>, requireLogin, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; orderId, trackCode, shipmentProvider &#125; = req.body;</span><br><span class="line">    <span class="keyword">let</span> order = <span class="keyword">await</span> Order.findById(orderId).populate(<span class="string">"owner"</span>).exec();</span><br><span class="line">    <span class="keyword">if</span> (!order || order.owner.id !== req.user.id) &#123;</span><br><span class="line">      res.status(<span class="number">400</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"Unauthorized access!"</span> &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (trackCode) order.trackCode = trackCode;</span><br><span class="line">    <span class="keyword">if</span> (shipmentProvider) order.shipmentProvider = shipmentProvider;</span><br><span class="line">    order.status = <span class="string">"shipped"</span>;</span><br><span class="line">    <span class="keyword">await</span> order.save();</span><br><span class="line">    res.status(<span class="number">200</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"success!"</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.post(<span class="string">"/comfirmReceived"</span>, requireLogin, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; orderId &#125; = req.body;</span><br><span class="line">    <span class="keyword">let</span> order = <span class="keyword">await</span> Order.findById(orderId).populate(<span class="string">"buyer"</span>).exec();</span><br><span class="line">    <span class="keyword">if</span> (!order || order.buyer.id !== req.user.id) &#123;</span><br><span class="line">      res.status(<span class="number">400</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"Unauthorized access!"</span> &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    order.status = <span class="string">"completed"</span>;</span><br><span class="line">    <span class="keyword">await</span> order.save();</span><br><span class="line">    res.status(<span class="number">200</span>).send(&#123; <span class="attr">msg</span>: <span class="string">"success!"</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    res.status(<span class="number">500</span>).send(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="网站部署和跨域问题"><a href="#网站部署和跨域问题" class="headerlink" title="网站部署和跨域问题"></a>网站部署和跨域问题</h3><p>最终网站的成品命名为iShop。该项目前后端是分离的，前端使用React并部署在Vercel上（shop.wei.ai），后端用Express搭建并部署在Google App Engine上（shop-api.wei.ai）。其实一开始后端本来是部署在Heroku上的，后面在开发的过程中遇到一些跨域问题，即safari浏览器仅接受来自相同域名的跨域api调用（参考之前的<a href="https://blog.wei.ai/2020/08/25/一次关于express%20sameSite%20cookies的debug/" target="_blank" rel="noopener">blog</a>），heroku的免费版又不支持自建域名和https。刚好之前GCP新用户注册还剩小半年免费期，就先部署在GCP了。当然缺点也是蛮明显的，就是国内用户访问很慢。以后可能会考虑将应用迁移到位于境内的服务器上。</p><p>（另外打个小广告，我最近注册了wei.ai域名，欢迎大家有空访问并提出意见）</p><h3 id="最终成品"><a href="#最终成品" class="headerlink" title="最终成品"></a>最终成品</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/22/NSfP2y5t3vodGAn.png" alt="首页和购物车" title>                </div>                <div class="image-caption">首页和购物车</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/22/zW3SewQqYArtLby.png" alt="商品展示页" title>                </div>                <div class="image-caption">商品展示页</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/22/9jPG46JNolquCdz.png" alt="结算页面" title>                </div>                <div class="image-caption">结算页面</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/09/22/G7X65t3NTbZDQfy.png" alt="卖家管理页面" title>                </div>                <div class="image-caption">卖家管理页面</div>            </figure><h3 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h3><p>（以下内容有时间或需求的话会继续更新）</p><ol><li>图片上传模块（可能于近期写一个图床应用，但需要一个大一点空间的服务器，穷o(╥﹏╥)o）</li><li>评论、点赞和收藏模块</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;最近接触到MERN技术栈，想做一个全栈的项目练练手。正好之前在上网课的时候有提到如何使用第三方服务如stripe搭建一个支付系统，把这个支付
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.david916.com/categories/Note/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://blog.david916.com/tags/React/"/>
    
      <category term="Express" scheme="http://blog.david916.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>一次关于express sameSite cookies的debug</title>
    <link href="http://blog.david916.com/2020/09/21/%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8Eexpress%20sameSite%20cookies%E7%9A%84debug/"/>
    <id>http://blog.david916.com/2020/09/21/一次关于express sameSite cookies的debug/</id>
    <published>2020-09-21T03:57:49.000Z</published>
    <updated>2020-09-21T03:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个google / facebook oauth登录系统，前端使用react，后端使用nodejs + express，前后端分别部署在vercel和heroku上，不可避免的遇到很多跨域问题。</p><p>今天在将本地代码deploy到生产环境的时候，发现google oauth虽然能成功调用callback url重定向到后端，后端也能设置cookie，但后续的api操作却没有带上之前返回的cookie，导致无法通过api获取用户数据等信息。然而之前在开发环境测试的时候，api操作确实带上了cookie并成功获取数据，并且：</p><ol><li>在开发和生产环境中后端都设置了<code>cors({ credentials: true, origin: process.env.CLIENT_BASE_URL })</code></li><li>前端axios获取api数据时也设置了<code>axios.defaults.withCredentials = true;</code></li><li>生产环境中前端地址<code>localhost:3000</code>和后端地址<code>localhost:5000</code>同属于跨域，但测试正常</li></ol><p>查看console，发现以下错误信息：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A cookie associated with a cross-site resource at http://MYAPI.URL was set</span><br><span class="line">without the `SameSite` attribute. A future release of Chrome will only deliver </span><br><span class="line">cookies with cross-site requests if they are set with `SameSite=None` and </span><br><span class="line">`Secure`. You can review cookies in developer tools under </span><br><span class="line"><span class="meta">Application&gt;</span><span class="bash">Storage&gt;Cookies and see more details at </span></span><br><span class="line">https://www.chromestatus.com/feature/5088147346030592 and </span><br><span class="line">https://www.chromestatus.com/feature/5633521622188032.</span><br></pre></td></tr></table></figure><p>搜索后发现，该错误是由于chrome等浏览器最近的安全升级导致，该升级要求所有跨域cookie操作都必须要对cookie设置为<code>samesite=&quot;none&quot;</code>和<code>secure=&quot;true&quot;</code>，而且该升级只针对于host不同的情况，其余跨域诸如端口号等不受到影响，这也解释了为什么开发环境测试通过而生产环境出现错误。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie/SameSite" target="_blank" rel="noopener">MDN参考</a></p><p>后续设置express-session</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sessionConfig = &#123;</span><br><span class="line">  secret: process.env.SESSION_SECRET,</span><br><span class="line">  resave: <span class="literal">false</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">false</span>,</span><br><span class="line">  cookie: &#123;</span><br><span class="line">    sameSite: <span class="string">"none"</span>,</span><br><span class="line">    secure: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">app.use(session(sessionConfig));</span><br></pre></td></tr></table></figure><p>修改后新问题又来了，这次后端直接不设置cookie了，即response中不包含set-cookie。查阅<a href="https://github.com/expressjs/session#cookiesecure" target="_blank" rel="noopener">文档</a>后发现当设置cookie为secure时，需要通过https设置cookie，使用http将默认不设置cookie。因此express加多一行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">'trust proxy'</span>, <span class="number">1</span>) <span class="comment">// trust first proxy</span></span><br></pre></td></tr></table></figure><p>这次在生产环境测试成功，但生产环境的前后端地址都是由第三方提供的https地址，不知道为何也会出现这样的问题，猜想可能需要自行配置有效证书。</p><p><strong>Update on 2020-09-21</strong></p><p>上述问题其实是由于苹果safari浏览器的最新安全策略所导致的，现时safari浏览器无论是否设置cookie为secure或使用https，都仅允许同一域名下的跨域异步操作，在Google Chrome和Firefox浏览器测试中不存在上述问题。将server (<a href="https://shop-api.wei.ai" target="_blank" rel="noopener">https://shop-api.wei.ai</a>) 和client (<a href="https://shop.wei.ai" target="_blank" rel="noopener">https://shop.wei.ai</a>)  部署到同一域名下后问题解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在写一个google / facebook oauth登录系统，前端使用react，后端使用nodejs + express，前后端分别部署在vercel和heroku上，不可避免的遇到很多跨域问题。&lt;/p&gt;
&lt;p&gt;今天在将本地代码deploy到生产环境的时候，发现go
      
    
    </summary>
    
    
      <category term="Debug" scheme="http://blog.david916.com/categories/Debug/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="Nodejs" scheme="http://blog.david916.com/tags/Nodejs/"/>
    
      <category term="Express" scheme="http://blog.david916.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Travel to the Northwest of China Vlog</title>
    <link href="http://blog.david916.com/2020/09/07/%E8%A5%BF%E5%8C%97%E6%B8%B8vlog/"/>
    <id>http://blog.david916.com/2020/09/07/西北游vlog/</id>
    <published>2020-09-07T14:56:09.000Z</published>
    <updated>2020-09-07T14:56:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>I recently traveled to Ningxia and Shaanxi provinces in China with my undergrad roommates and friends. I have been to the desert in Zhongwei city (中卫), the museum of Terracotta Army (兵马俑), and Mount Hua (华山). This vlog is automatically generated by the iPhone photos app, which is awesome.</p><p><a href="https://youtu.be/LETzL7fe5_s" target="_blank" rel="noopener">Vlog link</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/LETzL7fe5_s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I recently traveled to Ningxia and Shaanxi provinces in China with my undergrad roommates and friends. I have been to the desert in Zhong
      
    
    </summary>
    
    
      <category term="Life" scheme="http://blog.david916.com/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Passport.js实现Google OAuth登录</title>
    <link href="http://blog.david916.com/2020/08/21/%E4%BD%BF%E7%94%A8Passport.js%E5%AE%9E%E7%8E%B0Google%20OAuth%E7%99%BB%E5%BD%95/"/>
    <id>http://blog.david916.com/2020/08/21/使用Passport.js实现Google OAuth登录/</id>
    <published>2020-08-21T12:18:44.000Z</published>
    <updated>2020-08-21T12:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fssongwei/Emaily-Server/tree/d6e87442e2ed7e5769b16352ab25d8af2522c43a" target="_blank" rel="noopener">Source Code</a></p><h3 id="Google-OAuth-2-0-登录流程"><a href="#Google-OAuth-2-0-登录流程" class="headerlink" title="Google OAuth 2.0 登录流程"></a>Google OAuth 2.0 登录流程</h3><img src="https://i.loli.net/2020/08/20/fA12XlsdSWVkHQD.jpg" alt="google oauth workflow.jpg" style="zoom: 33%;"><ol><li><p>client向server发起<code>GET /auth/google</code>请求</p></li><li><p>server将client重定向至google oauth登录页<code>https://accounts.google.com/o/oauth2/auth</code>，并附带以下查询参数集：</p><ul><li><code>response_type: code</code> 登录后返回授权码</li><li><code>client_id: GOOGLE_CLIENT_ID</code> Google控制台中的client_id，用于google识别应用程序</li><li><code>redirect_url: http://www.example.com/auth/google/callback</code> 回调URL，必须和Google控制台中设置的回调URL一致</li><li><code>scope: [&#39;profile&#39;, &#39;email&#39;]</code> 用户授权使用的数据返回，显示在oauth登录确认页中 </li></ul></li><li><p>用户在登录页授权登录后，google api server会将client重定向至之前设定的回调URL，并附带authorization code授权码</p></li><li><p>server收到针对回调URL的GET请求<code>GET /auth/google/callback</code>，从中提取出code授权码，并使用该code向google api server换取access token</p><ol><li><p>请求地址：<code>https://www.googleapis.com/oauth2/v3/token</code></p></li><li><p>请求参数</p><ul><li>code: 之前获得的授权码</li><li>grant_type: authorization_code：指明使用授权码进行验证</li><li>client_id，同上</li><li>client_secret，同上</li><li>redirect_url，同上</li></ul></li><li><p>返回值：</p><ul><li>access_token：用于获取其他google api数据或控制权</li><li>expires_in：过期时间</li><li>token_type：指明token类型</li><li>id_token：一串加密信息，使用base64 decode解密后可以获得用户邮箱email和用户唯一标识符sub等信息</li><li>refresh_token：access_token过期后，可以使用refresh_token来重新获取新的access_token，而不需要用户重新授权</li></ul><p>可以将上述token信息保存到数据库，即使用户不使用app时也能获取用户信息和代替用户进行google api操作等</p></li></ol></li><li><p>server从google api收到用户数据后，可以将用户注册到数据库，然后将用户信息序列化后设置cookie并返回给client，后续client使用该cookie进行身份验证</p></li></ol><p>使用passport middleware可以帮助我们简化中间与google api交互的流程，我们只需要设置以下组件：</p><ol><li>GoogleStrategy：设置clientID，clientSecret和callbackURL</li><li>verify / register callback function：接收用户数据，并完成后续用户认证和注册等流程</li><li>session serialization / deserialization：将用户信息存储到cookie/从cookie解码用户信息</li><li>next middleware（或router的callback function）：执行后续api数据返回</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/20/mNQkqEAIJrslYZH.jpg" alt="passportJS google oauth workflow.jpg" title>                </div>                <div class="image-caption">passportJS google oauth workflow.jpg</div>            </figure><p>创建google strategy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// passport-config.js</span></span><br><span class="line"><span class="keyword">let</span> myGoogleStrategy = <span class="keyword">new</span> GoogleStrategy(&#123;</span><br><span class="line">    clientID: GOOGLE_CLIENT_ID,</span><br><span class="line">    clientSecret: GOOGLE_CLIENT_SECRET,</span><br><span class="line">    callbackURL: <span class="string">"http://www.example.com/auth/google/callback"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">accessToken, refreshToken, profile, done</span>) </span>&#123;</span><br><span class="line">    User.findOrCreate(&#123; <span class="attr">googleId</span>: profile.id &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> done(err, user);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">"passport"</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">"./passportConfig"</span>);</span><br></pre></td></tr></table></figure><p><a href="https://juejin.im/post/6844903509016444942" target="_blank" rel="noopener">Ref1</a> <a href="http://www.zchengjoey.com/posts/使用oauth2登录访问谷歌API/" target="_blank" rel="noopener">Ref2</a></p><h3 id="cookie验证流程"><a href="#cookie验证流程" class="headerlink" title="cookie验证流程"></a>cookie验证流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/21/JsmB7bFPDrS2wKQ.jpg" alt="session workflow.jpg" title>                </div>                <div class="image-caption">session workflow.jpg</div>            </figure><ol><li><p>Express-session middleware：用于解码从client发来的cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">"express-session"</span>);</span><br><span class="line">app.use(</span><br><span class="line">  session(&#123;</span><br><span class="line">    secret: process.env.SESSION_SECRET,</span><br><span class="line">    resave: <span class="literal">false</span>,</span><br><span class="line">    saveUninitialized: <span class="literal">false</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>passport.initialize() middleware：负责从cookie中提取userId</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">app.use(passport.initialize());</span><br></pre></td></tr></table></figure></li><li><p>app.use(passport.session())：使用userId，从数据库中获取user，或将user序列化为cookie</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// passport-config.js</span></span><br><span class="line">passport.serializeUser(<span class="function">(<span class="params">user, done</span>) =&gt;</span> &#123;</span><br><span class="line">  done(<span class="literal">null</span>, user.id);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">passport.deserializeUser(<span class="keyword">async</span> (id, done) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">await</span> User.findById(id);</span><br><span class="line">    done(<span class="literal">null</span>, user);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    done(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">app.use(passport.session())</span><br></pre></td></tr></table></figure></li><li><p>Self-defined middleware：使用<code>req.isAuthenticated()</code>函数验证登录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">middlewares.checkAuthenticated = <span class="keyword">async</span> (req, res, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.isAuthenticated()) &#123;</span><br><span class="line">          next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          req.flash(<span class="string">"error"</span>, <span class="string">"You need to login first"</span>);</span><br><span class="line">          res.redirect(<span class="string">"/auth/login"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/fssongwei/Emaily-Server/tree/d6e87442e2ed7e5769b16352ab25d8af2522c43a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Source 
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.david916.com/categories/Note/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="Nodejs" scheme="http://blog.david916.com/tags/Nodejs/"/>
    
      <category term="Express" scheme="http://blog.david916.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>React APIs Widget</title>
    <link href="http://blog.david916.com/2020/08/05/React%20APIs%20Widget/"/>
    <id>http://blog.david916.com/2020/08/05/React APIs Widget/</id>
    <published>2020-08-05T08:38:54.000Z</published>
    <updated>2020-08-05T08:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>This <strong>React</strong> app contains four different widgets:</p><ol><li><p>A translate widget using <a href="https://cloud.google.com/translate" target="_blank" rel="noopener">Google Translate API</a></p><p><img src="https://i.loli.net/2020/08/05/LyblAxXJoU2taBh.png" alt="Translate Widget.png"></p></li><li><p>A wiki search widget using <a href="https://www.mediawiki.org/wiki/API:Main_page" target="_blank" rel="noopener">Wikepedia API</a></p><p><img src="https://i.loli.net/2020/08/05/iLCZd4Tpsx61v7Y.png" alt="Wiki Widget.png"></p></li><li><p>A photo search widget using <a href="https://unsplash.com/developers" target="_blank" rel="noopener">Unsplash API</a></p><p><img src="https://i.loli.net/2020/08/05/37iXTd9qkC6JEw4.png" alt="Photo Widget.png"></p></li><li><p>A youtube widget using <a href="https://developers.google.com/youtube/v3" target="_blank" rel="noopener">Youtube Data API v3</a></p><p><img src="https://i.loli.net/2020/08/05/MJBP5OfcsyxFVQb.png" alt="Youtube Widget.png"></p></li></ol><p>Other tools &amp; libraries include:</p><ol><li><a href="https://fezvrasta.github.io/bootstrap-material-design/" target="_blank" rel="noopener">Bootstrap Material Design</a> - UI Library</li><li><a href="https://github.com/axios/axios" target="_blank" rel="noopener">Axios</a> - HTTP Library</li><li><a href="https://www.npmjs.com/package/faker" target="_blank" rel="noopener">Faker.js</a> - Random String Generator</li></ol><p><a href="https://react-api-s-widgets.vercel.app" target="_blank" rel="noopener">Live Demo</a><br><a href="https://github.com/fssongwei/React-APIs-Widgets" target="_blank" rel="noopener">Source Code</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;This &lt;strong&gt;React&lt;/strong&gt; ap
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://blog.david916.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Youtube Shuffle</title>
    <link href="http://blog.david916.com/2020/08/05/Youtube%20Shuffle/"/>
    <id>http://blog.david916.com/2020/08/05/Youtube Shuffle/</id>
    <published>2020-08-05T05:54:30.000Z</published>
    <updated>2020-08-05T05:54:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><a href="https://youtube-shuffle.vercel.app" target="_blank" rel="noopener">Live Demo</a></p><p><a href="https://github.com/fssongwei/Youtube-Shuffle" target="_blank" rel="noopener">Source Code</a></p><p>Youtube shuffle is a <strong>React</strong> app using Youtube Data API. It has a personalized user interface which allows users to search a Youtube video and play it. It also includes a shuffle function, which the program will randomly generated a keyword and presents the related videos from Youtube.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/31/mqlB7crGP5wUXiC.png" alt="Youtube Shuffle.png" title>                </div>                <div class="image-caption">Youtube Shuffle.png</div>            </figure><p>Technologies and libraries using in this project are listing below: </p><p><strong>Front-end Library</strong>: React</p><p><strong>UI Library</strong>: MDUI</p><p><strong>APIs</strong>: Youtube Data API v3</p><p><strong>Other Libraries</strong>: Faker.js (to generate random keywords)</p><p>This project was bootstrapped with <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">Create React App</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://youtube-shuff
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://blog.david916.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>在React中实现Debounced Textfield</title>
    <link href="http://blog.david916.com/2020/08/03/React:%20Debounced%20Textfield/"/>
    <id>http://blog.david916.com/2020/08/03/React: Debounced Textfield/</id>
    <published>2020-08-03T12:57:05.000Z</published>
    <updated>2020-08-03T12:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>假设我们需要实现一种类似google的搜索提示功能，即用户输入搜索词的过程中，输入框的下方会同步显示搜索的候选项：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://media1.tenor.com/images/cec9b2f2b8732aa68285a1930e9064a0/tenor.gif?itemid=14832746" alt title>                </div>                <div class="image-caption"></div>            </figure><p>基本方案：通过input的onChange listener监听input field文本的变化，并通过调用api返回提示结果</p><p>存在问题：每次用户输入或删除一个字符，即调用一次API，造成资源浪费。我们希望可以设置一个timer，当用户停止输入一段时间后，才调用api并返回结果</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/byS1WNK9I27HEXU.png" alt="workflow.png" title>                </div>                <div class="image-caption">workflow.png</div>            </figure><ol><li><p>设置两个state，分别为text和debouncedText</p></li><li><p>每当event listener监听到变化，调用setText函数重设state中的text</p></li><li><p>使用useEffect监听text的变化，并执行以下步骤</p><ol><li>设定一个timer，延迟一段时间（500ms）后使用text和setDebouncedText函数来设置debouncedText的值</li><li>返回一个useEffect cleanup funtion来删除这个timer。这个cleanup function将会在下一次text发生变化时调用并清理掉上一次设置的timer。</li></ol><p>假设当前text和debouncedText字符串为”abc”，用户分别再输入’d’和’e’，此时存在两种情况：</p><ol><li>当用户两次键入字符时间小于500ms时，前一次timer的设定时间还没到而不会产生更新，而后面cleanup funtion会清理掉前面设置的timer，因此debouncedText的值不变，仍为”abc”</li><li>当用户两次键入字符时间大于500ms时，前一次timer已到时，会调用setDebounced来更新debouncedText的值，此时为”abcd”</li></ol></li><li><p>使用另一个useEffect监听debouncedText的变化，并完成api等操作</p></li></ol><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DebouncedTextField.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DebouncedTextField = <span class="function">(<span class="params">&#123; initText, onTextChange &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState(initText);</span><br><span class="line">  <span class="keyword">const</span> [debouncedText, setDebouncedText] = useState(initText);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timerID = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setDebouncedText(text);</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      clearTimeout(timerID);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [text]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// debouncedText发生变化后调用onTextChange执行后续api操作等</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> onTextChange(debouncedText), [debouncedText, onTextChange]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> onChange=&#123;(e) =&gt; setText(e.target.value)&#125; value=&#123;text&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> DebouncedTextField;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;假设我们需要实现一种类似google的搜索提示功能，即用户输
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.david916.com/categories/Note/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://blog.david916.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React：一次关于onclick的debug</title>
    <link href="http://blog.david916.com/2020/08/02/React%EF%BC%9A%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8Eonclick%E7%9A%84debug/"/>
    <id>http://blog.david916.com/2020/08/02/React：一次关于onclick的debug/</id>
    <published>2020-08-02T14:13:26.000Z</published>
    <updated>2020-08-02T14:13:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>React中可以向onClick（onSubmit，onChange等同理）中传入一个函数，这个函数会在组件被click时执行：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line"><span class="comment">// some code to execute after button clicked</span></span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure><p>这个函数可以接受一个参数，即event：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(event) =&gt; &#123;</span><br><span class="line"><span class="comment">// some code to execute after button clicked</span></span><br><span class="line"><span class="comment">// you can use event object to do something, such as event.target.value</span></span><br><span class="line">&#125;&#125;&gt;</span><br></pre></td></tr></table></figure><p>同时也可以在函数体中使用该component内，该函数外定义的其他变量，且这些变量不需要通过该函数的参数传入，e.g.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设外部定义了一个名为item的state变量，还有一个从上层component传递下来的callback函数 cbfunc() 需要使用该item变量</span></span><br><span class="line">&lt;button onClick=&#123;() =&gt; cbfunc(item)&#125;&gt;</span><br></pre></td></tr></table></figure><p>下面这种写法是错误的，即不需要将item作为参数传入，且第一个传入的参数会被当成event对象</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;(item) =&gt; cbfunc(item)&#125;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React中可以向onClick（onSubmit，onChange等同理）中传入一个函数，这个函数会在组件被click时执行：&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="Debug" scheme="http://blog.david916.com/categories/Debug/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="React" scheme="http://blog.david916.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Yelp Camp - A full-stack Node.js Web Application Project</title>
    <link href="http://blog.david916.com/2020/07/19/Yelp%20Camp%20-%20A%20full-stack%20Node.js%20Web%20Application%20Project/"/>
    <id>http://blog.david916.com/2020/07/19/Yelp Camp - A full-stack Node.js Web Application Project/</id>
    <published>2020-07-19T11:27:00.000Z</published>
    <updated>2020-07-19T11:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Yelp Camp is a Yelp-like node.js web app. It’s the final course project of the Web Develop Bootcamp course in Udemy. Users and campground owners can upload their campground information to the website, and other users can leave a comment to the campground.</p><p><a href="http://app.david916.com:2000" target="_blank" rel="noopener">Live Demo</a><br><a href="https://github.com/fssongwei/YelpCamp" target="_blank" rel="noopener">Source Code</a></p><p>The app is built on Node.js with Express. Other technologies and library using in this project are listing below: </p><p><strong>UI Library</strong>: Bootstrap</p><p><strong>Database</strong>: MongoDB, Mongoose</p><p><strong>Authentication</strong>: passport.js, bcrypt, express-session, express-flash</p><h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h2><h5 id="2020-7-19-Version-1-0"><a href="#2020-7-19-Version-1-0" class="headerlink" title="2020.7.19 Version 1.0"></a>2020.7.19 Version 1.0</h5><ol><li>Front-end development with HTML/CSS/JS and Bootstrap 4</li><li>Back-end development with Node.js and Express</li><li>Built user login and register system with Passport.js</li><li>Developed Posts module and Comments module</li></ol><h5 id="To-do-List"><a href="#To-do-List" class="headerlink" title="To-do List"></a>To-do List</h5><p>Other features comming. If you have any idea, send email to <a href="mailto:ws446@cornell.edu" target="_blank" rel="noopener">ws446@cornell.edu</a></p><ol><li>Fuzzy Search </li><li>Campground location with Google Maps</li><li>User profile </li><li>Password reset </li><li>Image upload with multer and cloudinary </li><li>Payment with Stripe API</li><li>Ratings</li><li>Pagination in campgrounds index</li></ol><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/19/jJb98kKhSAsix5M.png" alt="mainpage.png" title>                </div>                <div class="image-caption">mainpage.png</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/19/rjnZtfvFVU9caLR.png" alt="camppage.png" title>                </div>                <div class="image-caption">camppage.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Yelp Camp is a Yelp-like node.
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Nodejs" scheme="http://blog.david916.com/tags/Nodejs/"/>
    
      <category term="Express" scheme="http://blog.david916.com/tags/Express/"/>
    
      <category term="Bootstrap" scheme="http://blog.david916.com/tags/Bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>Dwitter - A Twitter-like Social Media App</title>
    <link href="http://blog.david916.com/2020/07/17/Dwitter%20-%20A%20Twitter-like%20Social%20Media%20App/"/>
    <id>http://blog.david916.com/2020/07/17/Dwitter - A Twitter-like Social Media App/</id>
    <published>2020-07-16T16:00:00.000Z</published>
    <updated>2020-07-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Dwitter is a Twitter-like social media web app written in Javascript. The name “Dwitter” stands for “David’s Twitter”. Users can post their thoughs, follow other user, comment and like other user’s posts.</p><p><a href="http://app.david916.com:3000" target="_blank" rel="noopener">Live Demo</a><br><a href="https://github.com/fssongwei/Dwitter" target="_blank" rel="noopener">Source Code</a></p><p>The app is built on Node.js with Express. Other technologies and library using in this project are listing below: </p><p><strong>UI Library</strong>: MDUI</p><p><strong>Database</strong>: MongoDB, Mongoose</p><p><strong>Authentication</strong>: passport.js, bcrypt, express-session, express-flash</p><h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h2><h5 id="2020-7-16-Version-1-0"><a href="#2020-7-16-Version-1-0" class="headerlink" title="2020.7.16 Version 1.0"></a>2020.7.16 Version 1.0</h5><p>(The app is officially for public testing)</p><ol><li>Improve UI with MDUI (Material Design UI)</li><li>Add following &amp; unfollowing features</li><li>Add like &amp; unlike features</li><li>Implement express-flash to show flash message</li></ol><h5 id="2020-7-15"><a href="#2020-7-15" class="headerlink" title="2020.7.15"></a>2020.7.15</h5><ol><li>Authentication with passport.js</li><li>Refactor the code</li></ol><h5 id="2020-7-14"><a href="#2020-7-14" class="headerlink" title="2020.7.14"></a>2020.7.14</h5><ol><li>Initialize the project by setting up the routers and database models</li><li>Add Basic UI with HTML &amp; CSS</li><li>Add posts &amp; comments create and delete features</li></ol><h5 id="To-do-List"><a href="#To-do-List" class="headerlink" title="To-do List"></a>To-do List</h5><p>Other features comming. If you have any idea, send email to <a href="mailto:ws446@cornell.edu" target="_blank" rel="noopener">ws446@cornell.edu</a></p><ol><li>Implement photo library for user to upload their photos</li><li>Display the number of favorite for each post</li><li>Implement google / facebook login</li><li>User can change their own avatars</li><li>Routers refactor</li></ol><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><img src="https://i.loli.net/2020/07/19/Fzc5LiMEWo4Z32O.png" alt="MainPage.png" style="height: 500px;"><img src="https://i.loli.net/2020/07/19/r6ZmgcyPYRt4i89.png" alt="profilePage.png" style="height: 500px;"><br><img src="https://i.loli.net/2020/07/19/3LxnoeavjfT89qH.png" alt="followingPage.png" style="height: 500px;"><img src="https://i.loli.net/2020/07/19/fuabQnrldK9Pze5.png" alt="loginPage.png" style="height: 500px;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;p&gt;Dwitter is a Twitter-like soci
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="Nodejs" scheme="http://blog.david916.com/tags/Nodejs/"/>
    
      <category term="Express" scheme="http://blog.david916.com/tags/Express/"/>
    
  </entry>
  
  <entry>
    <title>Web Develop Bootcamp Front-end Projects</title>
    <link href="http://blog.david916.com/2020/06/22/Web%20Develop%20Bootcamp%20Front-end%20Projects/"/>
    <id>http://blog.david916.com/2020/06/22/Web Develop Bootcamp Front-end Projects/</id>
    <published>2020-06-21T16:00:00.000Z</published>
    <updated>2020-06-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Below are some of the web developer bootcamp course projects. All of them are purely front-end app with only HTML / CSS / Javascript</p><p><a href="https://github.com/fssongwei/WDB-Projects" target="_blank" rel="noopener">Source Code</a></p><h4 id="Color-Guessing-Game"><a href="#Color-Guessing-Game" class="headerlink" title="Color Guessing Game"></a>Color Guessing Game</h4><p>The game will give an RGB value and some squares fill with different color. The player choose the correct color square that matches the given RGB value wins. There are three difficulty level to choose. The game also includes a statistics function to calculate the correct rate of the player.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/19/V7fmPHsA4kO8MZo.png" alt="colorGame.png" title>                </div>                <div class="image-caption">colorGame.png</div>            </figure><p><a href="https://www.david916.com/projects/patatap/index.html" target="_blank" rel="noopener">Demo</a></p><h4 id="To-Do-List"><a href="#To-Do-List" class="headerlink" title="To-Do List"></a>To-Do List</h4><p>This tool allows user to keep track of their daily tasks. User can update a task, mark it as completed, or delete a task.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/07/19/nQARgB2shIMb1q7.png" alt="TodoList.png" title>                </div>                <div class="image-caption">TodoList.png</div>            </figure><p><a href="https://www.david916.com/projects/todolist/" target="_blank" rel="noopener">Demo</a></p><h4 id="Patatap"><a href="#Patatap" class="headerlink" title="Patatap"></a>Patatap</h4><p>Patatap is a fun music game. User can type any key on their keyborad and the game will play different sounds and show animated circle on the screen with different colors.</p><p>Several javacript library are included in this project, includes JQuery, Paper.js and Howler.js</p><p><a href="https://www.david916.com/projects/colorgame/" target="_blank" rel="noopener">Demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Below are some of the web developer bootcamp course projects. All of them are purely front-end app with only HTML / CSS / Javascript&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Javascript" scheme="http://blog.david916.com/tags/Javascript/"/>
    
      <category term="HTML" scheme="http://blog.david916.com/tags/HTML/"/>
    
      <category term="CSS" scheme="http://blog.david916.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Princeton Algorithm 1 Note</title>
    <link href="http://blog.david916.com/2020/04/06/Princeton%20Algorithm%201%20Note/"/>
    <id>http://blog.david916.com/2020/04/06/Princeton Algorithm 1 Note/</id>
    <published>2020-04-05T16:00:00.000Z</published>
    <updated>2020-04-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Week-1-Dynamic-Connectivity-动态连通性"><a href="#Week-1-Dynamic-Connectivity-动态连通性" class="headerlink" title="Week 1. Dynamic Connectivity 动态连通性"></a>Week 1. Dynamic Connectivity 动态连通性</h3><ol><li>将所有对象映射为0-N<br>证明：一棵树上的节点x的深度最多为lgN<br>两棵树大小相等时，union操作会使合并得来的新树大小翻倍，但是高度只+1<br>（也可以理解为每次树的高度+1，树的大小则翻倍）<br>因此假设树最开始只有一个节点，经过lgN次翻倍后形成完整的节点数为N的树，此时树的高度为lgN!</li></ol><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p><a href="https://vancexu.github.io/2015/07/21/intro-to-union-find-data-structure-exercise.html" target="_blank" rel="noopener">Exercises Solution</a></p><h4 id="3-sum算法"><a href="#3-sum算法" class="headerlink" title="3-sum算法"></a>3-sum算法</h4><p>upper bound为O(N^2logN) （二分查找logN * N^2）<br>lower bound至少为Ω(N) （有可能更高，但目前没有证明）因为算法至少需要遍历一遍所有数字，否则可能会漏过</p><p>证明一个算法是最优的（或者优化一个算法），要不降低算法的upper bound，要不证明算法有更高的lower bound<br>（即缩短上下bound之间的gap）<br>当upper bound = lower bound即证明算法没有其他更优解</p><p>Big O记号常常用来表示一个算法的性能，但这是错误的，他只表示一个算法的上界。比如：函数<code>$2n^2$</code>，<code>$25000n^3$</code>都可以用<code>$O(n^3)$</code>表示。改用tilde标记 ~<code>$2n^2$</code>来表示特定算法的性能</p><h4 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h4><table><thead><tr><th>Types</th><th>Bytes</th><th>Types</th><th>Bytes</th></tr></thead><tbody><tr><td>char</td><td>2</td><td>char[]</td><td>2N + 24 (Overhead)</td></tr><tr><td>int</td><td>4</td><td>int[]</td><td>4N + 24 (Overhead)</td></tr><tr><td>double</td><td>8</td><td>double[]</td><td>8N + 24 (Overhead)</td></tr><tr><td>boolean</td><td>1</td><td>char[][]</td><td>~ 2NM</td></tr><tr><td>float</td><td>4</td><td>int[][]</td><td>~ 4NM</td></tr><tr><td>long</td><td>8</td><td>double[][]</td><td>~ 8NM</td></tr></tbody></table><p>Java对象 Obejct：<br>Object Overhead: 16 Bytes<br>Padding: 填充字节，使得整个object的大小为8的倍数<br>Object的大小= 16 (Overhead) + 变量大小 + Padding<br>e.g. 下面类产生的object有32个字节：16(overhead) + 4*3(variables) + 4(padding)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Date &#123;</span><br><span class="line">    private int day;</span><br><span class="line">    private int month;</span><br><span class="line">    private int year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针大小 (reference)：8 Bytes (64位) / 4 Bytes (32位)</p><h3 id="Week-2-Stack-amp-Queue-堆栈和队列"><a href="#Week-2-Stack-amp-Queue-堆栈和队列" class="headerlink" title="Week 2. Stack &amp; Queue 堆栈和队列"></a>Week 2. Stack &amp; Queue 堆栈和队列</h3><h4 id="resizing-array"><a href="#resizing-array" class="headerlink" title="resizing array"></a>resizing array</h4><p>如果每添加一个数字，将array扩大1位，则插入N个数据的数组的访问次数为1 + 2 + … + N ~ 0.5 N^2</p><h5 id="Loitering问题"><a href="#Loitering问题" class="headerlink" title="Loitering问题"></a>Loitering问题</h5><p>将数组某项设为null，如<code>A[0] == null</code>，可以释放相应的空间   （Stack的array实现中，push操作后需要把相应位置设为null）</p><h5 id="Optimal-Soultion"><a href="#Optimal-Soultion" class="headerlink" title="Optimal Soultion:"></a>Optimal Soultion:</h5><p>初始设array大小为1，每次array将满的时候，将array扩大一遍<br>此时array的访问次数大概为 N + (1 + 2 + 4 + 8 + … + N) = ~3N<br>当数组只有1/4满的时候，才将数组大小减半 （防止thrashing抖动问题）</p><h5 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h5><p>push 和 pop 操作最好情况下性能为O(1)<br>由于resizing操作，最坏情况（worst case）下性能为O(N)<br>（对比linkedlist实现，最好最坏情况均为O(1)）</p><h5 id="Memory-Usage"><a href="#Memory-Usage" class="headerlink" title="Memory Usage"></a>Memory Usage</h5><p>对stack的Linkedlist实现，需要空间为 40N Bytes （一个节点40 Bytes）<br>对array实现，当数组全满时，空间为8N，当数组为1/4满时，空间为32N</p><h5 id="LinkedList-vs-Resizing-Array"><a href="#LinkedList-vs-Resizing-Array" class="headerlink" title="LinkedList vs Resizing Array"></a>LinkedList vs Resizing Array</h5><p>链表实现，每个操作都是常数操作，但需要额外空间和用于分配空间的时间，因此平均性能较慢，但比较稳定<br>数组实现，所需空间和运行总时间较少，但可能某个操作遇到需要resize的情况导致效率变慢，性能较不稳定</p><h4 id="Java-Generics-Java泛型"><a href="#Java-Generics-Java泛型" class="headerlink" title="Java Generics (Java泛型)"></a>Java Generics (Java泛型)</h4><p>之前设计的都是String类型的stack和queue，如果我们想要实现任何数据类型都可以接收的stack和queue，就需要用到java泛型</p><p>Example：创建一个泛型的stack类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class stack&lt;Item&gt; &#123;</span><br><span class="line">//这里预先定义一个Item的数据类型，以后使用的时候可以替换为其他数据类型</span><br><span class="line">    private class Node &#123;</span><br><span class="line">        Item item; //这里引用Item，表示任意传入的数据类型</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Item pop() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... //其他函数或变量</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要使用这个类的对象，可以使用<br><code>Stack&lt;Integer&gt; integerStack = new Stack&lt;Integer&gt;();</code>命令创建一个接受Integer的stack对象</p><p><strong>注意：Java不能创建泛型数组</strong><br>如果需要将上面的stack改为数组实现，则可以创建一个Object数组，再将其cast强制转换为Item[]类型的数组：<br><code>Item[] S = (Item[]) new Object[capacity];</code></p><p>另外，Java泛型只接受包装数据类型（Wrapper Type），如Integer，String，Double，基本类型（Primitive Type，如int, double）需要转换为包装类型才能用于泛型<br>在一些高版本的java支持Autoboxing(自动打包)，可以直接传入基本数据类型</p><h4 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h4><p>Java提供了一种Iterator迭代器机制，可以帮助我们遍历一个class中的所有元素（比如说遍历stack和queue中的元素）</p><p>步骤（以stack为例）：</p><ol><li>创建一个stack类，并实现（implement）iterable接口</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Stack &lt;Item&gt; implements Iterable&lt;Item&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>Iterable&lt;Item&gt;</code>里面的Item是你要迭代(遍历)的元素的数据类型</p><ol start="2"><li>要实现这个Iterable接口，代表这个stack类中需要有一个iterator函数，这个函数返回一个类型为<code>Iterator&lt;Item&gt;</code>的实例<br>(即返回一个迭代器实例，这样Java每次调用迭代机制的时候会调用这个iterator()函数生成一个新的迭代器)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;Item&gt; iterator() &#123;</span><br><span class="line">    return new ListIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>用一个内部类来实现(implement)我们的迭代器</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private class ListIterator implements Iterator&lt;Item&gt; &#123;</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        ... //确定是否能继续迭代</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Item next() &#123;</span><br><span class="line">        ... //返回下一个元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里<code>Iterator&lt;Item&gt;</code>是已经预置在Java里面的内部类（其实是一种较为特殊的类称为Interface 接口），类似于一个迭代器模板，我们需要的是创建一个新的迭代器类，但是要按照这个迭代器模板实现（所以是<code>implements Iterator&lt;Item&gt;</code>）<br>因为Iterator这个类名已被占用，所以我们创建的新的迭代器类不能命名为Iterator（这里命名的为ListIterator）</p><p>Example<br>假设我们有一个stack对象<code>Stack&lt;String&gt; ourNewStack = new Stack&lt;String&gt;()</code>，并且这个stack类实现了iterator<br>当我们执行语句 <code>for (String item : ourNewStack)</code>时：</p><ol><li>Java首先调用这个类中的iterator()函数来创建一个新的Iterator实例，这个实例里面包含<code>hasNext()</code> 和 <code>next()</code>两个methods</li><li>Java首先调用<code>hasNext()</code>来判断是否有下一个元素，再调用<code>next()</code>来返回下一个元素，直到所有元素遍历完成</li></ol><h5 id="Bag-包"><a href="#Bag-包" class="headerlink" title="Bag 包"></a>Bag 包</h5><p>利用迭代器可以实现一种名为Bag的数据结构，可以将item放入bag，然后遍历所有放入bag中的item</p><h3 id="Week-3-Sort-Algorithm-排序算法"><a href="#Week-3-Sort-Algorithm-排序算法" class="headerlink" title="Week 3. Sort Algorithm 排序算法"></a>Week 3. Sort Algorithm 排序算法</h3><h4 id="Ref-Comparable接口"><a href="#Ref-Comparable接口" class="headerlink" title="Ref: Comparable接口"></a>Ref: Comparable接口</h4><p>假设我们新定义了一个日期数据类型Date，里面包括三个int变量month, day, year<br>对于任意两个Date变量，我们想要他们可以比较大小，就需要对这个Date的class实现Compareable接口，包括一个compareTo函数来定义如何比较大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Date implements Comparable&lt;Date&gt; &#123;</span><br><span class="line">    private final int month, day, year;</span><br><span class="line">    public Date (int m, int d, int y) &#123;</span><br><span class="line">        month = m; day = d; year = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int compareTo (Date anotherDay) &#123;</span><br><span class="line">        //如果this Date &gt; anotherDay; return 1;</span><br><span class="line">        //如果this Date &lt; anotherDay; return -1;</span><br><span class="line">        //如果this Date = anotherDay; return 0;</span><br><span class="line">        //需要具体实现以上比较规则</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以利用Comparable类定义两个通用的helper function，在将来的排序算法中能够简化代码量：  </p><ol><li>less (用于判断变量v是否小于变量w)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static boolean less(Comparable v, Comparable w) &#123; </span><br><span class="line">    return v.compareTo(w) &lt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Exchange (假设有一个已经实现了comparable接口的数据类型的数组a，交换数组第i项和第j项的数据)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void exch(Comparable[] a, int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">   Comparable tmp = a[i];</span><br><span class="line">   a[i] = a[j];</span><br><span class="line">   a[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note: 这里的Comparable接口和前面的Iteratable接口、Iterator接口类似，都用到了java泛型，本质上都是一个模板类，里面有一些预先定义的函数（iterator(); compareTo(); hasNext(); next();），java系统可以根据模板对实现了这些接口的数据类型调用这些函数</p><h4 id="Selection-Sort-选择排序"><a href="#Selection-Sort-选择排序" class="headerlink" title="Selection Sort 选择排序"></a>Selection Sort 选择排序</h4><p>设立一个数组的指针i从左向右移动<br>每移动一位，遍历指针i右侧(包括i)的所有项，选择(select)其中最小的项，与当前指针i所指的项交换<br>这样能保证指针左侧的数据已经是排好序的，当指针i遍历到最右时所有数据已排好序</p><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void selectionSort(Comparable[] a) &#123;</span><br><span class="line">    for (int i = 0; i &lt; a.length; i++) &#123; //移动指针</span><br><span class="line">        int min = i;</span><br><span class="line">        for (int j = i+1; j &lt; N; j++)</span><br><span class="line">            if (less(a[j], a[min]))</span><br><span class="line">                min = j; //找出指针i右侧最小的项</span><br><span class="line">        exch(a, i, min); //交换最小项至当前位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h5><p>最好和最坏情况下都需要(N-1) + (N-2) + … + 1 + 0 = N^2/2次比较大小操作和N次交换操作<br>时间复杂度为O(N^2)，空间复杂度为O(N)</p><h4 id="Insertion-Sort-插入排序"><a href="#Insertion-Sort-插入排序" class="headerlink" title="Insertion Sort 插入排序"></a>Insertion Sort 插入排序</h4><p>同样设立一个数组的指针i从左向右移动<br>对于i指向的数据，如果他小于他左边的项，则和左边的数据交换<br>交换之后如果还小于左边的数据则继续交换，直到不小于为止（即指针i左侧的数据全部排好序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void insertionSort(Comparable[] a) &#123;</span><br><span class="line">    int N = a.length;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) //移动指针</span><br><span class="line">        for (int j = i; j &gt; 0; j--) //从当前位置开始往左交换</span><br><span class="line">            if (less(a[j], a[j-1]))</span><br><span class="line">                exch(a, j, j-1);</span><br><span class="line">            else break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Complexity-1"><a href="#Complexity-1" class="headerlink" title="Complexity"></a>Complexity</h5><p>最好情况下，数组本身已排好序，因此需要N次比较和0次交换<br>最坏情况下，数组为倒序，需要N^2/2 次比较和N^2/2次交换（比Selection Sort慢）<br>对于一个已经部分排好序（partially sorted）的数组，Insertion sort所需时间是线性的<br>对于随机的数组，平均需要N^2/4 次比较和N^2/4次交换<br>时间复杂度为O(N^2)，空间复杂度为O(N)</p><h4 id="Shell-Sort-希尔排序"><a href="#Shell-Sort-希尔排序" class="headerlink" title="Shell Sort 希尔排序"></a>Shell Sort 希尔排序</h4><h5 id="1-h-sort"><a href="#1-h-sort" class="headerlink" title="1. h-sort"></a>1. h-sort</h5><p>本质上是Insertion sort，只是每次比较和交换时，和往左数第h个数进行比较和交换<br>（h为1时即为Insertion sort）</p><h5 id="2-Shell-sort"><a href="#2-Shell-sort" class="headerlink" title="2. Shell sort"></a>2. Shell sort</h5><p>设定一个较大的h（h &lt; a.length），进行h-sort<br>缩小h再进行h-sort，直到h为1<br>经过多次h-sort使得数组部分排序，这样最后进行insertion sort所需比较和交换次数会大大降低</p><p>如何确定h序列？<br>一般采用3x+1，即1, 4, 13, 40, 121, 364, …</p><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a) &#123;</span><br><span class="line">    //确定最大的h</span><br><span class="line">    int h = 1</span><br><span class="line">    while (h &lt; N/3) h = 3*h + 1;</span><br><span class="line">    </span><br><span class="line">    while (h &gt;= 1) &#123;</span><br><span class="line">        // h-sort</span><br><span class="line">        for (int i = h; i &lt; N; i++) &#123; //指针（从h开始，因为h往左的项没办法和再左边的第h项比较）</span><br><span class="line">            //比较和交换往左数第h项</span><br><span class="line">            for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h) </span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">        &#125;</span><br><span class="line">        h /= 3; //缩小h，在进行h-sort，直到h为1 (Insertion sort)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Complexity-2"><a href="#Complexity-2" class="headerlink" title="Complexity"></a>Complexity</h5><p>Worst case: <code>$O(N^{3/2})$</code><br>Average: O(NlogN) ~<code>$N^{1.289}$</code></p><h4 id="Ref-Application1：Knuth-Shuffle-洗牌算法"><a href="#Ref-Application1：Knuth-Shuffle-洗牌算法" class="headerlink" title="Ref Application1：Knuth Shuffle 洗牌算法"></a>Ref Application1：Knuth Shuffle 洗牌算法</h4><p>设立一个指针i，从左往右移动<br>每移动一位，生成一个[0,i]之间的随机数r，交换第i位和第r位  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StdRandom.uniform(i + 1); //生成[0, i+1)的随机数</span><br></pre></td></tr></table></figure><h4 id="Ref-Application2-Convex-Hull-闭包算法"><a href="#Ref-Application2-Convex-Hull-闭包算法" class="headerlink" title="Ref Application2: Convex Hull 闭包算法"></a>Ref Application2: Convex Hull 闭包算法</h4><p>问题描述：平面中有一堆点，找出最少的点，这些点连起来围成一个圈可以包括所有点<br>观察：闭包上的点，总可以通过逆时针旋转得到下一个点<br>算法:  </p><ol><li>找出一个原点p，这个点具有最小的y-coordinate</li><li>将原点p和其他点连线，连线与y轴的夹角称为polar angle，按照polar angle从小到大的顺序依次遍历除p外所有点</li><li>将第一个点放入堆栈s</li><li>如果遍历到的点和堆栈s中的顶点组成了一个逆时针旋转(ccw turn)，则将该点入栈，否则将顶点出栈再将该点入栈</li><li>最后留在栈s中的点则为闭包上的点</li></ol><p>如何判断三个点是否呈逆时针旋转  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int ccw(Point2D a, Point2D b, Point2D c) &#123;</span><br><span class="line">    double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);</span><br><span class="line">    if (area2 &lt; 0) return -1; // clockwise</span><br><span class="line">    else if (area2 &gt; 0) return +1; // counter-clockwise</span><br><span class="line">    else return 0; // collinear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Merge-Sort-归并排序"><a href="#Merge-Sort-归并排序" class="headerlink" title="Merge Sort 归并排序"></a>Merge Sort 归并排序</h4><p>分治法的应用，将一个大数组分成两个小数组，分别排好序，再合并为一个排好序的大数组</p><ol><li>Merge函数<br>假设一个数组，左半部分和又半部分已经单独排好序，现在需要排序整个数组<br>需要一个aux辅助数组复制a数组，lo和hi指针分别指向两个子数组的头元素，mid为第一个数组的尾元素<br>依次复制lo和hi指针指向的aux中的元素的最小值回a数组，并相应更改lo和hi指针</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi)&#123;</span><br><span class="line">    //前置条件</span><br><span class="line">    assert isSorted(a, lo, mid); // precondition: a[lo..mid] sorted </span><br><span class="line">    assert isSorted(a, mid+1, hi); // precondition: a[mid+1..hi] sorted </span><br><span class="line">    </span><br><span class="line">    //复制数组</span><br><span class="line">    for (int k = lo; k &lt;= hi; k++) aux[k] = a[k];</span><br><span class="line"></span><br><span class="line">    //归并数组</span><br><span class="line">    int i = lo, j = mid+1;</span><br><span class="line">    for (int k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        if      (i &gt; mid)              a[k] = aux[j++];</span><br><span class="line">        else if (j &gt; hi)               a[k] = aux[i++];</span><br><span class="line">        else if (less(aux[j], aux[i])) a[k] = aux[j++];</span><br><span class="line">        else                           a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    //检查数组是否排好序   </span><br><span class="line">    assert isSorted(a, lo, hi); // postcondition: a[lo..hi] sorted </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="补充：Java-Assertion-断言机制"><a href="#补充：Java-Assertion-断言机制" class="headerlink" title="补充：Java Assertion 断言机制"></a>补充：Java Assertion 断言机制</h5><p>用于debug和提示代码功能<br>e.g. 假设函数<code>isSorted(a, lo, hi)</code>用来判断数组a从第lo位到第hi位的元素是否排好序，在merge sort中我们需要merge两个排好序的数组，这样我们就可以在merge前加入<code>assert isSorted(a, lo, hi)</code>代码，如果两个子数组没有排好序就可以提前报错，方便debug；也可以在merge后加入，用于检验我们的merge算法是否准确，同时也方便说明这段merge代码的作用<br>(注意：assertion是默认不启动的，需要在运行时加入<code>java -ea myProgram</code>)</p><ol start="2"><li>MergeSort<br>有了merge函数，现在可以很方便的递归分割数组，再用merge函数合并</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo) return; //跳出递归条件（只有一个元素的时候）</span><br><span class="line">    int mid = lo + (hi - lo) / 2;</span><br><span class="line">    sort(a, aux, lo, mid);</span><br><span class="line">    sort(a, aux, mid+1, hi);</span><br><span class="line">    //当左数组的最大值小于右数组的最小值，代表整个数组已经排好序，因此不用merge以节省时间</span><br><span class="line">    if (!less(a[mid+1], a[mid])) return;</span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(Comparable[] a) &#123;</span><br><span class="line">    aux = new Comparable[a.length]; //在这里创建aux数组并传入merge以避免重复创建</span><br><span class="line">    sort(a, aux, 0, a.length - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Complexity-3"><a href="#Complexity-3" class="headerlink" title="Complexity"></a>Complexity</h5><p>时间复杂度: <strong>~NlgN</strong> (linearithmic)；空间复杂度： <strong>~N</strong> （需要额外Aux辅助数组）</p><p>证明1：<br>假设D(N)为对总长度为N的数组的两个子数组进行merge所需要的比较和数组access的数量，则有:<br><code>D(N) = 2D(N/2) + N</code>  (归并需要N次比较)<br>往下递归一层，则有:  <code>D(N/2) = 2D(N/4) + N/2</code><br>需要进行两次<code>D(N/2)</code>，因此这层所有的<code>D(N/2)</code>需要<code>(N/2) * 2 = N</code>次比较<br>同理再往下一层，有<code>D(N/4) = 2D(N/8) + N/4</code>，需要进行2*2=4次<code>D(N/4)</code>，一共N次比较<br>因此一直递归到底层<code>D(2)</code>，每层都需要N次比较<br>由于分治法，一共有lgN层，因此时间复杂度为<code>NlgN</code></p><p>证明2（数学归纳法）：<br>Base case：<code>D(1) = 1</code><br>假设：<code>D(N) = NlgN</code><br>证明：<code>D(2N) = 2Nlg2N</code>  </p><p>因为<code>D(N) = 2D(N/2) + N</code><br>所以<code>D(2N) = 2D(N) + 2N</code><br>= <code>2NlgN + 2N</code><br>= <code>2N(lg(2N)-1) + 2N</code><br>= <code>2Nlg2N</code></p><h5 id="改进方法1：CUTOFF"><a href="#改进方法1：CUTOFF" class="headerlink" title="改进方法1：CUTOFF"></a>改进方法1：CUTOFF</h5><p>对于一些小数组，或者递归到一定程度数组比较小的时候，可以直接采用insertion sort以避免不必要的递归开销<br>假设预先设定一个CUTOFF值，当数组总长度小于CUTOFF值时对整个数组采用insertion sort（相当于base case）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//base case </span><br><span class="line">if (hi &lt;= lo + CUTOFF - 1) &#123;</span><br><span class="line">    Insertion.sort(a, lo, hi);</span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经验证当CUTOFF=7，可使MergeSort提升20%速度</p><h5 id="改进方法2：Buttom-up-Sort（自下而上的递归）"><a href="#改进方法2：Buttom-up-Sort（自下而上的递归）" class="headerlink" title="改进方法2：Buttom-up Sort（自下而上的递归）"></a>改进方法2：Buttom-up Sort（自下而上的递归）</h5><p>从左到右，两两元素一组进行merge操作，在4个4个元素一组进行merge，一直增大直到merge元素的长度等于数组的实际长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a) &#123;</span><br><span class="line">    int N = a.length;</span><br><span class="line">    Comparable[] aux = new Comparable[N];</span><br><span class="line">    for (int sz = 1; sz &lt; N; sz *= 2) //每次扩大要合并数组长度为两倍</span><br><span class="line">        for (int lo = 0; lo &lt; N-sz; lo += sz+sz) //遍历，两两一组</span><br><span class="line">            merge(a, aux, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>优点：不需要递归，但比递归法慢10%</p><h4 id="Quick-Sort-快速排序"><a href="#Quick-Sort-快速排序" class="headerlink" title="Quick Sort 快速排序"></a>Quick Sort 快速排序</h4><p>和merge sort同属递归分治法，但先完成相应的部分排序操作，再往下递归缩小问题规模（和merge sort先递归到底再从下往上进行排序操作相反）</p><h5 id="0-预先操作：shuffle-the-array"><a href="#0-预先操作：shuffle-the-array" class="headerlink" title="0. 预先操作：shuffle the array"></a>0. 预先操作：shuffle the array</h5><p>对数组随机洗牌，避免worst case</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StdRandom.shuffle(a); // 传入Comparable[] a</span><br></pre></td></tr></table></figure><h5 id="1-基本步骤：Partition-the-array"><a href="#1-基本步骤：Partition-the-array" class="headerlink" title="1. 基本步骤：Partition the array"></a>1. 基本步骤：Partition the array</h5><p>随机从数组中选取一项v，并将数组分为两部分，使得数组左边所有项小于v，数组右边所有项大于v<br>（注意：这里当存在duplicate key即存在和v相等的项时，指针跳过该项并继续移动，而非交换）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static int partition(Comparable[] a, int lo, int hi) &#123;</span><br><span class="line">    int i = lo, j = hi+1; //设立左右两个指针i，j，并以a[lo]为基准进行Partition分区</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        while (less(a[++i], a[lo]))     //找出数组左边大于基准a[lo]的数，准备和右边小于a[lo]的数交换</span><br><span class="line">            if (i == hi) break; //如果左指针i已经移动到数组右端，则停止移动</span><br><span class="line">            </span><br><span class="line">        while (less(a[lo], a[--j])) //找出数组右边小于基准a[lo]的数，准备和左边大于于a[lo]的数交换</span><br><span class="line">            if (j == lo) break; //如果右指针j已经移动到数组左端，则停止移动（redundant：该命令事实无效）</span><br><span class="line">      </span><br><span class="line">        if (i &gt;= j) break; //如果左右两指针交叉，则数组已完成分区</span><br><span class="line">        exch(a, i, j); //交换左右指针所指的数据</span><br><span class="line">    &#125;</span><br><span class="line">    //数组分完区后，由于指针交叉，右指针j会指向左分区最后一个数，左指针i会指向右分区第一个数</span><br><span class="line">    //因此交换右指针j和指针lo所指向的数据，使得基准a[lo]（此时应该在a[j]的位置）的左边所有数</span><br><span class="line">    //小于基准，右边所有数大于基准</span><br><span class="line">    exch(a, lo, j); </span><br><span class="line">    return j; //这里返回基准的位置（即分区点）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h5><p>分别对左右两分区进行再分区操作，直到分区的大小为1或0</p><p>完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//init：对数组进行洗牌（这样分区后的子数组同样也是随机排列）</span><br><span class="line">public static void sort(Comparable[] a) &#123;</span><br><span class="line">    StdRandom.shuffle(a);</span><br><span class="line">    sort(a, 0, a.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo) return; //base case，右指针小于等于左指针</span><br><span class="line">    int j = partition(a, lo, hi); // 先分区</span><br><span class="line">    sort(a, lo, j-1); //对左分区进行排序</span><br><span class="line">    sort(a, j+1, hi); //对右分区进行排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Complexity-4"><a href="#Complexity-4" class="headerlink" title="Complexity"></a>Complexity</h5><p><strong>Time: ~NlogN (1.39NlogN)</strong><br>Best case：每次分区点都为中点，同merge sort，每层递归需要N次比较，一共有lgN层，<br>因此一共需要N*lgN = NlogN<br>Worst case：每次分区点都为起点，则一共有N层递归，假设为第i层，则需要i次比较，因此复杂度为~0.5 N^2 (very unlikely)<br>Average: ~1.39NlogN (随机洗牌)</p><p>所需compare的次数和Merge sort相比大于39%，但所需交换次数更小，因此速度比merge sort快<br>但merge sort能保证在worst case下依然有~NlogN的复杂度（因为每次递归一定是对半分）而quick sort不能保证（虽然经过洗牌后worst case基本不可能发生），因此相较之下merge sort更稳定</p><p><strong>Space: ~lgN</strong><br>每层递归都需要常数级别空间（指针等），一共有lgN层<br>和Merge sort相比可以实现in-space，即不需要额外空间</p><h5 id="改进方法1：Cut-Off"><a href="#改进方法1：Cut-Off" class="headerlink" title="改进方法1：Cut Off"></a>改进方法1：Cut Off</h5><p>同merge sort，当递归到一定程度，数组比较小的时候，可以直接用insertion sort (CUTOFF ~ 10)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo + CUTOFF - 1) &#123; //base case</span><br><span class="line">        Insertion.sort(a, lo, hi);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int j = partition(a, lo, hi); // 先分区</span><br><span class="line">    sort(a, lo, j-1); //对左分区进行排序</span><br><span class="line">    sort(a, j+1, hi); //对右分区进行排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经验证将CUTOFF设为10到20，能使Quick sort速度平均提升<strong>20%</strong></p><h5 id="改进方法2：Median-of-Sample-随机采样基准点"><a href="#改进方法2：Median-of-Sample-随机采样基准点" class="headerlink" title="改进方法2：Median of Sample 随机采样基准点"></a>改进方法2：Median of Sample 随机采样基准点</h5><p>随机抽取数组中3个点（一般取数组左右端点和中点，即lo, hi 和 lo + (hi - lo)/2），<br>找出其中的中位数并将其设为基准点（即交换到左端点位置），<br>这样找出的基准点能使两分区大小大致相等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo) return;</span><br><span class="line">    </span><br><span class="line">    int m = medianOf3(a, lo, lo + (hi - lo)/2, hi); //找出3个数的中位数的指针，设为基准点</span><br><span class="line">    swap(a, lo, m); //交换左端点和中位数</span><br><span class="line">    </span><br><span class="line">    int j = partition(a, lo, hi);</span><br><span class="line">    sort(a, lo, j-1);</span><br><span class="line">    sort(a, j+1, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经验证可以使Quick sort速度平均提升<strong>10%</strong></p><h4 id="Ref-Quick-Selection-快速选择"><a href="#Ref-Quick-Selection-快速选择" class="headerlink" title="Ref: Quick Selection 快速选择"></a>Ref: Quick Selection 快速选择</h4><p>即找出一个大小为N的数组中第K小的数组，e.g. K=0即最小值，K=N即最大值，K=N/2即中位数  </p><p>解决方案：利用quick sort的一种变体，即对数组进行分区：<br>(1)假设基准点的位置刚好为K，则输出基准点j的值<br>(2)如果基准点j的位置在K左边，则对<strong>右半分区</strong>继续分区，然后循环(1)(2)(3)<br>(3)如果基准点j的位置在K右边，则对<strong>左半分区</strong>继续分区，然后循环(1)(2)(3)<br>重复(1)(2)(3)直到基准点刚好为K</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static Comparable select(Comparable[] a, int k) &#123;</span><br><span class="line">    StdRandom.shuffle(a); //对数组进行洗牌</span><br><span class="line">    int lo = 0, hi = a.length - 1;</span><br><span class="line">    while (hi &gt; lo) &#123;</span><br><span class="line">        int j = partition(a, lo, hi); //分区</span><br><span class="line">        if      (j &lt; k) lo = j + 1; //(2)</span><br><span class="line">        else if (j &gt; k) hi = j - 1; //(3)</span><br><span class="line">        else            return a[k]; //(1)如果基准点位置为K,则输出基准点的值</span><br><span class="line">    &#125;</span><br><span class="line">    return a[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Complexity-5"><a href="#Complexity-5" class="headerlink" title="Complexity"></a>Complexity</h5><p>Time: ~N (linear time)<br>分析：<br>Best Case: 每次分区后，剩余的数组为原来的一半，即需要N+N/2+N/4+N/8+…+1 ~2N<br>Worst Case: 同quick sort，需要进行N次分区，第i次分区需要N-i次比较，共<code>$1/2N^2$</code> (因此需要进行洗牌避免)</p><h4 id="Ref-Three-way-Partitioning"><a href="#Ref-Three-way-Partitioning" class="headerlink" title="Ref: Three-way Partitioning"></a>Ref: Three-way Partitioning</h4><p>假设数组中存在很多相同元素，使用原始的quick sort会导致quadratic的复杂度，<br>(假设数组元素全部相同，则每次递归进行i次比较而不进行交换，一共N次递归，复杂度为worst case的<code>$1/2N^2$</code>)</p><p>因此我们需要实现另一种partition，将数组分为三个区间，<br>将所有与基准点相同的元素一起放在数组中间分区，左边是全部小于基准点的元素，右边是全部大于基准点的元素：</p><table><thead><tr><th>小于v的元素（左区间）</th><th>v, v, v, …, v （基准点区间）</th><th>大于v的元素（右区间）</th></tr></thead></table><ol><li>除了数组的左右边界lo和hi外，还需要3个指针，其中：<br>i指针从左端点往右移动，直到和gt指针交叉<br>lt指针从左往右移动，为基准点区间的起点（lt指针左边的元素为左区间）<br>gt指针从右往左移动，为基准点区间的终点（gt指针右边的元素为右区间）  </li><li>从左往右，每移动i指针一位，进行以下操作(v为基准点的值)：<br>2.1 如果a[i] &lt; v，则交换a[lt]和a[i]，并对指针i和lt加1 (把小于基准点的值移到左区间)<br>2.2 如果a[i] &gt; v，则交换a[gt]和a[i]，并对指针gt减1 (把大于基准点的值移到右区间)<br>2.3 如果a[i] == v，则对指针i加1 (不需要任何移动)  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">    if (hi &lt;= lo) return;</span><br><span class="line">    int lt = lo, gt = hi;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    int i = lo;</span><br><span class="line">    while (i &lt;= gt) &#123;</span><br><span class="line">        int cmp = a[i].compareTo(v);</span><br><span class="line">        if (cmp &lt; 0) exch(a, lt++, i++);</span><br><span class="line">        else if (cmp &gt; 0) exch(a, i, gt--);</span><br><span class="line">        else i++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, lo, lt - 1);</span><br><span class="line">    sort(a, gt + 1, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ref-Java-Comparator"><a href="#Ref-Java-Comparator" class="headerlink" title="Ref: Java Comparator"></a>Ref: Java Comparator</h4><p>用于数组排序：<br>Comparable接口只实现了某种数据类型唯一一种total order的比较大小方式，<br>如果我们希望某种数据类型能够基于不同方式进行大小比较并排序，则需要实现comparator接口：<br>e.g. 我们设计一个student的数据类型，里面有name和section两个变量。<br>如果我们想要student类型的数据按照name变量来排序，则需要实现一个名为ByName的内部接口类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//...外面是名为Student的Class</span><br><span class="line">private static class ByName implements Comparator&lt;Student&gt; &#123;</span><br><span class="line">    public int compare(Student v, Student w) &#123;</span><br><span class="line">        return v.name.compareTo(w.name);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Comparator接口需要定义一个compare方法，用于告诉java系统如何比较两个数据的大小<br>然后我们可以生成一个comparator实例用于排序，这里可以用预先定义的方法生成，也可以用调用函数的方法生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//假设有一个数据类型为Student的数组a</span><br><span class="line"></span><br><span class="line">//预先定义式，可以通过Arrays.sort(a, Student.BY_NAME); 调用并对a数组排序</span><br><span class="line">public Comparator&lt;Student&gt; BY_NAME = new ByName();</span><br><span class="line"></span><br><span class="line">//函数式，可以通过Arrays.sort(a, a[0].getByNameComparator())；调用</span><br><span class="line">public Comparator&lt;Student&gt; getByNameComparator() &#123;</span><br><span class="line">    return new ByName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种数据类型可以既实现Comparable接口，又可以在内部实现Comparator接口并生成Comparator实例</p><h4 id="Ref-Stability"><a href="#Ref-Stability" class="headerlink" title="Ref: Stability"></a>Ref: Stability</h4><p>假设一列数据有多个key，用排序算法对其某个key进行排序<br>一个排序算法是stable的，即对当key的值相同的元素进行排序时，不影响其他key的相对顺序<br>（即假设key1已经是排好序的，对key2进行排序，在key2相同的元素中同样也按key1排好序）</p><p>目前已知的stable算法：insertion和merge</p><h4 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h4><table><thead><tr><th>Algorithms</th><th>inplace?</th><th>stable?</th><th>worst</th><th>average</th><th>best</th><th>remark</th></tr></thead><tbody><tr><td>selection</td><td>yes</td><td></td><td><code>$N^2/2$</code></td><td><code>$N^2/2$</code></td><td><code>$N^2/2$</code></td><td>N exchange</td></tr><tr><td>insertion</td><td>yes</td><td>yes</td><td><code>$N^2/2$</code></td><td><code>$N^2/4$</code></td><td><code>$N$</code></td><td>常用于当N比较小或数组已经部分排好序（近乎线性复杂度）</td></tr><tr><td>shell</td><td>yes</td><td></td><td><code>$N^{1.5}$</code></td><td><code>$N^{1.3}$</code></td><td>N</td><td>subquadratic</td></tr><tr><td>merge</td><td></td><td>yes</td><td><code>$NlgN$</code></td><td><code>$NlgN$</code></td><td><code>$NlgN$</code></td><td><code>$NlgN$</code> guarantee, stable</td></tr><tr><td>quick</td><td>yes</td><td></td><td><code>$N^2/2$</code></td><td><code>$2NlnN$</code></td><td><code>$NlgN$</code></td><td><code>$NlgN$</code> probabilistic guarantee，目前实践中最快的算法</td></tr><tr><td>3-way quick</td><td>yes</td><td></td><td><code>$N^2/2$</code></td><td><code>$2NlnN$</code></td><td><code>$N$</code></td><td>改进的quick sort，适应duplicate key</td></tr><tr><td>Heap</td><td>yes</td><td></td><td><code>$2NlgN$</code></td><td><code>$2NlgN$</code></td><td><code>$NlgN$</code></td><td><code>$NlgN$</code> guarantee, in-place</td></tr></tbody></table><h3 id="Week-4-Priority-Queue-Heap-优先队列-堆"><a href="#Week-4-Priority-Queue-Heap-优先队列-堆" class="headerlink" title="Week 4. Priority Queue / Heap 优先队列 / 堆"></a>Week 4. Priority Queue / Heap 优先队列 / 堆</h3><p>定义，有序的队列，即每次删除操作只删除最大或最小值</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>(e.g. Max Priority Queue, 每次删除最大值)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 注意：与一般Queue相比，我们希望MaxPQ里面的元素是comparable的，以便在队内进行排序操作</span><br><span class="line">public class MaxPQ &lt;key extends Comparable&lt;Key&gt;&gt; &#123;</span><br><span class="line">    MaxPQ()                 // create an empty priority queue</span><br><span class="line">    MaxPQ(Key[] a)          // create an priority queue with given keys</span><br><span class="line">    void insert(key v)      // return and remove the largest key</span><br><span class="line">    boolean isEmpty()       // is the priority queue empty</span><br><span class="line">    key max()               // return the largest key</span><br><span class="line">    int size()              // number of the entries in the priority queue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最简单的两种Priority-Queue实现"><a href="#最简单的两种Priority-Queue实现" class="headerlink" title="最简单的两种Priority Queue实现"></a>最简单的两种Priority Queue实现</h5><ol><li>(Unordered PQ) 每次将元素插入到队列末端，每次删除需要遍历整个Queue找出最小值<br>–插入需要O(1), 删除需要O(N)，查找最值需要O(N)</li><li>(Ordered PQ) 每次插入需要插入到合适位置使queue始终有序，删除操作只需删除队尾元素<br>–插入需要O(N)，删除需要O(1)，查找最值需要O(1), 分为链表和数组两种实现<br><strong>两种都需要O(N)时间复杂度</strong></li></ol><h4 id="Binary-Heap"><a href="#Binary-Heap" class="headerlink" title="Binary Heap"></a>Binary Heap</h4><h5 id="1-Complete-Binary-Tree"><a href="#1-Complete-Binary-Tree" class="headerlink" title="1. Complete Binary Tree"></a>1. Complete Binary Tree</h5><ol><li>Binary Tree二叉树：一个节点连接两个左右子二叉树，或者节点为空的树</li><li>Complete Binary Tree完全二叉树：整个树除了底层节点外，每个节点都有两个子节点<br>一个有N个节点的 CBT的层数为floor(lgN)</li></ol><h5 id="2-Binary-Heap"><a href="#2-Binary-Heap" class="headerlink" title="2. Binary Heap"></a>2. Binary Heap</h5><p>即数组形式表现的Complete Binary Tree<br>如何将CBT存储为数组形式？</p><ol><li>按照层遍历(BST)完全二叉树，并依次分配一个递增的索引index（index start from 1）</li><li>按照分配的索引放入数组a的对应位置<br>(以上称为Heap Ordering 堆排序，即父节点的index一定小于子节点的index，同一层左边的节点index小于右边的)</li></ol><p>通过数组形式存储，我们就无须实际生成整个完全二叉树，通过数组操作实现堆操作</p><h5 id="3-Properties"><a href="#3-Properties" class="headerlink" title="3. Properties"></a>3. Properties</h5><ol><li>index=1 (a[1]) 对应的元素为所有元素的最大值，即根节点为最大值</li><li>index为k的节点的父节点index为k/2，子节点index为2k和2k+1 （因此我们需要index从1开始）</li><li>父节点需要大于（MaxPQ）或小于（MinPQ）其子节点</li></ol><p>通过性质2我们可以很方便的通过数组访问CBT的节点</p><h5 id="4-Eliminate-the-Violation"><a href="#4-Eliminate-the-Violation" class="headerlink" title="4. Eliminate the Violation"></a>4. Eliminate the Violation</h5><p>e.g. (以MaxPQ为例，即堆元素从上往下减小) </p><p><strong>Case 1: Promotion</strong><br>前提假设：我们改变一个节点的值，使其大于父节点的值<br>方法：我们可以将其与父节点交换，交换后再将该节点与新的父节点相比较，层层向上交换直到根节点<br>(Peter Principle: node promoted to level of incompetence，类似于升职过程)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k)) &#123;</span><br><span class="line">        exch(k, k/<span class="number">2</span>);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Case 2: Demotion</strong><br>前提假设：我们改变一个节点的值，使其小于其两个子节点<br>方法：我们将该节点与它最大的子节点交换，交换后再将该节点与新的子节点相比较，层层向下交换直到叶子节点<br>(Power Struggle: Better subordinate promote，类似于降职过程)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j+<span class="number">1</span>)) j++; <span class="comment">// find the maximum child node</span></span><br><span class="line">        <span class="keyword">if</span> (!less(k, j)) <span class="keyword">break</span>; <span class="comment">// legal position</span></span><br><span class="line">        exch(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-Insert"><a href="#5-Insert" class="headerlink" title="5. Insert"></a>5. Insert</h5><p>基于4的Promotion原理，对于新插入的元素，我们可以将其直接插入到数组尾端（即树的叶子节点），然后判断这个新插入的节点是否violation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key x)</span> </span>&#123;</span><br><span class="line">    pq[++N] = x;</span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该操作复杂度为logN，即我们只需要最多1 + floor(lgN)次compare</p><h5 id="6-Delete-the-Max"><a href="#6-Delete-the-Max" class="headerlink" title="6. Delete the Max"></a>6. Delete the Max</h5><p>基于5的Demotion原理，我们用数组中最后一个元素（即最小值）替换掉堆顶元素（即根节点最大值），然后对新的堆顶元素做Demotion操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Key max = pq[<span class="number">1</span>];</span><br><span class="line">    exch(<span class="number">1</span>, N--);</span><br><span class="line">    pq[N+<span class="number">1</span>] = <span class="keyword">null</span>; <span class="comment">// prevent loitering 记得把最后一个节点设为null</span></span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该操作复杂度为logN</p><h5 id="7-Total-Complexity-O-lgN"><a href="#7-Total-Complexity-O-lgN" class="headerlink" title="7. Total Complexity: O(lgN)"></a>7. Total Complexity: O(lgN)</h5><p>Insert: O(lgN); Delete: O(lgN); <strong>Max: O(1)</strong></p><h5 id="8-Other-Notice"><a href="#8-Other-Notice" class="headerlink" title="8. Other Notice"></a>8. Other Notice</h5><ol><li>我们不希望client能够随意改动已经放入PQ的Key，因此实现特定数据结构Key时需要 a. 对整个class声明final，即<code>public final class Key{}</code> b.对数据结构内部所有变量需要设置为<code>private final</code> c. 这个数据类型中所有可调用的方法都不能改变内部变量的值<br>(Some Immutable Variable: String, Integer, Double;<br>Some Mutable Variable: StringBuilder, Stack, Counter, Java array)</li></ol><h4 id="HeapSort-堆排序"><a href="#HeapSort-堆排序" class="headerlink" title="HeapSort 堆排序"></a>HeapSort 堆排序</h4><p>即利用堆顶元素最大的原理，将待排序的元素建立一个堆，每次提取堆顶元素再建立新堆，直到所有元素都提取完成</p><h5 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h5><p>假设存在一个数组a[N]需要排序</p><ol><li>我们将a[N]按照heap order排序，即用这些数据建立一个max heap最大堆</li><li>当我们获得堆后，堆顶元素即为最大值，将其与数组最后一个元素（即第N个元素）交换。<br>设置一个指针i=N指向第N个元素，表示这个元素以及之后的元素是排好序的，剩余堆为[1, i-1]。<br>对堆顶元素进行sink操作直到整个剩余堆[1,i-1]是valid的，</li><li>重复操作2，每次将堆顶元素放入已排好序区间的开头位置，同时移动指针i–，使得这个数组的前面一部分[1, i-1]是堆，后面一部分[i, N]是部分排好序的数组</li></ol><p>注意：为了实现in-place，我们直接在原数组上建堆，即我们从后往前，对每个节点进行sink操作以确保局部堆的合法性。即我们确保了两个局部堆是valid的，然后通过sink两个堆的父节点来确保这两个堆合并为一个大堆后是valid的<br>（实际上第N/2 + 1到第N个元素都是没有子节点的，我们可以直接从第N/2个元素开始）<br>为什么不从前往后建堆：因为所有的insert或者sink操作，前提是需要这个堆除了这个元素外其他都是in heap order的，否则通过sink操作并不能得到valid的堆；从后往前建堆以保证每个子堆vaild以及merge后也是valid的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) sink(a, k, N); <span class="comment">// Step 1：in-place heap builder</span></span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123; <span class="comment">// Step 2: put the largest element to the right and rebuild the heap</span></span><br><span class="line">        exch(a, <span class="number">1</span>, N);</span><br><span class="line">        sink(a, <span class="number">1</span>, --N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（注意这里我们的数组index是从0开始到N-1，而使用PQ的index是从1到N，因此我们需要在进行exch和sink操作时将两种索引进行对应的转换）</p><h5 id="Complexity-NlogN"><a href="#Complexity-NlogN" class="headerlink" title="Complexity: ~NlogN"></a>Complexity: ~NlogN</h5><p>唯一能保证worst case为NlogN的in-place算法<br>（Mergesort：non in-place；Quick Sort：worst case ~N^2）</p><p>补充：为什么在industry中不常用HeapSort：  </p><ol><li>其他sort访问元素都是比较连续的局部顺序访问，而HeapSort经常会需要访问数组中两个距离较远的元素（比如访问子节点依次需要访问1，2，4，8，…等相距的节点），使得CPU需要较大缓存cache（CPU缓存可能一次只能从内存中读取小部分数组，访问其他块的元素需要多次内存&lt;-&gt;缓存操作），导致效率变低</li><li>HeapSort需要的交换次数多于Quick Sort，因为每次建堆过程(insert / delete)都会打乱Heap Order，以致数据有序度降低</li><li>不是Stable的算法 （区别Merge Sort）</li></ol><h3 id="Week-5-Symbol-Table-符号表"><a href="#Week-5-Symbol-Table-符号表" class="headerlink" title="Week 5. Symbol Table 符号表"></a>Week 5. Symbol Table 符号表</h3><p>符号表主要目的就是将一个键（Key）和一个值（value）关联起来，可以将一个键值对（Key-Value Pair）插入到符号表中并能够通过key直接找到对应的value</p><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    ST(); <span class="comment">// 创建一个符号表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>; <span class="comment">// 存储键值对</span></span><br><span class="line">    <span class="function">Value <span class="title">get</span><span class="params">(Key key)</span></span>; <span class="comment">// 获得key对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>; <span class="comment">// 删去key及对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span>; <span class="comment">// 判断ST是否包括key</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断ST是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 获取ST中的键值对数量</span></span><br><span class="line">    <span class="function">Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>; <span class="comment">// 遍历表中的所有key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h5><p>关于null值的几个限定：</p><ol><li>value不能为null</li><li>当key不存在时，get(key) 方法返回null</li><li>当key存在时，put(key, value)方法将覆盖旧的value</li></ol><h5 id="补充：contains和delete方法的实现"><a href="#补充：contains和delete方法的实现" class="headerlink" title="补充：contains和delete方法的实现"></a>补充：contains和delete方法的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于所有的ST，contains方法都是相同的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> get(key) != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种简单的delete方法（仅对某些实现有效）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;put(key, <span class="keyword">null</span>);  &#125;</span><br></pre></td></tr></table></figure><h5 id="补充：Java-Equality-Test-相等性测试"><a href="#补充：Java-Equality-Test-相等性测试" class="headerlink" title="补充：Java Equality Test (相等性测试)"></a>补充：Java Equality Test (相等性测试)</h5><p>所有的java class内部都包含equals()函数，用于测试两个对象是否相等<br>判断对象相等的标准：</p><ol><li>Reflexive 自反性：x.equals(x) == true</li><li>Symmetric 对称性：x.equals(y) iff y.equals(x)</li><li>Transitive 传递性：x.equals(y) &amp; y.equals(z) =&gt; x.equals(z)</li><li>Non-null 非空：x.equals(null) == false</li></ol><p>equals实现方法：</p><ol><li>Java默认实现：x == y （即判断两个对象的地址是否相同，较不常用）</li><li>自定义(即根据不同对象类型自行设计各种判断来实现equals函数，注意需要满足上述四大标准)<br>e.g. 假设我们有个Date类，里面有(int month, int day, int year)三个值，需要实现equals函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object y) &#123; // 注意这里，java规范规定传入类型必须为Object而非自定义的类</span><br><span class="line"></span><br><span class="line">    if (y == this) return true; // 优化：如果两个对象地址相同，则一定相等</span><br><span class="line">    </span><br><span class="line">    if (y == null) return false; // 判断Non-null非空（标准4）</span><br><span class="line">    </span><br><span class="line">    if (y.getClass() != this.getClass()) return false; // 两个对象的类相同，两个对象才相同</span><br><span class="line">    Date that = (Date) y; // 经过上面判断后，cast操作一定成功</span><br><span class="line">    </span><br><span class="line">    // 上面的代码对任何equals函数都是必要的</span><br><span class="line">    </span><br><span class="line">    // 比较各个field的逻辑</span><br><span class="line">    if (this.day != that.day ) return false;</span><br><span class="line">    if (this.month != that.month) return false;</span><br><span class="line">    if (this.year != that.year ) return false;</span><br><span class="line">    return true;</span><br><span class="line">    </span><br><span class="line">    // 对于字段field的比较方法（上面的day，month和year）</span><br><span class="line">    // 1. 如果field为基本数据类型primitive type，则直接用==比较</span><br><span class="line">    // 2. 如果field为object类型，则用该object的equals函数进行比较</span><br><span class="line">    // 3. 如果field为数组，则我们需要遍历数组并对数组中的每一项进行equals比较</span><br><span class="line">    //      (可以采用Arrays.equals(a, b)或者Arrays.deepEquals(a, b) （适用于多维或嵌套数组），</span><br><span class="line">    //      但不能采用a.equals(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两种简单的ST实现"><a href="#两种简单的ST实现" class="headerlink" title="两种简单的ST实现"></a>两种简单的ST实现</h4><h5 id="1-无序链表"><a href="#1-无序链表" class="headerlink" title="1. 无序链表"></a>1. 无序链表</h5><p>键值对为链表的一个节点<br>search：从头至尾遍历链表，直到找到对应的key =&gt; O(n)<br>insert：每次插入先serach对应的key是否存在于链表中，如果不存在则直接插入到链表头部 =&gt; O(n)<br>注意:<br>这种实现只需通过equals()函数比较key而无需通过compareTo()进行key排序，但也无法顺序输出键值对</p><h5 id="2-顺序数组-二分查找"><a href="#2-顺序数组-二分查找" class="headerlink" title="2. 顺序数组 + 二分查找"></a>2. 顺序数组 + 二分查找</h5><p>需要两个并行数组keys和values来分开存储key和value<br>search：通过二分查找函数rank()来获取key在keys数组中的索引i，并以此索引i来获得value = values[i]，如果未找到对应的key则返回null =&gt; O(logN)<br>insert：通过rank()函数找到对应插入的位置i，对keys和values数组将i后面的所有元素往后移动一位，再将key-value插入到对应位置；如果key存在则直接改写对应的value值 =&gt; O(N)<br>注意：和无序链表实现相比，需要通过compareTo()函数实现二分查找，同时可以顺序输出键值对 </p><p>补充：当key是comparable时，还可以有其他应用（统称为ordered operations）：</p><ol><li>找到最小或最大的key （min()和max()函数）或者删除最大或最小值(deleteMin()和deleteMax()函数)</li><li>查找特定位置的key(select()函数)</li><li>找到最接近的key(ceiling()和flooring()函数)</li><li>获得key在ST表中的顺位(rank()函数)</li><li>迭代ST表</li></ol><h4 id="Binary-Search-Tree-二叉查找树"><a href="#Binary-Search-Tree-二叉查找树" class="headerlink" title="Binary Search Tree 二叉查找树"></a>Binary Search Tree 二叉查找树</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>每个节点有一个key值，每个节点的key值大于这个节点的左子树中所有节点的key值，小于这个节点右子树中所有节点的key值</p><p>每个node有四个field：key，value，left，right</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line">    <span class="keyword">private</span> Value val;</span><br><span class="line">    <span class="keyword">private</span> Node left, right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p>与quick sort的关联：和quick sort一样有一个partition的过程，因此BST的inorder是有序的</p><h5 id="查找key对应的value"><a href="#查找key对应的value" class="headerlink" title="查找key对应的value"></a>查找key对应的value</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = root;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x = x.left; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x = x.right; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：key所在的节点深度+1（Average: ~2lnN，由quick sort启发得来）</p><h5 id="插入一个key-value-pair"><a href="#插入一个key-value-pair" class="headerlink" title="插入一个key-value pair"></a>插入一个key-value pair</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span></span><br><span class="line"><span class="function"></span>&#123;  root = put(root, key, val);  <span class="comment">// re-link &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val);</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left = put(x.left, key, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = put(x.right, key, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) x.val = val;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// tricky part：注意这里我们虽然返回的是一个节点，但我们需要把他想象成一个link，让其父节点连接到这个修改后的子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：key所在的节点深度+1 （Average: ~2lnN）<br>补充：二叉树的形状，取决于节点插入的顺序<br>如果二叉树的节点是按顺序插入的，则二叉树呈一斜线，此时二叉树的高度最大 (worst case)，等同于一个linkedlist<br>Average Height: ~4.311lnN (随机顺序插入情况下)</p><h5 id="删除一个key-value-pair"><a href="#删除一个key-value-pair" class="headerlink" title="删除一个key-value pair"></a>删除一个key-value pair</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;  root = delete(root, key);  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left = delete(x.left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = delete(x.right, key);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x.left; <span class="comment">// 没有左子树，直接返回右子树</span></span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x.right; <span class="comment">// 没有右子树，直接返回左子树</span></span><br><span class="line">        <span class="comment">// 找出右子树的最小节点来替换该节点</span></span><br><span class="line">        Node t = x;</span><br><span class="line">        x = min(t.right); <span class="comment">// 找出右子树的最小节点替换该节点</span></span><br><span class="line">        x.right = deleteMin(t.right); <span class="comment">// 删掉这个最小节点（因为要替换到该节点的位置）</span></span><br><span class="line">        x.left = t.left; <span class="comment">// 将旧节点的左子树附到新节点的左子树上</span></span><br><span class="line">    &#125;</span><br><span class="line">    x.count = size(x.left) + size(x.right) + <span class="number">1</span>; <span class="comment">// 更新该节点的size()</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：sqrt(N)<br>这种删除方法存在一个问题，因为我们总是将右子树的最小值替换到删除的节点，因此当长时间进行动态的insert和delete操作后，树变得不再balance而会偏向一边（左边），导致后面的insert、search和delete操作的复杂度变为比lgN更大的sqrt(N)<br>该问题目前无解，即使是随机的选取左子树的最大值或者右子树的最小值替换删除的节点，复杂度仍为sqrt(N)<br>另外如果delete操作是order的，也会导致BST变为完全不平衡的树（因此引入红黑树解决此问题，后续会讲）</p><h5 id="Ordered-Operations"><a href="#Ordered-Operations" class="headerlink" title="Ordered Operations"></a>Ordered Operations</h5><p>min() / max(): 一直递归左子树直到叶节点即为最小值；一直递归右子树直到叶节点即为最大值<br>floor()：找出比该key小的所有节点的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = floor(root, key); <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="keyword">return</span> x.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key); </span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x; <span class="comment">// 找到exact same的值，直接返回节点</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> floor(x.left, key); <span class="comment">//当前节点比key大，说明target肯定在该节点的左子树中</span></span><br><span class="line">    Node t = floor(x.right, key); <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="comment">// 当前节点比key小，说明当前节点可能是target</span></span><br><span class="line">    <span class="comment">// 如果在他右子树中能发现target，则证明能找到更大的比key小的值，返回新的target</span></span><br><span class="line">    <span class="comment">// 否则当前节点的值就是要找的下界，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ceiling()同理类推<br>size()：在node节点中增加一个size field，代表该节点为根的树的大小，在插入操作时同时修改每个节点的size<br>rank()：利用size()函数递归操作，对于某个节点的rank，等于其左子树的size()以及其父节点的左子树的size()依次递归</p><p>Ordered Iteration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Key&gt; q = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">    inorder(root, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Inorder traversal: BST的中序遍历为有序的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node x, Queue&lt;Key&gt; q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">    inorder(x.left, q);</span><br><span class="line">    q.enqueue(x.key);</span><br><span class="line">    inorder(x.right, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：除了Ordered Iteration为N，其他ordered operation的复杂度都为h (节点的深度，avg为lgN)</p><h4 id="2-3-Tree"><a href="#2-3-Tree" class="headerlink" title="2-3 Tree"></a>2-3 Tree</h4><h5 id="定义-amp-特征"><a href="#定义-amp-特征" class="headerlink" title="定义&amp;特征"></a>定义&amp;特征</h5><p>2-3 Tree是Balanced Search Tree的一种，每个节点可以有1个或两个key，分别称为2-node或3-node:<br>2-node: 包含1个key和2个子节点，其中左子树的所有节点的key小于该节点，右子树所有节点的key大于该节点<br>3-node: 包含2个key和3个子节点，假设该节点有两个key，分别为a和b，则有：  </p><ol><li>这个节点左子树的所有节点的key小于a  </li><li>这个节点右子树的所有节点的key大于b  </li><li>这个节点中子树的所有节点介于a和b之间  </li></ol><p>2-3树有如下特征：  </p><ol><li>每条从root节点到叶子节点（或null节点）路径的长度总是相等的（即Perfect Balanced）</li><li>2-3树的中序遍历也是有序的</li><li>树的高度：<ol><li>worst case（即全为2-node）：lgN</li><li>best case（即全为3-node）：log_3 N (~0.631lgN)</li></ol></li></ol><h5 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h5><p>基本方法和BST相同：</p><ol><li>如果target在一个2-node或3-node里面，表示找到target</li><li>如果dfs到一个2-node且target不在里面，如果2-node的key &gt; target则递归到左子树，反之递归到右子树</li><li>如果dfs到一个3-node且target不再里面，假设有两个key分别为a，b，如果target &lt; a则递归到左子树，如果a &lt; target &lt; b则递归到中子树，如果target &gt; b则递归到右子树</li><li>如果节点为null，代表没找到target，返回null</li></ol><h5 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h5><p>假设我们通过search找到key要插入的位置，为一个2-node或3-node叶子节点</p><ol><li>假设要插入的位置为2-node，我们可以直接插入到2-node使其变为一个3-node</li><li>如果要插入的位置为3-node：<ol><li>我们先将key插入到这个3-node使其变为一个临时的4-node（即含有三个key和四个子树）  </li><li>然后进行split操作：将这个4-node分开成3个2-node，最左边的2-node包含了原本4-node的左边两个子树，最右边的2-node包含了原本右4-node的右边两个子树，中间的2-node将其向上合并到原本4-node的父节点  </li><li>此时原本4-node的父节点可能是一个3-node，也有可能是一个4-node，如果是一个4-node，就继续进行split操作并向上合并。如果是3-node则无需进一步操作</li></ol></li></ol><p>补充：2-3树原理较为简单，但实现比较复杂，需要考虑到多种情况，这里暂时不需要掌握具体实现<br>另外有其他实现更简单的Balance Search Tree（e.g. 红黑树）</p><h5 id="Complexity-6"><a href="#Complexity-6" class="headerlink" title="Complexity"></a>Complexity</h5><p>所有操作都能保证为lgN的复杂度 (lgN guarantee)</p><h4 id="left-leaning-Red-Black-BSTs"><a href="#left-leaning-Red-Black-BSTs" class="headerlink" title="(left-leaning) Red-Black BSTs"></a>(left-leaning) Red-Black BSTs</h4><h5 id="定义-amp-特征-1"><a href="#定义-amp-特征-1" class="headerlink" title="定义&amp;特征"></a>定义&amp;特征</h5><p>基本思想：2-3树因为存在2-node和3-node（尤其是3-node），因此插入和查找操作相对BST比较复杂。我们希望我们的树结构能和BST一样简单,但是又能体现出2-node和3-node。即我们需要在BST中用一种简单的方法来表现3-node</p><p>如何在BST中表现3-node？  </p><p><img src="https://i.loli.net/2020/08/03/RgQrAKTNGbW3tLl.png" alt="3-node.png"></p><p>我们用一个称为left-leaning link（即上图红色的边）来粘结3-node，此时原本3-node的左子树为a的左子树，中子树为a的右子树，右子树为b的右子树</p><p>原本3-node中较大的key为新的BST中的根节点，我们用红色的边标记a和b之间的internal link，以示和其他link区别</p><p>e.g. 完整的2-3 Tree以及其对应的RB Tree表示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/J1zfU7nHmVuEb6O.png" alt="2-3 Tree.png" title>                </div>                <div class="image-caption">2-3 Tree.png</div>            </figure><p>黑色的边连接原本的2-node或3-node，红色的边为internal link，用来表现3-node</p><p>红黑树定义：</p><ol><li><p>任何节点不会有两个红色的边与其相连</p></li><li><p>任何从根节点到叶子节点（或null节点）的路径所包括的黑色的边的数量相同 （黑色边连接2-node和3-node，原先2-3树中每条路径的节点数相同，对应红黑树的黑边数量相同）</p></li><li><p>所有红色的边都是向左的，称为left-leaning</p></li></ol><h5 id="Search-amp-other-ordered-ops"><a href="#Search-amp-other-ordered-ops" class="headerlink" title="Search &amp; other ordered ops"></a>Search &amp; other ordered ops</h5><p>Search操作以及其他ordered ops和BST是完全一样的，但由于树的平衡性更好，因而效率更高</p><h5 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">   Key key;</span><br><span class="line">   Value val;</span><br><span class="line">   Node left, right;</span><br><span class="line">   <span class="keyword">boolean</span> color; <span class="comment">// color of parent link</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> x.color == RED; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BST节点的基础上增加一个color field，用来表示这个节点连接到其父节点的边颜色</p><p>（上图中，A, E, S节点的color为RED而其他node为BLACK）</p><p>补充：我们默认所有null节点都是黑色的（因为它不可能是3-node中的key）</p><h5 id="Basic-Operations-Required-For-Insertion"><a href="#Basic-Operations-Required-For-Insertion" class="headerlink" title="Basic Operations Required For Insertion"></a>Basic Operations Required For Insertion</h5><p>在实现insertion 操作之前，我们需要实现两个基本的rotation操作，使得将一个right-leaning的3-node变成left-leaning，或者将一个left-leaning的3-node临时变成right-leaning（再变回left-leaning）。还需要一个等效于原来4-node分裂成2-node的操作。后续Insertion操作会用到这些操作</p><ol><li>Rotate Left</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/2MnBDKL9Xu8sFTH.png" alt="rotateLeft.png" title>                </div>                <div class="image-caption">rotateLeft.png</div>            </figure><p>假设h节点的右节点为红色（即leaning-right），rotate之后x将成为新的父节点并返回。剩余的三棵子树中，原来的左子树和右子树都不用变（还是连接在原来的h和x节点上），中子树需要从原来x节点的左子树连接到h节点的右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(h.right)</span></span>;</span><br><span class="line">    Node x = h.right; <span class="comment">// 先保存x</span></span><br><span class="line">    h.right = x.left; <span class="comment">// 将中子树从x连接到h上</span></span><br><span class="line">    x.left = h; <span class="comment">// 旋转，将h连接到x左边（变为left-leaning）</span></span><br><span class="line">    x.color = h.color; <span class="comment">//同时需要改变两个节点的颜色</span></span><br><span class="line">    h.color = RED;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回旋转后新的3-node根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Rotate Right</p><p>原理同Rotate Left，先调整中子树再rotate</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/rCod3OmeivpX9xS.png" alt="rotateRight.png" title>                </div>                <div class="image-caption">rotateRight.png</div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(h.left)</span></span>;</span><br><span class="line">    Node x = h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    x.color = h.color; <span class="comment">// 注意这里，我们希望旋转之后除了这个3-node之外整个树其他部分都不变化（包括其他各边的颜色），因此这里我们新的根节点的颜色（即这个node连接到上面父节点的边的颜色）选择与原来一样保持不变</span></span><br><span class="line">    h.color = RED;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Color Flip</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/vrjdyOkD67PSzsM.png" alt="colorFlip.png" title>                </div>                <div class="image-caption">colorFlip.png</div>            </figure><p>在insert的过程中可能会遇到一个节点的两个子节点都是Red节点（等价于原来的4-node）。此时我们需要将其分为两个2-node（即图中的A和S节点），并将表示中间key的节点（图中的E）向上移动。</p><p>将4-node分为2个2-node，可以直接将两个红色节点设为黑色即可</p><p>对中间节点（E节点）的颜色进行分类讨论：</p><ol><li><p>假设E的父节点表示的是一个2-node（即只有一个key），则直接将E设为红色节点可以使这个2-node变为一个3-node。即使我们不知道E是左节点还是右节点，我们也可以通过旋转操作进行调整</p></li><li><p>假设E的父节点表示的是一个3-node，则将E设为红色后，E的父节点将有两个红色节点，此时等价于左图中的4-node情况，需要继续进行color flip</p><p>因此我们直接将4-node的中间节点设为红色，左右节点设为黑色即可 (只需设置相应节点的颜色而无需更改link)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !isRed(h);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(h.left)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(h.right)</span></span>;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    h.left.color = BLACK;</span><br><span class="line">    h.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h5><p>基本策略：通过上面的rotation和color flip，实现与2-3 Tree insertion一一对应的等价操作</p><ol><li><p>按照search方法找到插入位置后，我们将要插入的节点设为红色并插入到对应位置（即将原本的2-node变为3-node或原本的3-node变为4-node，因而设为红色）</p></li><li><p>如果插入后的link是right-leaning的，我们通过left-rotation使其变为left-leaning的合法RBT</p></li><li><p>如果插入后，使得存在两个连续的边（下图两种情况）</p><img src="https://i.loli.net/2020/08/03/M9VhyPltbc8ejd4.png" alt="2-leanLeft.png" style="zoom:50%;"><p>左图情况下，直接以c为节点进行rotateRight使其变为一个4-node，再进行color Flip</p><p>右图情况下，因为a节点会比b节点优先检查到，在检查a节点时会进行第二步的left-rotate操作使其变为左图情况</p><p>（补充第另外两种种右左情况和右右情况，因为先检查是否存在right-leaning，因此进行left-rotate后都会变为上面两种情况，因此实际上不会存在）</p><p>因此任意两个node插入第三个node，最终都会归结到左图情况，进行rotateLeft再color flip即可</p></li><li><p>插入后依次向上对每个节点进行合法性检查，最终得到合法RBT</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node h, Key key, Value val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BST插入部分（同一般BST插入）</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, RED);</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(h.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) h.left = put(h.left, key, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) h.right = put(h.right, key, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) h.val = val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查每个节点是否合法：调整节点使其成为合法RBT</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h);<span class="comment">//此时该节点是leaning-right的，直接左旋</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);<span class="comment">//上面case3, 等价于生成4-node</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); <span class="comment">//split 4-node</span></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态转换过程: 对每个非法节点进行一步步的状态转换（一共三种状态），直到转换为合法状态</p><img src="https://i.loli.net/2020/08/03/cHTlxWZAaKDvgO1.png" alt="caseTransfer.png" style="zoom:50%;"><h5 id="Complexity-7"><a href="#Complexity-7" class="headerlink" title="Complexity"></a>Complexity</h5><p>Tree Height: &lt;= 2lgN in worst case (每条路径的黑边数相同，且没有两条连续的红边，假设worst case最坏情况是一条黑边一条红边交错相连，因而worst case为2lgN)；1.00lgN in average case；</p><p>Time Complexity: 2lgN in worst case and lgN in average case for all operations.</p><h4 id="（Optional）B-Tree"><a href="#（Optional）B-Tree" class="headerlink" title="（Optional）B-Tree"></a>（Optional）B-Tree</h4><h5 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h5><p>B-树是Blanced Search Tree在文件系统中的应用。通常我们需要存储大量文件和数据在external storage中，需要尽可能快的查找到所需的文件</p><p>基于2-3树，B-Tree一个节点设置为可以包含最多M个key（M往往很大，e.g. 1024）和M-1个link （而2-3树中每个节点只能包括1个或2个key）。B-Tree还有如下性质</p><ol><li>root节点至少要有两个key</li><li>其他节点至少要有M/2个key （我们不希望每个节点太空，以保证查找高度不会太高）</li><li>所有的数据都存储在external node（外部节点，即叶节点）中，只存储数据的key且从左到右有序排列</li><li>B-Tree的internal node（内部节点，即非叶节点）仅用于搜索而非存储数据和key</li><li>当节点填满后，将一分为两个节点，并在其父节点添加一个新key</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/enNbwI3KcJOVuzC.png" alt="BTree.png" title>                </div>                <div class="image-caption">BTree.png</div>            </figure><h5 id="Complexity-8"><a href="#Complexity-8" class="headerlink" title="Complexity"></a>Complexity</h5><p>log_{M-1} N 到 log{M/2} N，for all operations</p><p>（每个节点包含的边的数量总是在 M/2  到 M-1之间）</p><p>Avg：当M = 1024 &amp; N = 62 billion, log {M/2} N &lt;= 4，即探查次数不超过4次</p><h4 id="Geometric-Application"><a href="#Geometric-Application" class="headerlink" title="Geometric Application"></a>Geometric Application</h4><h5 id="1D-Range-Search"><a href="#1D-Range-Search" class="headerlink" title="1D Range Search"></a>1D Range Search</h5><p>在ST的基础上增加两个函数：</p><ol><li>Range Search：找出所有大小介于k1和k2之间的key</li><li>Range Count：找出所有大小介于k1和k2之间的key的数量</li></ol><p>如果将所有key排列成一条直线（即1维状况），上面两个操作等同于找出这题直线某个区间内的所有点</p><p>BST Implementation：</p><ol><li>count：使用rank函数，找出两个key的rank，两者之差的绝对值即为结果</li><li>search：中序递归，先递归查找左子树中是否包含在两个key之间的key，再检查当前key，再递归查找右子树是否包含在两个key之间的key</li></ol><p>Time Complexity:</p><table><thead><tr><th>data structure</th><th>Insert</th><th>range count</th><th>range search</th></tr></thead><tbody><tr><td>unordered list</td><td>1</td><td>N</td><td>N</td></tr><tr><td>ordered array</td><td>N</td><td>logN</td><td>R + logN</td></tr><tr><td>BST</td><td>logN</td><td>logN</td><td>R + logN</td></tr></tbody></table><p>N = number of keys</p><p>R = number of keys that match</p><p>1D Range Search的应用: Orthogonal line segment intersection</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/AqIHWrZyGQwgLtY.png" alt="Orthogonal line segment intersection.png" title>                </div>                <div class="image-caption">Orthogonal line segment intersection.png</div>            </figure><p>如图，平面中有许多水平线和垂直线。我们需要找出所有的交点。不存在任何重合的直线。</p><p>方法 （Sweep-line Algorithm，线段扫描算法）：</p><ol><li>图中红色的线从左到右依次扫描。遇到一条水平线的左端点后，将这条线的y坐标插入到BST中 （图中按0，1，2，3顺序依次插入）</li><li>遇到一条垂直线的右端点，则将该线的y坐标从BST中移出（移出2）</li><li>遇到垂直线后，假设这个垂直线两端点的y坐标分别为y1和y2，对BST进行Range Search(y1, y2)可以找到与该垂线相交的直线数量（e.g. 搜索线段4在BST中的range可以得到1的y坐标在range范围内，即与线段4相交的线段数量为1）</li></ol><p>时间复杂度：NlogN （每条线需要logN复杂度的BST操作，一共N条线）</p><h5 id="KD-Range-Search"><a href="#KD-Range-Search" class="headerlink" title="KD Range Search"></a>KD Range Search</h5><p>即我们假设每个key有K个维度，通过KD-Tree我们可以搜索给定维度范围内的key</p><p>e.g. 假设二维空间内有一群数据点，每个数据点包括两个field，如一个人的收入和年龄。我们可以通过一个2-D正交搜索（2-D Orthonogal Range Search）来查找给定收入和年龄范围内（e.g. 100K &lt; income &lt; 200K, 25 &lt; age &lt; 40）的所有数据点（等价于查找二维平面内用一个长方形框住的所有点）</p><h5 id="Grid-Implementation"><a href="#Grid-Implementation" class="headerlink" title="Grid Implementation"></a>Grid Implementation</h5><p>Steps</p><ol><li>将二维空间分为M*M个网格</li><li>将每个网格中的点分别存储到对应的list中</li><li>用一个2-D数组来索引每个网格的list</li><li>对于插入操作，利用索引将点直接插入到对应的网格的点list中</li><li>对于range search操作，对于给出的2-d range query，我们找到在这个范围内的所有square，提取出对应square的所有点，再一一检查每个点是否在给定的2-d range query范围内</li></ol><img src="https://i.loli.net/2020/08/03/VRjczSr61unGhdb.png" alt="2DRangeSearch.png" style="zoom:50%;">   <p>Complexity</p><p>Space：M^2 + N (M^2个索引，以及需要用M^2个list存储所有N个点)</p><p>Time：对于每个examined的网格需要平均N/M^2次检查（平均每个网格包含N/M^2个点）</p><p>因此对于划分的网格大小M如果过大会导致空间复杂度上升，过小会导致时间复杂度上升（即space-time tradeoff）。</p><p>一般我们选择M = sqrt(N)，如果数据是evenly distributed的，则初始化索引的复杂度为N（sqrt(N) ^ 2）；insert的复杂度为1，range search的复杂度为1（每个网格平均包含一个点）</p><p>Issue</p><p>通常情况下，数据往往不是evenly distributed而是clustering（即大部分数据都集中在某一片区域，见上图右），导致存在少数很长的list和大多数很空的list（range search复杂度增大至趋近于N），因此需要其他数据结构</p><h5 id="2-D-Tree"><a href="#2-D-Tree" class="headerlink" title="2-D Tree"></a>2-D Tree</h5><p>Example</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/WTEc2B7pPkhJqlO.png" alt="2-DTree.png" title>                </div>                <div class="image-caption">2-DTree.png</div>            </figure><ol><li><p>每个点表示为一个key，包含一个二维坐标。</p></li><li><p>我们将数据点依次插入到一个二叉搜索树中：</p><ol><li><p>对于树中奇数层的点，其左子树的点为平面中在该点左边的点，其右子树中点为平面中在该点右边的点 （e.g. 以点1为例，左子树中3，4，5，6都在点1的左边，2，7，8，9，10都在点1的右边，相当于以点1为基准<strong>将平面分为左右两部分</strong>）</p></li><li><p>对于树中偶数层的点，其左子树的点为平面中在该点下边的点，其右子树中点为平面中在该点上边的点 （e.g. 以点3为例，左子树中4，5都在点1的左边，6在点1的右边，相当于以点3为基准<strong>将子平面分为上下两部分</strong>）</p><p>这样我们每插入一个点，就将一个平面分为两个更小的平面</p></li></ol></li></ol><p>Range Search in 2-D Tree</p><p>e.g. 假设我们需要搜索上图中绿色框范围内的点</p><ol><li>从根节点开始，判断节点是否在范围内，如果在则添加到结果集</li><li>对于在奇数层的节点，如果查询范围的左边界在该节点左边，则递归查找到左子树，如果查询范围的右边界在该节点右边，则递归查找到右子树</li><li>对于在偶数层的节点，如果查询范围的上边界在该节点下边，则递归查找到左子树，如果查询范围的下边界在该节点上边，则递归查找到右子树</li><li>Complexity：R + logN</li></ol><p>2-D树的补充应用：Find Nearest Neighbor </p><p>给出一个点，找出现存平面中离该点最近的点</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/ZXu6dF1VYMDwhPS.png" alt="KDNearestNeighbor.png" title>                </div>                <div class="image-caption">KDNearestNeighbor.png</div>            </figure><ol><li>从根节点开始，计算该节点与目标节点的距离，并更新最短距离</li><li>目标节点应该在该节点划分的两个区域的任意一边，我们优先递归到包含目标节点的区域对应的子树（e.g. 图中目标节点在1节点的左边，因此我们先递归到左子树，即3节点）</li><li>递归完包含目标节点的一边后，我们再判断是否需要递归另外一边的子树（e.g. 递归完1节点左半部分后，得到最近的neighbor为节点5，此时当前最短距离小于1节点右边的理论最短距离（即红色虚线的长度），因此1节点右边的节点与目标节点的距离不可能小于当前的最短距离，因此我们不需要再递归右节点部分，相当于剪枝）</li><li>Complexity：logN（in average），N（worst case, even if tree is balanced）</li></ol><h5 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD Tree"></a>KD Tree</h5><img src="https://i.loli.net/2020/08/03/AUedNujB2tOkFSK.png" alt="KDTree.png" style="zoom:50%;"><p>类似于2D-Tree，奇数层的节点将平面分为左右两部分而偶数层的节点将平面分为上下两部分，我们同样利用BST将其延伸到k维。</p><p>假设节点P在第i mod k 层，则P的左子树的点在第i维都比点p小，右子树的点在第i维都比p大</p><h5 id="Interval-Search-Tree"><a href="#Interval-Search-Tree" class="headerlink" title="Interval Search Tree"></a>Interval Search Tree</h5><p>1D Interval Search Problem</p><p>我们希望实现一种数据结构，能够保存一系列区间（interval），这些区间有可能存在重叠（overlap）</p><p>这个数据结构能够完成如下操作：</p><ol><li>insert：插入一个interval (lo, hi)</li><li>search：搜索一个interval (lo, hi)</li><li>delete：删除一个interval (lo, hi)</li><li>interval intersection query：给定一个interval (lo, hi)，找出所有和这个interval交错（intersect）的区间</li></ol><p>（我们假设所有interval的起点都不同）</p><p>Implementation</p><p>利用BST，每个节点存储一个interval，但只用interval的左端点（即lo值）作为BST每个节点的key。</p><p>另外每个node还要存储以该node为根节点的树中所有节点最大的右端点，记为max （图中蓝色部分）</p><img src="https://i.loli.net/2020/08/03/8tL7lSsduKjkE2p.png" alt="IntervalST.png" style="zoom:50%;"><p>Insertion</p><p>插入操作等同于一般BST的插入，以interval的左端点为key查找到对应的插入位置。</p><p>插入到对应位置后，要延搜索路径回溯并更新路径节点上的max值</p><p>Interval Intersection Search</p><p>假设给出一个query interval  (lo, hi)，只需要查找到一个与其交错的interval</p><p>从根节点开始，对每个节点表示的interval</p><ol><li>if 该interval和query interval交错，则将其添加到结果集</li><li>else if 该节点的左子树为空，递归到右子树</li><li>else if 左节点的max值小于query interval的lo值，递归到右子树 （即所有左子树中的节点都在query interval的左边，不可能存在交叉）</li><li>else 递归到左子树</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node x = root;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.interval.intersects(lo, hi)) <span class="keyword">return</span> x.interval;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) x = x.right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x.left.max &lt; lo) x = x.right;</span><br><span class="line"><span class="keyword">else</span> x = x.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>有效性证明：</p><ol><li><p>当我们搜索右节点时，代表左子树中不可能存在任何交错的节点区间</p></li><li><p>如果我们搜索左节点，如果在左子树中找不到交错的区间，代表即使我们搜索右子树也不可能找到交错的区间节点</p><p>证明：假设左子树不存在交错节点，同时因为搜索左子树，代表左节点的max值大于或等于query interval的lo值（即左子树中存在右端点大于lo的区间）。</p><p>因此如果在左子树中找不到交错节点，代表左子树中所有区间的最左端点都在query interval的右边（即图中hi &lt; c）。又因为右子树中所有区间的左端点肯定大于左子树的最左端点，因此右子树中也不可能找到交错节点</p><img src="/Users/david/Documents/Note/Algorithm/pic/IISProof.png" style="zoom: 33%;"></li></ol><p>延伸：如何找出所有与其交错的intervals</p><p>按上面找一个intersection的方法，每找到一个交错interval，将其删除（或标记为已找到并不再访问），直到找到所有的interval</p><p>Complexity：我们可以采用红黑树，使得对insert, delete, search和find one intersect interval操作的复杂度为logN，对find all intersect interval，假设最后结果集的大小为R，则复杂度为RlogN（即需要R次find one intersect interval操作）</p><p>Application：Orthogonal rectangle intersection</p><p>平面内有一系列长方形（有可能存在相互覆盖或交错），找出所有交错的长方形</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/TCto6HsWAlrfxBp.png" alt="RectIntersectSearch.png" title>                </div>                <div class="image-caption">RectIntersectSearch.png</div>            </figure><p>算法：Sweep Line Algorithm 线性扫描法（类似于1-D range search）</p><p>从左到右扫描所有长方形，每个长方形有一个y-interval记录长方形的上下两边的y值区间。我们用一个Interval Search Tree存储长方形的y-interval</p><ol><li>扫描到一个长方形左边时：<ol><li>查找Interval Search Tree中与该长方形y-interval交错的长方形，并记录到结果集</li><li>将这个长方形的y-interval插入到Interval Search Tree中</li></ol></li><li>扫描到一个长方形右边时：将这个长方形的y-interval从Interval Search Tree中移出</li></ol><p>复杂度：NlogN + RlogN</p><ol><li>将所有长方形按x值排序以便扫描（NlogN）</li><li>所有长方形的y-interval插入到Interval Search Tree中（NlogN）</li><li>删除Interval Search Tree中的y-interval（NlogN）</li><li>搜索交错的区间（NlogN + RlogN）</li></ol><p>该问题为原本2D Orthogonal line segment intersection的升级版，即2D orthogonal rectangle intersection。该算法将原本问题降维至1D interval search，因而降低了时间复杂度</p><h5 id="BST几何应用总结"><a href="#BST几何应用总结" class="headerlink" title="BST几何应用总结"></a>BST几何应用总结</h5><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/RcU5mG7YNPSeCoK.png" alt="BSTGeometricAppConclusion.png" title>                </div>                <div class="image-caption">BSTGeometricAppConclusion.png</div>            </figure><h3 id="Week-6-HashTable-哈希表"><a href="#Week-6-HashTable-哈希表" class="headerlink" title="Week 6. HashTable 哈希表"></a>Week 6. HashTable 哈希表</h3><p>哈希表本质是一个Space-Time Trade-Off的数据结构，相比其他Symbol Table实现（如BST，红黑树），插入和查找的速度更快，但不支持ordered operations</p><p>我们将key-value键值对存储在一个数组中，并实现一个hash function以获得某个key在数组中的index</p><p>为此我们需要解决以下问题：</p><ol><li>如何设计hash function</li><li>如何判断两个key是否相等（Equality Test）</li><li>如何解决两个不同的key具有相同的hash值（Collision Resolution）</li></ol><h4 id="Hash-Function-哈希函数"><a href="#Hash-Function-哈希函数" class="headerlink" title="Hash Function 哈希函数"></a>Hash Function 哈希函数</h4><p>我们希望Hash Function计算效率要高，且每个计算出的index出现的可能性尽可能相等（e.g. 假设key1-10十个数，key1-9的hash都为0而key10的hash为1，这样会造成大量的hash冲突）</p><h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h5><p>对于一个任意类型的对象，我们使用hashCode()函数将其简化为一串数字（介于Integer.MIN_VALUE和Integer.MAX_VALUE之间），便于之后我们设计的hash函数通用化。hashCode()函数需要满足以下要求：</p><ol><li><p>两个相等对象的hashCode相同，即当x.equals(y) == true时, x.hashCode() == y.hashCode() </p></li><li><p>尽可能满足（不一定）当两个对象不同时，其hashCode也不同。即x.equals(y) == false时x.hashCode() != y.hashCode()。</p><p>因此hashCode()函数如果只返回一个常数(e.g. 17)是满足要求的，但没有什么实际用途。</p></li></ol><p>标准方法（Horner’s method）：31x+y</p><p>我们先设置一个初始hash值为<strong>17</strong>（一个质数），然后对于自定义数据结构中的每一个field，我们都采用hash = <strong>31</strong> * hash + field.hashCode()来计算：</p><ol><li>如果field为原始数据类型，则将其转化为包装类型（wrapper type）再使用其hashCode()函数</li><li>如果field为包装类型或引用类型，则直接采用其hashCode()函数</li><li>如果field是一个数组，则对其中的每一项采用hashCode()函数和31x+y规则（或者直接使用Arrays.deepHashCode()函数）。</li></ol><p>补充：所有java的class都内置了hashCode()函数。默认情况下，hashCode()为对象的地址。包装数据类型有其设计好的hashCode()函数</p><h5 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h5><p>假设我们可以使用的数组空间大小为M，则我们的hash()函数为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M; &#125; <span class="comment">// 注意</span></span><br></pre></td></tr></table></figure><p>注意：因为key可能存在负数，因此我们需要先转成正数后才能进行取模操作。</p><p>另外我们不能直接用Math.abs()取正数，因为当hashcode为Integer.MIN_VALUE时该操作会导致整数溢出</p><h5 id="Uniform-Hashing-Assumption"><a href="#Uniform-Hashing-Assumption" class="headerlink" title="Uniform Hashing Assumption"></a>Uniform Hashing Assumption</h5><p>假设数组空间大小为M，且每个key获得0~M-1的index的概率都是相同的</p><p>从概率论角度，当我们随机插入~ sqrt(πM / 2)个key后，会出现两个key有相同的index</p><p>当随机插入~ MlnM个key后，数组每项都会存在至少一个key</p><p>当随机插入M个key后，数组中包含最多key的项大概包含log <em>M /</em> log log <em>M</em>个key</p><h4 id="Collision-Resolution-冲突解决"><a href="#Collision-Resolution-冲突解决" class="headerlink" title="Collision Resolution 冲突解决"></a>Collision Resolution 冲突解决</h4><p>即使我们采用了均匀分布的hash函数，仍然可能存在不同的key具有相同的hash值，即hash冲突</p><h5 id="Separate-Chaining-链表法"><a href="#Separate-Chaining-链表法" class="headerlink" title="Separate Chaining 链表法"></a>Separate Chaining 链表法</h5><p>假设我们的index数组大小为M &lt; N（待插入的键值对数量）。我们对数组中每一项放入一个链表，对于相同hash值的key所对应的键值对将插入到对应的同一个链表。</p><ol><li>Hash：先用hash函数计算key在表中的index i （0 &lt;= i &lt;= M-1）</li><li>Search: 找出数组中的第i项，对其链表进行线性查找</li><li>Insert：如果key不存在则将键值对插入到对应的链表头部。如果存在则改变对应的value值</li></ol><p>平均情况下，每个链表的长度为N/M，因此Search和Insert的复杂度也为~N/M</p><p>M的选择不能过大和过小，一般我们希望平均链表长度为5，此时M ~ N/5，复杂度趋近于log 1</p><h5 id="Opening-Addressing-开放地址法"><a href="#Opening-Addressing-开放地址法" class="headerlink" title="Opening Addressing 开放地址法"></a>Opening Addressing 开放地址法</h5><p>又称为linear probing线性探测法</p><p>Insert：仍然使用hash()函数获取key-value在表中的index，当这个index在数组中已被占用时，从这个index开始向后遍历（index + 1, index + 2, …），直到找到一个空的index将键值对插入</p><p>（注意这里index遍历是循环的，即当index遍历到数组最后一位后，回到数组开头）</p><p>Search：获得index后查找对应位置是否存在key，如果key不相同则继续向后遍历，直到遇到空位置</p><p>注意：index数组的大小M &gt;= N，以保证所有数据都能够被插入</p><p>Complexity</p><p>当数组是半满的情况，每次插入或查找需要的平均探测次数（即依次遍历找到空位的次数）为~3/2</p><p>当数组是接近全满后，每次插入或查找的平均探测次数为~ sqrt(πM / 8)</p><p>即数组越满，插入和查找的效率越低</p><h4 id="HashTable-和-Balanced-BST对比"><a href="#HashTable-和-Balanced-BST对比" class="headerlink" title="HashTable 和 Balanced BST对比"></a>HashTable 和 Balanced BST对比</h4><table><thead><tr><th>HashTable</th><th>Balanced BST （R-B BST）</th></tr></thead><tbody><tr><td>代码更为简单</td><td>性能更稳定</td></tr><tr><td>对于较为简单的key而言效率更高</td><td>支持Ordered Operations</td></tr><tr><td>HashMap</td><td>TreeMap，TreeSet</td></tr></tbody></table><h4 id="几种ST实现比较"><a href="#几种ST实现比较" class="headerlink" title="几种ST实现比较"></a>几种ST实现比较</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2020/08/03/bVdYUsw6NiO8MzH.png" alt="STcomparasion.png" title>                </div>                <div class="image-caption">STcomparasion.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Week-1-Dynamic-Connectivity-动态连通性&quot;&gt;&lt;a href=&quot;#Week-1-Dynamic-Connectivity-动态连通性&quot; class=&quot;headerlink&quot; title=&quot;Week 1. Dynamic Connectivi
      
    
    </summary>
    
    
      <category term="Note" scheme="http://blog.david916.com/categories/Note/"/>
    
    
      <category term="Note" scheme="http://blog.david916.com/tags/Note/"/>
    
      <category term="Algorithm" scheme="http://blog.david916.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>GPU Accelerated Similarity Self-join</title>
    <link href="http://blog.david916.com/2019/12/20/GPU%20Accelerated%20Similarity%20Self-join/"/>
    <id>http://blog.david916.com/2019/12/20/GPU Accelerated Similarity Self-join/</id>
    <published>2019-12-19T16:00:00.000Z</published>
    <updated>2019-12-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The similarity self-join is an operation that finds all objects in a dataset within a distance threshold of each other. A typical method for the self-join is to utilize the search-and-refine strategy: search a set of candidate points that may be within the search radius for every query point, and then refine them by performing the distance calculations. Numerous searches for points within the search distance take advantage of the GPU’s high memory bandwidth and massive parallelism. Thus, the GPU’s architecture is suitable for massively parallel range queries and join operations.</p><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><p>There are many ways for points indexing, divided into two categories: Tree-based indexes (such as R-trees, quad-trees and kd-trees), and non-hierarchical indexes (such as Grids, see Figure 1). Due to the GPU’s SIMT architecture, tree indexes cause divergence in workload among the groups of threads in GPU call warp, so the total performance is depend on the threads in a warp that needs the longest time. On the other hands, each thread performs similar execution pathways in Grid structure. However, we may still have various number of points in different cells in a grid, which is also not very efficient in SIMT architecture.</p><div style="width: 50%; margin: auto"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/nPJtpXEuKz3ABdO.png" alt="Figure 1" title>                </div>                <div class="image-caption">Figure 1</div>            </figure></div>(Figure 1: An example of grid indexing structure in 2D. We want to find all the points that are within ε with point p (the point in the circle area). In order to do that, we use the grid index structure so every point are within a grid cell. Then we  search all the points in the cells adjacents to the cell that contains p (nine cells in the large square bounded by the dash line) to limit the search area. After we find all the points, we verify each point by performing distance calculations (in here we use Euclidean metric), to see if the point are within the circle)<p>Our goal is to minimize the divergence of workload among each threads. To achieve that, we utilize the grid structure, improve it and develop another two grid-base indexing methods. We also extract the feature of datasets to determin which grid indexes we should use, in order to maximize the performance. We have run experiments on differents datasets, synthetic or real-world, and our method generally has better performance, with up to 20x speedup compare to a CPU implementation and up to 5.5x speedup compare to another state-of-art GPU implementation (See Figure 2).</p><div style="width: 50%; margin: auto"><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2019/12/20/YaqAsM9QzmDoEtN.jpg" alt="Figure 2" title>                </div>                <div class="image-caption">Figure 2</div>            </figure></div>(Figure 2: (a) compared with another CPU self-join implementation call SuperEgo and (b) compare to another GPU self-join implementation call GPUCalcGlobal. Datasets are from 2D to 8D. The red lines show the average speedup 6.0x and 2.0x, and the black dash line shows where our approach achieves a speedup (or slowdown)).<p>We are currently improving our optimization methods and drafting the related outcomes. To be continued …</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;The similarity self-join is an
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="GPU" scheme="http://blog.david916.com/tags/GPU/"/>
    
      <category term="Research" scheme="http://blog.david916.com/tags/Research/"/>
    
      <category term="Parallel Computing" scheme="http://blog.david916.com/tags/Parallel-Computing/"/>
    
  </entry>
  
  <entry>
    <title>Prototype Time Limited Dispatch (TLD) Application</title>
    <link href="http://blog.david916.com/2019/03/04/Prototype%20Time%20Limited%20Dispatch%20(TLD)%20Application/"/>
    <id>http://blog.david916.com/2019/03/04/Prototype Time Limited Dispatch (TLD) Application/</id>
    <published>2019-03-03T16:00:00.000Z</published>
    <updated>2019-03-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>For more details, visits the <a href="https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/index.html" target="_blank" rel="noopener">project website</a> &amp; <a href="https://github.com/fssongwei/TLD-Application" target="_blank" rel="noopener">Github Repo</a></p><h2 id="Updates"><a href="#Updates" class="headerlink" title="Updates"></a>Updates</h2><p><strong>v2.1 (03/04/2019)</strong></p><p>Updated chart view: now you can choose the data you want to make a chart for it</p><p><strong>v2.0 (02/26/2019)</strong></p><p>New GUI design</p><p>Add menu for multiple planes data access</p><p>Two view modes: the table view and the chart view</p><p>Real-time data updating and parsing</p><p>Rawdata file can be download directly</p><p><strong>v1.1 (12/08/2018)</strong></p><p>Bug Fix: Fix the csrf verification issue when user click on the return key.</p><p><strong>v1.0 (12/07/2018)</strong></p><p>Release for tech demo</p><p>Finished the implementation of Django, include the user authencation, database connection and data integrity verification by hash value</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><img src="https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/img/honeywell.jpeg" style="zoom: 25%;"> <img src="https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/img/logo.png" style="zoom:25%;"></p><p>Honeywell Aerospace is a leading manufacturer of all sorts of aircraft engines ranging from helicopters to commercial airliners. These engines and their connected systems generate data every flight that is important for the functionality of their product. While in flight, an engine is constantly reading sensor data and storing it on the onboard computer called the Engine Control Unit (ECU). Currently, to gather this data, a technician will physically download the data from the ECU through a wire connection. The cumbersome process of physically connecting to a computer and downloading this data on location greatly limits the amount of flight data to collect. </p><p>Our team, TLD Worker Bee, are working on the project Prototype Time Limited Dispatch (TLD) Application for our sponsor, Harlan Mitchell from Honeywell Aerospace. The initial concept for this project was provided by our sponsor, in the form of a <a href="https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/docs/Mitchell-TLD-Application.pdf" target="_blank" rel="noopener">Capstone project proposal</a>. Our prototype is a web app that uses an internet connection to connect to the data stored in the cloud for a completely wireless experience. It verifies data integrity before showing the user any data to avoid reading false data. This ensures the mechanic knows exactly what maintenance to perform on the engine from anywhere in the world.</p><h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><p>For our requirements acquisition process, we began by brainstorming different use cases for our product to see how a typical user might interact with our system. We were able to come up with a few requirements of our own, but we wanted our sponsor’s opinion on what requirements he felt our system should have as well. We spoke to our sponsor, Harlan Mitchell, about what he would like to see in our final product and how he would like the final product to perform. We explained to him our proposed solution and what we had in mind to fix his problem, and he explained how our proposed solution needs to perform. From this discussion, we gathered a handful of functional and non-functional requirements.</p><p>Our functional requirements are as follows:</p><ul><li><p>[F-SYS1] The web viewer tool shall download the raw data file from the cloud to the user’s computer upon user’s request.</p></li><li><p>[F-SYS2] The web viewer tool shall display the data stored in the database. </p></li><li><p>[F-GUI1] The user shall navigate to data by plane tail number. </p></li><li><p>[F-GUI2] The GUI shall be adaptive for PCs and tablets using Google Chrome. </p><p>Note: Adaptive means the user will see the data without needing to side scroll.</p></li></ul><p>These functional requirements describe how the system is expected to function; they cover both system requirements and GUI requirements.</p><p>Our non-functional or performance requirements are as follows:</p><ul><li>[P-GUI3] The web viewer tool shall display data onto the web page after receiving it from the cloud. </li><li>[P-DT1] The database shall reject SQL injection 100% of the time. </li><li>[P-SYS3] The web viewer tool shall explicitly validate the data after receiving it from the cloud before displaying it on the web browser. This validation will be done by comparing local and cloud MD5 hash values for the data. </li></ul><p>These non-functional requirements describe benchmark goals for the system; they cover system, GUI, and database requirements.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>The solution our team has in mind to build for our sponsor is a prototype web application that will serve as a viewing tool for data that is stored in a cloud. The web application will be able to download the data files a user is requesting from the cloud and display them in the web browser of choice. The web viewing tool we build will be usable on Google Chrome and Apple Safari.</p><p>We have three main components that will each serve a purpose in our solution: cloud storage, parsing and verification services, and a web application. The cloud storage contains the databases for this prototype: one to store data for processing and one to store data that is already processed. These databases communicate with each other using Python to perform operations on the pre-processed data. We will be using Amazon S3 cloud storage to hold the database containing the pre-processed data and Amazon RDS to hold the database containing the processed data. The RDS database is the one that will be accessed when a user makes a data request in the web application. Before the data reaches the web application, it will be sent through a parsing and a verification tool. These tools/services will ensure data integrity throughout the data flow process. For the web application itself, we will be using Django and Python to create a web page to display data that a user requests from the database. This flow of data can be seen below in figure 1.<br><img src="https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/img/dataflow.png" style="zoom: 67%;"></p><p>The data starts by being collected from the ECU and is then sent to the Amazon S3 cloud database. From there, the data is sent through a parsing tool for data processing and is then sent to the Amazon RDS database. Once the user makes a request for data, it is passed through a verification tool before it is displayed to the user in the web application.</p><p>The components discussed above will be used to create software that adheres to the Model View Presenter (MVP) model, a key part of which is that data is handled and represented in three separate layers. These layers are as follows:</p><ul><li>Database Layer: where the data used by the software is stored(Model)</li><li>Presentation Layer: where the data used by the software is displayed(View)</li><li>Service Layer: where the data used by the software is parsed and verified.(Presenter) </li></ul><p>This separation of responsibilities surrounding the data into separate layers ensures a level of security with data parsing and makes sure that the data that is displayed is accurate. This configuration is shown in figure 2.<br><img src="https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/img/architecture.png" style="zoom: 33%;"></p><p>Here are two data view modes to display the TLD data: </p><h3 id="Table-View"><a href="#Table-View" class="headerlink" title="Table View"></a>Table View</h3><p>The table view mode is able to provide an organized way to arrange and display the TLD data by using easy-to-read table and grid structure.</p><img src="https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/img/tableview.png" style="zoom: 33%;"><img src="https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/img/chartview.png" style="zoom:50%;"><h3 id="Chart-View"><a href="#Chart-View" class="headerlink" title="Chart View"></a>Chart View</h3><p>The chart view mode allows the user to plot the specific TLD data, and generate the line chart of that data to help the user analyze the properties and tendency of the specific TLD data.</p><h2 id="Technology"><a href="#Technology" class="headerlink" title="Technology"></a>Technology</h2><p>Here are some technologies and services we choose for this project:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/img/icon.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Python Environment</p><ul><li>Python 3.6 (Python is an interpreted, high-level, general-purpose programming language. All the program and components of this project is written in Python)</li><li>Django 2.2.1 (Django is a high-level Python Web framework. This is the basic of the web application.) -   Pip (Package manager for Python. Use it to install other python components or libraries like Virtualenv, awsebcli and Urllib3) </li><li>Virtualenv (Python Virtual Environment. By using a virtual environment, you can discern exactly which packages are needed by your application so that the required packages are installed on the AWS instances that are running your application.)</li><li>Awsebcli (Elastic Beanstalk Command Line Interface (EB CLI). This is used to initialize your application with the files necessary for deploying with Elastic Beanstalk.)</li><li>Urllib3 (urllib3 is a powerful, sanity-friendly HTTP client for Python. We use it to transfer the raw TLD data from the cloud to the local environment)</li></ul><p>Cloud &amp; Database Services</p><ul><li>Amazon AWS S3 (Amazon Simple Storage Service (Amazon S3) is an object storage service that offers industry-leading scalability, data availability, security, and performance. This is the simulated cloud environment for this project.)</li><li>Amazon RDS (Amazon RDS is easy to set up, operate, and scale a relational database in the cloud.)-   Amazon Elastic Beanstalk (AWS Elastic Beanstalk is an easy-to-use service for deploying and scaling web applications and services developed with Java, .NET, PHP, Node.js, Python, Ruby, Go, and Docker on familiar servers such as Apache, Nginx, Passenger, and IIS.)</li><li>MySQL 5.1 (MySQL is a relational database management system. We use MySQL to manage the database)-   Sequel Pro (Sequel Pro is a fast, easy-to-use Mac database management application for working with MySQL databases.)</li><li>MySQL Workbench (MySQL Workbench is a visual database design tool)</li></ul><p>Code Editor &amp; IDE</p><ul><li>Sublime Text 3 (Sublime Text is a proprietary cross-platform source code editor with a Python API. It’s easy to develop code with Sublime Text 3)</li><li>vim (Vim is a highly configurable text editor built to enable efficient text editing.)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;For more details, visits the &lt;a href=&quot;https://www.ceias.nau.edu/capstone/projects/CS/2019/Workerbee-S19/index.html&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
      <category term="Projects" scheme="http://blog.david916.com/categories/Projects/"/>
    
    
      <category term="Django" scheme="http://blog.david916.com/tags/Django/"/>
    
      <category term="Python" scheme="http://blog.david916.com/tags/Python/"/>
    
      <category term="AWS" scheme="http://blog.david916.com/tags/AWS/"/>
    
  </entry>
  
</feed>
