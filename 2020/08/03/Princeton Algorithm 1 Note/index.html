<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Princeton Algorithm 1 Note | David&#39;s Blog | Eat, Sleep, Code, Repeat</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Note,Algorithm">
    <meta name="description" content="Week 1. Dynamic Connectivity 动态连通性 将所有对象映射为0-N证明：一棵树上的节点x的深度最多为lgN两棵树大小相等时，union操作会使合并得来的新树大小翻倍，但是高度只+1（也可以理解为每次树的高度+1，树的大小则翻倍）因此假设树最开始只有一个节点，经过lgN次翻倍后形成完整的节点数为N的树，此时树的高度为lgN!  ReferenceExercises Solu">
<meta name="keywords" content="Note,Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="Princeton Algorithm 1 Note">
<meta property="og:url" content="http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/index.html">
<meta property="og:site_name" content="David&#39;s Blog">
<meta property="og:description" content="Week 1. Dynamic Connectivity 动态连通性 将所有对象映射为0-N证明：一棵树上的节点x的深度最多为lgN两棵树大小相等时，union操作会使合并得来的新树大小翻倍，但是高度只+1（也可以理解为每次树的高度+1，树的大小则翻倍）因此假设树最开始只有一个节点，经过lgN次翻倍后形成完整的节点数为N的树，此时树的高度为lgN!  ReferenceExercises Solu">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://i.loli.net/2020/08/03/RgQrAKTNGbW3tLl.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/J1zfU7nHmVuEb6O.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/2MnBDKL9Xu8sFTH.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/rCod3OmeivpX9xS.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/vrjdyOkD67PSzsM.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/M9VhyPltbc8ejd4.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/cHTlxWZAaKDvgO1.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/enNbwI3KcJOVuzC.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/AqIHWrZyGQwgLtY.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/VRjczSr61unGhdb.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/WTEc2B7pPkhJqlO.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/ZXu6dF1VYMDwhPS.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/AUedNujB2tOkFSK.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/8tL7lSsduKjkE2p.png">
<meta property="og:image" content="http://blog.david916.com/Users/david/Documents/Note/Algorithm/pic/IISProof.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/TCto6HsWAlrfxBp.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/RcU5mG7YNPSeCoK.png">
<meta property="og:image" content="https://i.loli.net/2020/08/03/bVdYUsw6NiO8MzH.png">
<meta property="og:updated_time" content="2020-08-03T07:11:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Princeton Algorithm 1 Note">
<meta name="twitter:description" content="Week 1. Dynamic Connectivity 动态连通性 将所有对象映射为0-N证明：一棵树上的节点x的深度最多为lgN两棵树大小相等时，union操作会使合并得来的新树大小翻倍，但是高度只+1（也可以理解为每次树的高度+1，树的大小则翻倍）因此假设树最开始只有一个节点，经过lgN次翻倍后形成完整的节点数为N的树，此时树的高度为lgN!  ReferenceExercises Solu">
<meta name="twitter:image" content="https://i.loli.net/2020/08/03/RgQrAKTNGbW3tLl.png">
    
        <link rel="alternate" type="application/atom+xml" title="David&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/icon.jpg">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Wei Song</h5>
          <a href="mailto:ws446@cornell.edu" title="ws446@cornell.edu" class="mail">ws446@cornell.edu</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/fssongwei" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://wei.ai" target="_blank" >
                <i class="icon icon-lg icon-address-card"></i>
                About
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://wei.ai/docs/Wei_Song_CV.pdf" target="_blank" >
                <i class="icon icon-lg icon-file"></i>
                CV
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Princeton Algorithm 1 Note</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Princeton Algorithm 1 Note</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-08-03T07:11:13.000Z" itemprop="datePublished" class="page-time">
  2020-08-03
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Note/">Note</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Week-1-Dynamic-Connectivity-动态连通性"><span class="post-toc-number">1.</span> <span class="post-toc-text">Week 1. Dynamic Connectivity 动态连通性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Reference"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">Reference</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-sum算法"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">3-sum算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内存使用"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">内存使用</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Week-2-Stack-amp-Queue-堆栈和队列"><span class="post-toc-number">2.</span> <span class="post-toc-text">Week 2. Stack &amp; Queue 堆栈和队列</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#resizing-array"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">resizing array</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Loitering问题"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">Loitering问题</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Optimal-Soultion"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">Optimal Soultion:</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Performance"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">Performance</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Memory-Usage"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">Memory Usage</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#LinkedList-vs-Resizing-Array"><span class="post-toc-number">2.1.5.</span> <span class="post-toc-text">LinkedList vs Resizing Array</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Java-Generics-Java泛型"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Java Generics (Java泛型)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Iterator-迭代器"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">Iterator 迭代器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Bag-包"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">Bag 包</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Week-3-Sort-Algorithm-排序算法"><span class="post-toc-number">3.</span> <span class="post-toc-text">Week 3. Sort Algorithm 排序算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ref-Comparable接口"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Ref: Comparable接口</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Selection-Sort-选择排序"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">Selection Sort 选择排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">Complexity</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Insertion-Sort-插入排序"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">Insertion Sort 插入排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity-1"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">Complexity</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Shell-Sort-希尔排序"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">Shell Sort 希尔排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-h-sort"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">1. h-sort</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-Shell-sort"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">2. Shell sort</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity-2"><span class="post-toc-number">3.4.3.</span> <span class="post-toc-text">Complexity</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ref-Application1：Knuth-Shuffle-洗牌算法"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">Ref Application1：Knuth Shuffle 洗牌算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ref-Application2-Convex-Hull-闭包算法"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">Ref Application2: Convex Hull 闭包算法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Merge-Sort-归并排序"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">Merge Sort 归并排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#补充：Java-Assertion-断言机制"><span class="post-toc-number">3.7.1.</span> <span class="post-toc-text">补充：Java Assertion 断言机制</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity-3"><span class="post-toc-number">3.7.2.</span> <span class="post-toc-text">Complexity</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#改进方法1：CUTOFF"><span class="post-toc-number">3.7.3.</span> <span class="post-toc-text">改进方法1：CUTOFF</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#改进方法2：Buttom-up-Sort（自下而上的递归）"><span class="post-toc-number">3.7.4.</span> <span class="post-toc-text">改进方法2：Buttom-up Sort（自下而上的递归）</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Quick-Sort-快速排序"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">Quick Sort 快速排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#0-预先操作：shuffle-the-array"><span class="post-toc-number">3.8.1.</span> <span class="post-toc-text">0. 预先操作：shuffle the array</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-基本步骤：Partition-the-array"><span class="post-toc-number">3.8.2.</span> <span class="post-toc-text">1. 基本步骤：Partition the array</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-递归"><span class="post-toc-number">3.8.3.</span> <span class="post-toc-text">2. 递归</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity-4"><span class="post-toc-number">3.8.4.</span> <span class="post-toc-text">Complexity</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#改进方法1：Cut-Off"><span class="post-toc-number">3.8.5.</span> <span class="post-toc-text">改进方法1：Cut Off</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#改进方法2：Median-of-Sample-随机采样基准点"><span class="post-toc-number">3.8.6.</span> <span class="post-toc-text">改进方法2：Median of Sample 随机采样基准点</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ref-Quick-Selection-快速选择"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">Ref: Quick Selection 快速选择</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity-5"><span class="post-toc-number">3.9.1.</span> <span class="post-toc-text">Complexity</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ref-Three-way-Partitioning"><span class="post-toc-number">3.10.</span> <span class="post-toc-text">Ref: Three-way Partitioning</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ref-Java-Comparator"><span class="post-toc-number">3.11.</span> <span class="post-toc-text">Ref: Java Comparator</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Ref-Stability"><span class="post-toc-number">3.12.</span> <span class="post-toc-text">Ref: Stability</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#排序算法总结"><span class="post-toc-number">3.13.</span> <span class="post-toc-text">排序算法总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Week-4-Priority-Queue-Heap-优先队列-堆"><span class="post-toc-number">4.</span> <span class="post-toc-text">Week 4. Priority Queue / Heap 优先队列 / 堆</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#API"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">API</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#最简单的两种Priority-Queue实现"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">最简单的两种Priority Queue实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Binary-Heap"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Binary Heap</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-Complete-Binary-Tree"><span class="post-toc-number">4.2.1.</span> <span class="post-toc-text">1. Complete Binary Tree</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-Binary-Heap"><span class="post-toc-number">4.2.2.</span> <span class="post-toc-text">2. Binary Heap</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-Properties"><span class="post-toc-number">4.2.3.</span> <span class="post-toc-text">3. Properties</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4-Eliminate-the-Violation"><span class="post-toc-number">4.2.4.</span> <span class="post-toc-text">4. Eliminate the Violation</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#5-Insert"><span class="post-toc-number">4.2.5.</span> <span class="post-toc-text">5. Insert</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#6-Delete-the-Max"><span class="post-toc-number">4.2.6.</span> <span class="post-toc-text">6. Delete the Max</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#7-Total-Complexity-O-lgN"><span class="post-toc-number">4.2.7.</span> <span class="post-toc-text">7. Total Complexity: O(lgN)</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#8-Other-Notice"><span class="post-toc-number">4.2.8.</span> <span class="post-toc-text">8. Other Notice</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HeapSort-堆排序"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">HeapSort 堆排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Implementation"><span class="post-toc-number">4.3.1.</span> <span class="post-toc-text">Implementation</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity-NlogN"><span class="post-toc-number">4.3.2.</span> <span class="post-toc-text">Complexity: ~NlogN</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Week-5-Symbol-Table-符号表"><span class="post-toc-number">5.</span> <span class="post-toc-text">Week 5. Symbol Table 符号表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#API-1"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">API</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Limitation"><span class="post-toc-number">5.1.1.</span> <span class="post-toc-text">Limitation</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#补充：contains和delete方法的实现"><span class="post-toc-number">5.1.2.</span> <span class="post-toc-text">补充：contains和delete方法的实现</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#补充：Java-Equality-Test-相等性测试"><span class="post-toc-number">5.1.3.</span> <span class="post-toc-text">补充：Java Equality Test (相等性测试)</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#两种简单的ST实现"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">两种简单的ST实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-无序链表"><span class="post-toc-number">5.2.1.</span> <span class="post-toc-text">1. 无序链表</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-顺序数组-二分查找"><span class="post-toc-number">5.2.2.</span> <span class="post-toc-text">2. 顺序数组 + 二分查找</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Binary-Search-Tree-二叉查找树"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">Binary Search Tree 二叉查找树</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#定义"><span class="post-toc-number">5.3.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#特征"><span class="post-toc-number">5.3.2.</span> <span class="post-toc-text">特征</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#查找key对应的value"><span class="post-toc-number">5.3.3.</span> <span class="post-toc-text">查找key对应的value</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#插入一个key-value-pair"><span class="post-toc-number">5.3.4.</span> <span class="post-toc-text">插入一个key-value pair</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#删除一个key-value-pair"><span class="post-toc-number">5.3.5.</span> <span class="post-toc-text">删除一个key-value pair</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Ordered-Operations"><span class="post-toc-number">5.3.6.</span> <span class="post-toc-text">Ordered Operations</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-Tree"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">2-3 Tree</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#定义-amp-特征"><span class="post-toc-number">5.4.1.</span> <span class="post-toc-text">定义&amp;特征</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Search"><span class="post-toc-number">5.4.2.</span> <span class="post-toc-text">Search</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Insert"><span class="post-toc-number">5.4.3.</span> <span class="post-toc-text">Insert</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity-6"><span class="post-toc-number">5.4.4.</span> <span class="post-toc-text">Complexity</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#left-leaning-Red-Black-BSTs"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">(left-leaning) Red-Black BSTs</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#定义-amp-特征-1"><span class="post-toc-number">5.5.1.</span> <span class="post-toc-text">定义&amp;特征</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Search-amp-other-ordered-ops"><span class="post-toc-number">5.5.2.</span> <span class="post-toc-text">Search &amp; other ordered ops</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Implementation-1"><span class="post-toc-number">5.5.3.</span> <span class="post-toc-text">Implementation</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Basic-Operations-Required-For-Insertion"><span class="post-toc-number">5.5.4.</span> <span class="post-toc-text">Basic Operations Required For Insertion</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Insertion"><span class="post-toc-number">5.5.5.</span> <span class="post-toc-text">Insertion</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity-7"><span class="post-toc-number">5.5.6.</span> <span class="post-toc-text">Complexity</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#（Optional）B-Tree"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">（Optional）B-Tree</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Defination"><span class="post-toc-number">5.6.1.</span> <span class="post-toc-text">Defination</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Complexity-8"><span class="post-toc-number">5.6.2.</span> <span class="post-toc-text">Complexity</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Geometric-Application"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">Geometric Application</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1D-Range-Search"><span class="post-toc-number">5.7.1.</span> <span class="post-toc-text">1D Range Search</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#KD-Range-Search"><span class="post-toc-number">5.7.2.</span> <span class="post-toc-text">KD Range Search</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Grid-Implementation"><span class="post-toc-number">5.7.3.</span> <span class="post-toc-text">Grid Implementation</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-D-Tree"><span class="post-toc-number">5.7.4.</span> <span class="post-toc-text">2-D Tree</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#KD-Tree"><span class="post-toc-number">5.7.5.</span> <span class="post-toc-text">KD Tree</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Interval-Search-Tree"><span class="post-toc-number">5.7.6.</span> <span class="post-toc-text">Interval Search Tree</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#BST几何应用总结"><span class="post-toc-number">5.7.7.</span> <span class="post-toc-text">BST几何应用总结</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Week-6-HashTable-哈希表"><span class="post-toc-number">6.</span> <span class="post-toc-text">Week 6. HashTable 哈希表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Hash-Function-哈希函数"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">Hash Function 哈希函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#hashCode"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">hashCode()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#hash"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">hash()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Uniform-Hashing-Assumption"><span class="post-toc-number">6.1.3.</span> <span class="post-toc-text">Uniform Hashing Assumption</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Collision-Resolution-冲突解决"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">Collision Resolution 冲突解决</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Separate-Chaining-链表法"><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">Separate Chaining 链表法</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Opening-Addressing-开放地址法"><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">Opening Addressing 开放地址法</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashTable-和-Balanced-BST对比"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">HashTable 和 Balanced BST对比</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#几种ST实现比较"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">几种ST实现比较</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Princeton Algorithm 1 Note"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Princeton Algorithm 1 Note</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-08-03 15:11:13" datetime="2020-08-03T07:11:13.000Z"  itemprop="datePublished">2020-08-03</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Note/">Note</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="Week-1-Dynamic-Connectivity-动态连通性"><a href="#Week-1-Dynamic-Connectivity-动态连通性" class="headerlink" title="Week 1. Dynamic Connectivity 动态连通性"></a>Week 1. Dynamic Connectivity 动态连通性</h3><ol>
<li>将所有对象映射为0-N<br>证明：一棵树上的节点x的深度最多为lgN<br>两棵树大小相等时，union操作会使合并得来的新树大小翻倍，但是高度只+1<br>（也可以理解为每次树的高度+1，树的大小则翻倍）<br>因此假设树最开始只有一个节点，经过lgN次翻倍后形成完整的节点数为N的树，此时树的高度为lgN!</li>
</ol>
<h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h5><p><a href="https://vancexu.github.io/2015/07/21/intro-to-union-find-data-structure-exercise.html" target="_blank" rel="noopener">Exercises Solution</a></p>
<h4 id="3-sum算法"><a href="#3-sum算法" class="headerlink" title="3-sum算法"></a>3-sum算法</h4><p>upper bound为O(N^2logN) （二分查找logN * N^2）<br>lower bound至少为Ω(N) （有可能更高，但目前没有证明）因为算法至少需要遍历一遍所有数字，否则可能会漏过</p>
<p>证明一个算法是最优的（或者优化一个算法），要不降低算法的upper bound，要不证明算法有更高的lower bound<br>（即缩短上下bound之间的gap）<br>当upper bound = lower bound即证明算法没有其他更优解</p>
<p>Big O记号常常用来表示一个算法的性能，但这是错误的，他只表示一个算法的上界。比如：函数<code>$2n^2$</code>，<code>$25000n^3$</code>都可以用<code>$O(n^3)$</code>表示。改用tilde标记 ~<code>$2n^2$</code>来表示特定算法的性能</p>
<h4 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a>内存使用</h4><table>
<thead>
<tr>
<th>Types</th>
<th>Bytes</th>
<th>Types</th>
<th>Bytes</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>2</td>
<td>char[]</td>
<td>2N + 24 (Overhead)</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>int[]</td>
<td>4N + 24 (Overhead)</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>double[]</td>
<td>8N + 24 (Overhead)</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>char[][]</td>
<td>~ 2NM</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>int[][]</td>
<td>~ 4NM</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>double[][]</td>
<td>~ 8NM</td>
</tr>
</tbody></table>
<p>Java对象 Obejct：<br>Object Overhead: 16 Bytes<br>Padding: 填充字节，使得整个object的大小为8的倍数<br>Object的大小= 16 (Overhead) + 变量大小 + Padding<br>e.g. 下面类产生的object有32个字节：16(overhead) + 4*3(variables) + 4(padding)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Date &#123;</span><br><span class="line">    private int day;</span><br><span class="line">    private int month;</span><br><span class="line">    private int year;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指针大小 (reference)：8 Bytes (64位) / 4 Bytes (32位)</p>
<h3 id="Week-2-Stack-amp-Queue-堆栈和队列"><a href="#Week-2-Stack-amp-Queue-堆栈和队列" class="headerlink" title="Week 2. Stack &amp; Queue 堆栈和队列"></a>Week 2. Stack &amp; Queue 堆栈和队列</h3><h4 id="resizing-array"><a href="#resizing-array" class="headerlink" title="resizing array"></a>resizing array</h4><p>如果每添加一个数字，将array扩大1位，则插入N个数据的数组的访问次数为1 + 2 + … + N ~ 0.5 N^2</p>
<h5 id="Loitering问题"><a href="#Loitering问题" class="headerlink" title="Loitering问题"></a>Loitering问题</h5><p>将数组某项设为null，如<code>A[0] == null</code>，可以释放相应的空间   （Stack的array实现中，push操作后需要把相应位置设为null）</p>
<h5 id="Optimal-Soultion"><a href="#Optimal-Soultion" class="headerlink" title="Optimal Soultion:"></a>Optimal Soultion:</h5><p>初始设array大小为1，每次array将满的时候，将array扩大一遍<br>此时array的访问次数大概为 N + (1 + 2 + 4 + 8 + … + N) = ~3N<br>当数组只有1/4满的时候，才将数组大小减半 （防止thrashing抖动问题）</p>
<h5 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h5><p>push 和 pop 操作最好情况下性能为O(1)<br>由于resizing操作，最坏情况（worst case）下性能为O(N)<br>（对比linkedlist实现，最好最坏情况均为O(1)）</p>
<h5 id="Memory-Usage"><a href="#Memory-Usage" class="headerlink" title="Memory Usage"></a>Memory Usage</h5><p>对stack的Linkedlist实现，需要空间为 40N Bytes （一个节点40 Bytes）<br>对array实现，当数组全满时，空间为8N，当数组为1/4满时，空间为32N</p>
<h5 id="LinkedList-vs-Resizing-Array"><a href="#LinkedList-vs-Resizing-Array" class="headerlink" title="LinkedList vs Resizing Array"></a>LinkedList vs Resizing Array</h5><p>链表实现，每个操作都是常数操作，但需要额外空间和用于分配空间的时间，因此平均性能较慢，但比较稳定<br>数组实现，所需空间和运行总时间较少，但可能某个操作遇到需要resize的情况导致效率变慢，性能较不稳定</p>
<h4 id="Java-Generics-Java泛型"><a href="#Java-Generics-Java泛型" class="headerlink" title="Java Generics (Java泛型)"></a>Java Generics (Java泛型)</h4><p>之前设计的都是String类型的stack和queue，如果我们想要实现任何数据类型都可以接收的stack和queue，就需要用到java泛型</p>
<p>Example：创建一个泛型的stack类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class stack&lt;Item&gt; &#123;</span><br><span class="line">//这里预先定义一个Item的数据类型，以后使用的时候可以替换为其他数据类型</span><br><span class="line">    private class Node &#123;</span><br><span class="line">        Item item; //这里引用Item，表示任意传入的数据类型</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Item pop() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... //其他函数或变量</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要使用这个类的对象，可以使用<br><code>Stack&lt;Integer&gt; integerStack = new Stack&lt;Integer&gt;();</code>命令创建一个接受Integer的stack对象</p>
<p><strong>注意：Java不能创建泛型数组</strong><br>如果需要将上面的stack改为数组实现，则可以创建一个Object数组，再将其cast强制转换为Item[]类型的数组：<br><code>Item[] S = (Item[]) new Object[capacity];</code></p>
<p>另外，Java泛型只接受包装数据类型（Wrapper Type），如Integer，String，Double，基本类型（Primitive Type，如int, double）需要转换为包装类型才能用于泛型<br>在一些高版本的java支持Autoboxing(自动打包)，可以直接传入基本数据类型</p>
<h4 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h4><p>Java提供了一种Iterator迭代器机制，可以帮助我们遍历一个class中的所有元素（比如说遍历stack和queue中的元素）</p>
<p>步骤（以stack为例）：</p>
<ol>
<li>创建一个stack类，并实现（implement）iterable接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Stack &lt;Item&gt; implements Iterable&lt;Item&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>Iterable&lt;Item&gt;</code>里面的Item是你要迭代(遍历)的元素的数据类型</p>
<ol start="2">
<li>要实现这个Iterable接口，代表这个stack类中需要有一个iterator函数，这个函数返回一个类型为<code>Iterator&lt;Item&gt;</code>的实例<br>(即返回一个迭代器实例，这样Java每次调用迭代机制的时候会调用这个iterator()函数生成一个新的迭代器)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;Item&gt; iterator() &#123;</span><br><span class="line">    return new ListIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>用一个内部类来实现(implement)我们的迭代器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private class ListIterator implements Iterator&lt;Item&gt; &#123;</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        ... //确定是否能继续迭代</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Item next() &#123;</span><br><span class="line">        ... //返回下一个元素</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里<code>Iterator&lt;Item&gt;</code>是已经预置在Java里面的内部类（其实是一种较为特殊的类称为Interface 接口），类似于一个迭代器模板，我们需要的是创建一个新的迭代器类，但是要按照这个迭代器模板实现（所以是<code>implements Iterator&lt;Item&gt;</code>）<br>因为Iterator这个类名已被占用，所以我们创建的新的迭代器类不能命名为Iterator（这里命名的为ListIterator）</p>
<p>Example<br>假设我们有一个stack对象<code>Stack&lt;String&gt; ourNewStack = new Stack&lt;String&gt;()</code>，并且这个stack类实现了iterator<br>当我们执行语句 <code>for (String item : ourNewStack)</code>时：</p>
<ol>
<li>Java首先调用这个类中的iterator()函数来创建一个新的Iterator实例，这个实例里面包含<code>hasNext()</code> 和 <code>next()</code>两个methods</li>
<li>Java首先调用<code>hasNext()</code>来判断是否有下一个元素，再调用<code>next()</code>来返回下一个元素，直到所有元素遍历完成</li>
</ol>
<h5 id="Bag-包"><a href="#Bag-包" class="headerlink" title="Bag 包"></a>Bag 包</h5><p>利用迭代器可以实现一种名为Bag的数据结构，可以将item放入bag，然后遍历所有放入bag中的item</p>
<h3 id="Week-3-Sort-Algorithm-排序算法"><a href="#Week-3-Sort-Algorithm-排序算法" class="headerlink" title="Week 3. Sort Algorithm 排序算法"></a>Week 3. Sort Algorithm 排序算法</h3><h4 id="Ref-Comparable接口"><a href="#Ref-Comparable接口" class="headerlink" title="Ref: Comparable接口"></a>Ref: Comparable接口</h4><p>假设我们新定义了一个日期数据类型Date，里面包括三个int变量month, day, year<br>对于任意两个Date变量，我们想要他们可以比较大小，就需要对这个Date的class实现Compareable接口，包括一个compareTo函数来定义如何比较大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Date implements Comparable&lt;Date&gt; &#123;</span><br><span class="line">    private final int month, day, year;</span><br><span class="line">    public Date (int m, int d, int y) &#123;</span><br><span class="line">        month = m; day = d; year = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int compareTo (Date anotherDay) &#123;</span><br><span class="line">        //如果this Date &gt; anotherDay; return 1;</span><br><span class="line">        //如果this Date &lt; anotherDay; return -1;</span><br><span class="line">        //如果this Date = anotherDay; return 0;</span><br><span class="line">        //需要具体实现以上比较规则</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以利用Comparable类定义两个通用的helper function，在将来的排序算法中能够简化代码量：  </p>
<ol>
<li>less (用于判断变量v是否小于变量w)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static boolean less(Comparable v, Comparable w) &#123; </span><br><span class="line">    return v.compareTo(w) &lt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Exchange (假设有一个已经实现了comparable接口的数据类型的数组a，交换数组第i项和第j项的数据)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void exch(Comparable[] a, int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">   Comparable tmp = a[i];</span><br><span class="line">   a[i] = a[j];</span><br><span class="line">   a[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note: 这里的Comparable接口和前面的Iteratable接口、Iterator接口类似，都用到了java泛型，本质上都是一个模板类，里面有一些预先定义的函数（iterator(); compareTo(); hasNext(); next();），java系统可以根据模板对实现了这些接口的数据类型调用这些函数</p>
<h4 id="Selection-Sort-选择排序"><a href="#Selection-Sort-选择排序" class="headerlink" title="Selection Sort 选择排序"></a>Selection Sort 选择排序</h4><p>设立一个数组的指针i从左向右移动<br>每移动一位，遍历指针i右侧(包括i)的所有项，选择(select)其中最小的项，与当前指针i所指的项交换<br>这样能保证指针左侧的数据已经是排好序的，当指针i遍历到最右时所有数据已排好序</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void selectionSort(Comparable[] a) &#123;</span><br><span class="line">    for (int i = 0; i &lt; a.length; i++) &#123; //移动指针</span><br><span class="line">        int min = i;</span><br><span class="line">        for (int j = i+1; j &lt; N; j++)</span><br><span class="line">            if (less(a[j], a[min]))</span><br><span class="line">                min = j; //找出指针i右侧最小的项</span><br><span class="line">        exch(a, i, min); //交换最小项至当前位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h5><p>最好和最坏情况下都需要(N-1) + (N-2) + … + 1 + 0 = N^2/2次比较大小操作和N次交换操作<br>时间复杂度为O(N^2)，空间复杂度为O(N)</p>
<h4 id="Insertion-Sort-插入排序"><a href="#Insertion-Sort-插入排序" class="headerlink" title="Insertion Sort 插入排序"></a>Insertion Sort 插入排序</h4><p>同样设立一个数组的指针i从左向右移动<br>对于i指向的数据，如果他小于他左边的项，则和左边的数据交换<br>交换之后如果还小于左边的数据则继续交换，直到不小于为止（即指针i左侧的数据全部排好序）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void insertionSort(Comparable[] a) &#123;</span><br><span class="line">    int N = a.length;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) //移动指针</span><br><span class="line">        for (int j = i; j &gt; 0; j--) //从当前位置开始往左交换</span><br><span class="line">            if (less(a[j], a[j-1]))</span><br><span class="line">                exch(a, j, j-1);</span><br><span class="line">            else break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Complexity-1"><a href="#Complexity-1" class="headerlink" title="Complexity"></a>Complexity</h5><p>最好情况下，数组本身已排好序，因此需要N次比较和0次交换<br>最坏情况下，数组为倒序，需要N^2/2 次比较和N^2/2次交换（比Selection Sort慢）<br>对于一个已经部分排好序（partially sorted）的数组，Insertion sort所需时间是线性的<br>对于随机的数组，平均需要N^2/4 次比较和N^2/4次交换<br>时间复杂度为O(N^2)，空间复杂度为O(N)</p>
<h4 id="Shell-Sort-希尔排序"><a href="#Shell-Sort-希尔排序" class="headerlink" title="Shell Sort 希尔排序"></a>Shell Sort 希尔排序</h4><h5 id="1-h-sort"><a href="#1-h-sort" class="headerlink" title="1. h-sort"></a>1. h-sort</h5><p>本质上是Insertion sort，只是每次比较和交换时，和往左数第h个数进行比较和交换<br>（h为1时即为Insertion sort）</p>
<h5 id="2-Shell-sort"><a href="#2-Shell-sort" class="headerlink" title="2. Shell sort"></a>2. Shell sort</h5><p>设定一个较大的h（h &lt; a.length），进行h-sort<br>缩小h再进行h-sort，直到h为1<br>经过多次h-sort使得数组部分排序，这样最后进行insertion sort所需比较和交换次数会大大降低</p>
<p>如何确定h序列？<br>一般采用3x+1，即1, 4, 13, 40, 121, 364, …</p>
<p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a) &#123;</span><br><span class="line">    //确定最大的h</span><br><span class="line">    int h = 1</span><br><span class="line">    while (h &lt; N/3) h = 3*h + 1;</span><br><span class="line">    </span><br><span class="line">    while (h &gt;= 1) &#123;</span><br><span class="line">        // h-sort</span><br><span class="line">        for (int i = h; i &lt; N; i++) &#123; //指针（从h开始，因为h往左的项没办法和再左边的第h项比较）</span><br><span class="line">            //比较和交换往左数第h项</span><br><span class="line">            for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h) </span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">        &#125;</span><br><span class="line">        h /= 3; //缩小h，在进行h-sort，直到h为1 (Insertion sort)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Complexity-2"><a href="#Complexity-2" class="headerlink" title="Complexity"></a>Complexity</h5><p>Worst case: <code>$O(N^{3/2})$</code><br>Average: O(NlogN) ~<code>$N^{1.289}$</code></p>
<h4 id="Ref-Application1：Knuth-Shuffle-洗牌算法"><a href="#Ref-Application1：Knuth-Shuffle-洗牌算法" class="headerlink" title="Ref Application1：Knuth Shuffle 洗牌算法"></a>Ref Application1：Knuth Shuffle 洗牌算法</h4><p>设立一个指针i，从左往右移动<br>每移动一位，生成一个[0,i]之间的随机数r，交换第i位和第r位  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StdRandom.uniform(i + 1); //生成[0, i+1)的随机数</span><br></pre></td></tr></table></figure>

<h4 id="Ref-Application2-Convex-Hull-闭包算法"><a href="#Ref-Application2-Convex-Hull-闭包算法" class="headerlink" title="Ref Application2: Convex Hull 闭包算法"></a>Ref Application2: Convex Hull 闭包算法</h4><p>问题描述：平面中有一堆点，找出最少的点，这些点连起来围成一个圈可以包括所有点<br>观察：闭包上的点，总可以通过逆时针旋转得到下一个点<br>算法:  </p>
<ol>
<li>找出一个原点p，这个点具有最小的y-coordinate</li>
<li>将原点p和其他点连线，连线与y轴的夹角称为polar angle，按照polar angle从小到大的顺序依次遍历除p外所有点</li>
<li>将第一个点放入堆栈s</li>
<li>如果遍历到的点和堆栈s中的顶点组成了一个逆时针旋转(ccw turn)，则将该点入栈，否则将顶点出栈再将该点入栈</li>
<li>最后留在栈s中的点则为闭包上的点</li>
</ol>
<p>如何判断三个点是否呈逆时针旋转  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int ccw(Point2D a, Point2D b, Point2D c) &#123;</span><br><span class="line">    double area2 = (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);</span><br><span class="line">    if (area2 &lt; 0) return -1; // clockwise</span><br><span class="line">    else if (area2 &gt; 0) return +1; // counter-clockwise</span><br><span class="line">    else return 0; // collinear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Merge-Sort-归并排序"><a href="#Merge-Sort-归并排序" class="headerlink" title="Merge Sort 归并排序"></a>Merge Sort 归并排序</h4><p>分治法的应用，将一个大数组分成两个小数组，分别排好序，再合并为一个排好序的大数组</p>
<ol>
<li>Merge函数<br>假设一个数组，左半部分和又半部分已经单独排好序，现在需要排序整个数组<br>需要一个aux辅助数组复制a数组，lo和hi指针分别指向两个子数组的头元素，mid为第一个数组的尾元素<br>依次复制lo和hi指针指向的aux中的元素的最小值回a数组，并相应更改lo和hi指针</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi)&#123;</span><br><span class="line">    //前置条件</span><br><span class="line">    assert isSorted(a, lo, mid); // precondition: a[lo..mid] sorted </span><br><span class="line">    assert isSorted(a, mid+1, hi); // precondition: a[mid+1..hi] sorted </span><br><span class="line">    </span><br><span class="line">    //复制数组</span><br><span class="line">    for (int k = lo; k &lt;= hi; k++) aux[k] = a[k];</span><br><span class="line"></span><br><span class="line">    //归并数组</span><br><span class="line">    int i = lo, j = mid+1;</span><br><span class="line">    for (int k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        if      (i &gt; mid)              a[k] = aux[j++];</span><br><span class="line">        else if (j &gt; hi)               a[k] = aux[i++];</span><br><span class="line">        else if (less(aux[j], aux[i])) a[k] = aux[j++];</span><br><span class="line">        else                           a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    //检查数组是否排好序   </span><br><span class="line">    assert isSorted(a, lo, hi); // postcondition: a[lo..hi] sorted </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="补充：Java-Assertion-断言机制"><a href="#补充：Java-Assertion-断言机制" class="headerlink" title="补充：Java Assertion 断言机制"></a>补充：Java Assertion 断言机制</h5><p>用于debug和提示代码功能<br>e.g. 假设函数<code>isSorted(a, lo, hi)</code>用来判断数组a从第lo位到第hi位的元素是否排好序，在merge sort中我们需要merge两个排好序的数组，这样我们就可以在merge前加入<code>assert isSorted(a, lo, hi)</code>代码，如果两个子数组没有排好序就可以提前报错，方便debug；也可以在merge后加入，用于检验我们的merge算法是否准确，同时也方便说明这段merge代码的作用<br>(注意：assertion是默认不启动的，需要在运行时加入<code>java -ea myProgram</code>)</p>
<ol start="2">
<li>MergeSort<br>有了merge函数，现在可以很方便的递归分割数组，再用merge函数合并</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo) return; //跳出递归条件（只有一个元素的时候）</span><br><span class="line">    int mid = lo + (hi - lo) / 2;</span><br><span class="line">    sort(a, aux, lo, mid);</span><br><span class="line">    sort(a, aux, mid+1, hi);</span><br><span class="line">    //当左数组的最大值小于右数组的最小值，代表整个数组已经排好序，因此不用merge以节省时间</span><br><span class="line">    if (!less(a[mid+1], a[mid])) return;</span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(Comparable[] a) &#123;</span><br><span class="line">    aux = new Comparable[a.length]; //在这里创建aux数组并传入merge以避免重复创建</span><br><span class="line">    sort(a, aux, 0, a.length - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Complexity-3"><a href="#Complexity-3" class="headerlink" title="Complexity"></a>Complexity</h5><p>时间复杂度: <strong>~NlgN</strong> (linearithmic)；空间复杂度： <strong>~N</strong> （需要额外Aux辅助数组）</p>
<p>证明1：<br>假设D(N)为对总长度为N的数组的两个子数组进行merge所需要的比较和数组access的数量，则有:<br><code>D(N) = 2D(N/2) + N</code>  (归并需要N次比较)<br>往下递归一层，则有:  <code>D(N/2) = 2D(N/4) + N/2</code><br>需要进行两次<code>D(N/2)</code>，因此这层所有的<code>D(N/2)</code>需要<code>(N/2) * 2 = N</code>次比较<br>同理再往下一层，有<code>D(N/4) = 2D(N/8) + N/4</code>，需要进行2*2=4次<code>D(N/4)</code>，一共N次比较<br>因此一直递归到底层<code>D(2)</code>，每层都需要N次比较<br>由于分治法，一共有lgN层，因此时间复杂度为<code>NlgN</code></p>
<p>证明2（数学归纳法）：<br>Base case：<code>D(1) = 1</code><br>假设：<code>D(N) = NlgN</code><br>证明：<code>D(2N) = 2Nlg2N</code>  </p>
<p>因为<code>D(N) = 2D(N/2) + N</code><br>所以<code>D(2N) = 2D(N) + 2N</code><br>= <code>2NlgN + 2N</code><br>= <code>2N(lg(2N)-1) + 2N</code><br>= <code>2Nlg2N</code></p>
<h5 id="改进方法1：CUTOFF"><a href="#改进方法1：CUTOFF" class="headerlink" title="改进方法1：CUTOFF"></a>改进方法1：CUTOFF</h5><p>对于一些小数组，或者递归到一定程度数组比较小的时候，可以直接采用insertion sort以避免不必要的递归开销<br>假设预先设定一个CUTOFF值，当数组总长度小于CUTOFF值时对整个数组采用insertion sort（相当于base case）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//base case </span><br><span class="line">if (hi &lt;= lo + CUTOFF - 1) &#123;</span><br><span class="line">    Insertion.sort(a, lo, hi);</span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经验证当CUTOFF=7，可使MergeSort提升20%速度</p>
<h5 id="改进方法2：Buttom-up-Sort（自下而上的递归）"><a href="#改进方法2：Buttom-up-Sort（自下而上的递归）" class="headerlink" title="改进方法2：Buttom-up Sort（自下而上的递归）"></a>改进方法2：Buttom-up Sort（自下而上的递归）</h5><p>从左到右，两两元素一组进行merge操作，在4个4个元素一组进行merge，一直增大直到merge元素的长度等于数组的实际长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a) &#123;</span><br><span class="line">    int N = a.length;</span><br><span class="line">    Comparable[] aux = new Comparable[N];</span><br><span class="line">    for (int sz = 1; sz &lt; N; sz *= 2) //每次扩大要合并数组长度为两倍</span><br><span class="line">        for (int lo = 0; lo &lt; N-sz; lo += sz+sz) //遍历，两两一组</span><br><span class="line">            merge(a, aux, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>优点：不需要递归，但比递归法慢10%</p>
<h4 id="Quick-Sort-快速排序"><a href="#Quick-Sort-快速排序" class="headerlink" title="Quick Sort 快速排序"></a>Quick Sort 快速排序</h4><p>和merge sort同属递归分治法，但先完成相应的部分排序操作，再往下递归缩小问题规模（和merge sort先递归到底再从下往上进行排序操作相反）</p>
<h5 id="0-预先操作：shuffle-the-array"><a href="#0-预先操作：shuffle-the-array" class="headerlink" title="0. 预先操作：shuffle the array"></a>0. 预先操作：shuffle the array</h5><p>对数组随机洗牌，避免worst case</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StdRandom.shuffle(a); // 传入Comparable[] a</span><br></pre></td></tr></table></figure>

<h5 id="1-基本步骤：Partition-the-array"><a href="#1-基本步骤：Partition-the-array" class="headerlink" title="1. 基本步骤：Partition the array"></a>1. 基本步骤：Partition the array</h5><p>随机从数组中选取一项v，并将数组分为两部分，使得数组左边所有项小于v，数组右边所有项大于v<br>（注意：这里当存在duplicate key即存在和v相等的项时，指针跳过该项并继续移动，而非交换）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private static int partition(Comparable[] a, int lo, int hi) &#123;</span><br><span class="line">    int i = lo, j = hi+1; //设立左右两个指针i，j，并以a[lo]为基准进行Partition分区</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        while (less(a[++i], a[lo]))     //找出数组左边大于基准a[lo]的数，准备和右边小于a[lo]的数交换</span><br><span class="line">            if (i == hi) break; //如果左指针i已经移动到数组右端，则停止移动</span><br><span class="line">            </span><br><span class="line">        while (less(a[lo], a[--j])) //找出数组右边小于基准a[lo]的数，准备和左边大于于a[lo]的数交换</span><br><span class="line">            if (j == lo) break; //如果右指针j已经移动到数组左端，则停止移动（redundant：该命令事实无效）</span><br><span class="line">      </span><br><span class="line">        if (i &gt;= j) break; //如果左右两指针交叉，则数组已完成分区</span><br><span class="line">        exch(a, i, j); //交换左右指针所指的数据</span><br><span class="line">    &#125;</span><br><span class="line">    //数组分完区后，由于指针交叉，右指针j会指向左分区最后一个数，左指针i会指向右分区第一个数</span><br><span class="line">    //因此交换右指针j和指针lo所指向的数据，使得基准a[lo]（此时应该在a[j]的位置）的左边所有数</span><br><span class="line">    //小于基准，右边所有数大于基准</span><br><span class="line">    exch(a, lo, j); </span><br><span class="line">    return j; //这里返回基准的位置（即分区点）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h5><p>分别对左右两分区进行再分区操作，直到分区的大小为1或0</p>
<p>完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//init：对数组进行洗牌（这样分区后的子数组同样也是随机排列）</span><br><span class="line">public static void sort(Comparable[] a) &#123;</span><br><span class="line">    StdRandom.shuffle(a);</span><br><span class="line">    sort(a, 0, a.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo) return; //base case，右指针小于等于左指针</span><br><span class="line">    int j = partition(a, lo, hi); // 先分区</span><br><span class="line">    sort(a, lo, j-1); //对左分区进行排序</span><br><span class="line">    sort(a, j+1, hi); //对右分区进行排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Complexity-4"><a href="#Complexity-4" class="headerlink" title="Complexity"></a>Complexity</h5><p><strong>Time: ~NlogN (1.39NlogN)</strong><br>Best case：每次分区点都为中点，同merge sort，每层递归需要N次比较，一共有lgN层，<br>因此一共需要N*lgN = NlogN<br>Worst case：每次分区点都为起点，则一共有N层递归，假设为第i层，则需要i次比较，因此复杂度为~0.5 N^2 (very unlikely)<br>Average: ~1.39NlogN (随机洗牌)</p>
<p>所需compare的次数和Merge sort相比大于39%，但所需交换次数更小，因此速度比merge sort快<br>但merge sort能保证在worst case下依然有~NlogN的复杂度（因为每次递归一定是对半分）而quick sort不能保证（虽然经过洗牌后worst case基本不可能发生），因此相较之下merge sort更稳定</p>
<p><strong>Space: ~lgN</strong><br>每层递归都需要常数级别空间（指针等），一共有lgN层<br>和Merge sort相比可以实现in-space，即不需要额外空间</p>
<h5 id="改进方法1：Cut-Off"><a href="#改进方法1：Cut-Off" class="headerlink" title="改进方法1：Cut Off"></a>改进方法1：Cut Off</h5><p>同merge sort，当递归到一定程度，数组比较小的时候，可以直接用insertion sort (CUTOFF ~ 10)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo + CUTOFF - 1) &#123; //base case</span><br><span class="line">        Insertion.sort(a, lo, hi);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int j = partition(a, lo, hi); // 先分区</span><br><span class="line">    sort(a, lo, j-1); //对左分区进行排序</span><br><span class="line">    sort(a, j+1, hi); //对右分区进行排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经验证将CUTOFF设为10到20，能使Quick sort速度平均提升<strong>20%</strong></p>
<h5 id="改进方法2：Median-of-Sample-随机采样基准点"><a href="#改进方法2：Median-of-Sample-随机采样基准点" class="headerlink" title="改进方法2：Median of Sample 随机采样基准点"></a>改进方法2：Median of Sample 随机采样基准点</h5><p>随机抽取数组中3个点（一般取数组左右端点和中点，即lo, hi 和 lo + (hi - lo)/2），<br>找出其中的中位数并将其设为基准点（即交换到左端点位置），<br>这样找出的基准点能使两分区大小大致相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo) return;</span><br><span class="line">    </span><br><span class="line">    int m = medianOf3(a, lo, lo + (hi - lo)/2, hi); //找出3个数的中位数的指针，设为基准点</span><br><span class="line">    swap(a, lo, m); //交换左端点和中位数</span><br><span class="line">    </span><br><span class="line">    int j = partition(a, lo, hi);</span><br><span class="line">    sort(a, lo, j-1);</span><br><span class="line">    sort(a, j+1, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经验证可以使Quick sort速度平均提升<strong>10%</strong></p>
<h4 id="Ref-Quick-Selection-快速选择"><a href="#Ref-Quick-Selection-快速选择" class="headerlink" title="Ref: Quick Selection 快速选择"></a>Ref: Quick Selection 快速选择</h4><p>即找出一个大小为N的数组中第K小的数组，e.g. K=0即最小值，K=N即最大值，K=N/2即中位数  </p>
<p>解决方案：利用quick sort的一种变体，即对数组进行分区：<br>(1)假设基准点的位置刚好为K，则输出基准点j的值<br>(2)如果基准点j的位置在K左边，则对<strong>右半分区</strong>继续分区，然后循环(1)(2)(3)<br>(3)如果基准点j的位置在K右边，则对<strong>左半分区</strong>继续分区，然后循环(1)(2)(3)<br>重复(1)(2)(3)直到基准点刚好为K</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static Comparable select(Comparable[] a, int k) &#123;</span><br><span class="line">    StdRandom.shuffle(a); //对数组进行洗牌</span><br><span class="line">    int lo = 0, hi = a.length - 1;</span><br><span class="line">    while (hi &gt; lo) &#123;</span><br><span class="line">        int j = partition(a, lo, hi); //分区</span><br><span class="line">        if      (j &lt; k) lo = j + 1; //(2)</span><br><span class="line">        else if (j &gt; k) hi = j - 1; //(3)</span><br><span class="line">        else            return a[k]; //(1)如果基准点位置为K,则输出基准点的值</span><br><span class="line">    &#125;</span><br><span class="line">    return a[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Complexity-5"><a href="#Complexity-5" class="headerlink" title="Complexity"></a>Complexity</h5><p>Time: ~N (linear time)<br>分析：<br>Best Case: 每次分区后，剩余的数组为原来的一半，即需要N+N/2+N/4+N/8+…+1 ~2N<br>Worst Case: 同quick sort，需要进行N次分区，第i次分区需要N-i次比较，共<code>$1/2N^2$</code> (因此需要进行洗牌避免)</p>
<h4 id="Ref-Three-way-Partitioning"><a href="#Ref-Three-way-Partitioning" class="headerlink" title="Ref: Three-way Partitioning"></a>Ref: Three-way Partitioning</h4><p>假设数组中存在很多相同元素，使用原始的quick sort会导致quadratic的复杂度，<br>(假设数组元素全部相同，则每次递归进行i次比较而不进行交换，一共N次递归，复杂度为worst case的<code>$1/2N^2$</code>)</p>
<p>因此我们需要实现另一种partition，将数组分为三个区间，<br>将所有与基准点相同的元素一起放在数组中间分区，左边是全部小于基准点的元素，右边是全部大于基准点的元素：</p>
<table>
<thead>
<tr>
<th>小于v的元素（左区间）</th>
<th>v, v, v, …, v （基准点区间）</th>
<th>大于v的元素（右区间）</th>
</tr>
</thead>
</table>
<ol>
<li>除了数组的左右边界lo和hi外，还需要3个指针，其中：<br>i指针从左端点往右移动，直到和gt指针交叉<br>lt指针从左往右移动，为基准点区间的起点（lt指针左边的元素为左区间）<br>gt指针从右往左移动，为基准点区间的终点（gt指针右边的元素为右区间）  </li>
<li>从左往右，每移动i指针一位，进行以下操作(v为基准点的值)：<br>2.1 如果a[i] &lt; v，则交换a[lt]和a[i]，并对指针i和lt加1 (把小于基准点的值移到左区间)<br>2.2 如果a[i] &gt; v，则交换a[gt]和a[i]，并对指针gt减1 (把大于基准点的值移到右区间)<br>2.3 如果a[i] == v，则对指针i加1 (不需要任何移动)  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi)&#123;</span><br><span class="line">    if (hi &lt;= lo) return;</span><br><span class="line">    int lt = lo, gt = hi;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    int i = lo;</span><br><span class="line">    while (i &lt;= gt) &#123;</span><br><span class="line">        int cmp = a[i].compareTo(v);</span><br><span class="line">        if (cmp &lt; 0) exch(a, lt++, i++);</span><br><span class="line">        else if (cmp &gt; 0) exch(a, i, gt--);</span><br><span class="line">        else i++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, lo, lt - 1);</span><br><span class="line">    sort(a, gt + 1, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ref-Java-Comparator"><a href="#Ref-Java-Comparator" class="headerlink" title="Ref: Java Comparator"></a>Ref: Java Comparator</h4><p>用于数组排序：<br>Comparable接口只实现了某种数据类型唯一一种total order的比较大小方式，<br>如果我们希望某种数据类型能够基于不同方式进行大小比较并排序，则需要实现comparator接口：<br>e.g. 我们设计一个student的数据类型，里面有name和section两个变量。<br>如果我们想要student类型的数据按照name变量来排序，则需要实现一个名为ByName的内部接口类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//...外面是名为Student的Class</span><br><span class="line">private static class ByName implements Comparator&lt;Student&gt; &#123;</span><br><span class="line">    public int compare(Student v, Student w) &#123;</span><br><span class="line">        return v.name.compareTo(w.name);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator接口需要定义一个compare方法，用于告诉java系统如何比较两个数据的大小<br>然后我们可以生成一个comparator实例用于排序，这里可以用预先定义的方法生成，也可以用调用函数的方法生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//假设有一个数据类型为Student的数组a</span><br><span class="line"></span><br><span class="line">//预先定义式，可以通过Arrays.sort(a, Student.BY_NAME); 调用并对a数组排序</span><br><span class="line">public Comparator&lt;Student&gt; BY_NAME = new ByName();</span><br><span class="line"></span><br><span class="line">//函数式，可以通过Arrays.sort(a, a[0].getByNameComparator())；调用</span><br><span class="line">public Comparator&lt;Student&gt; getByNameComparator() &#123;</span><br><span class="line">    return new ByName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一种数据类型可以既实现Comparable接口，又可以在内部实现Comparator接口并生成Comparator实例</p>
<h4 id="Ref-Stability"><a href="#Ref-Stability" class="headerlink" title="Ref: Stability"></a>Ref: Stability</h4><p>假设一列数据有多个key，用排序算法对其某个key进行排序<br>一个排序算法是stable的，即对当key的值相同的元素进行排序时，不影响其他key的相对顺序<br>（即假设key1已经是排好序的，对key2进行排序，在key2相同的元素中同样也按key1排好序）</p>
<p>目前已知的stable算法：insertion和merge</p>
<h4 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h4><table>
<thead>
<tr>
<th>Algorithms</th>
<th>inplace?</th>
<th>stable?</th>
<th>worst</th>
<th>average</th>
<th>best</th>
<th>remark</th>
</tr>
</thead>
<tbody><tr>
<td>selection</td>
<td>yes</td>
<td></td>
<td><code>$N^2/2$</code></td>
<td><code>$N^2/2$</code></td>
<td><code>$N^2/2$</code></td>
<td>N exchange</td>
</tr>
<tr>
<td>insertion</td>
<td>yes</td>
<td>yes</td>
<td><code>$N^2/2$</code></td>
<td><code>$N^2/4$</code></td>
<td><code>$N$</code></td>
<td>常用于当N比较小或数组已经部分排好序（近乎线性复杂度）</td>
</tr>
<tr>
<td>shell</td>
<td>yes</td>
<td></td>
<td><code>$N^{1.5}$</code></td>
<td><code>$N^{1.3}$</code></td>
<td>N</td>
<td>subquadratic</td>
</tr>
<tr>
<td>merge</td>
<td></td>
<td>yes</td>
<td><code>$NlgN$</code></td>
<td><code>$NlgN$</code></td>
<td><code>$NlgN$</code></td>
<td><code>$NlgN$</code> guarantee, stable</td>
</tr>
<tr>
<td>quick</td>
<td>yes</td>
<td></td>
<td><code>$N^2/2$</code></td>
<td><code>$2NlnN$</code></td>
<td><code>$NlgN$</code></td>
<td><code>$NlgN$</code> probabilistic guarantee，目前实践中最快的算法</td>
</tr>
<tr>
<td>3-way quick</td>
<td>yes</td>
<td></td>
<td><code>$N^2/2$</code></td>
<td><code>$2NlnN$</code></td>
<td><code>$N$</code></td>
<td>改进的quick sort，适应duplicate key</td>
</tr>
<tr>
<td>Heap</td>
<td>yes</td>
<td></td>
<td><code>$2NlgN$</code></td>
<td><code>$2NlgN$</code></td>
<td><code>$NlgN$</code></td>
<td><code>$NlgN$</code> guarantee, in-place</td>
</tr>
</tbody></table>
<h3 id="Week-4-Priority-Queue-Heap-优先队列-堆"><a href="#Week-4-Priority-Queue-Heap-优先队列-堆" class="headerlink" title="Week 4. Priority Queue / Heap 优先队列 / 堆"></a>Week 4. Priority Queue / Heap 优先队列 / 堆</h3><p>定义，有序的队列，即每次删除操作只删除最大或最小值</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>(e.g. Max Priority Queue, 每次删除最大值)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 注意：与一般Queue相比，我们希望MaxPQ里面的元素是comparable的，以便在队内进行排序操作</span><br><span class="line">public class MaxPQ &lt;key extends Comparable&lt;Key&gt;&gt; &#123;</span><br><span class="line">    MaxPQ()                 // create an empty priority queue</span><br><span class="line">    MaxPQ(Key[] a)          // create an priority queue with given keys</span><br><span class="line">    void insert(key v)      // return and remove the largest key</span><br><span class="line">    boolean isEmpty()       // is the priority queue empty</span><br><span class="line">    key max()               // return the largest key</span><br><span class="line">    int size()              // number of the entries in the priority queue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最简单的两种Priority-Queue实现"><a href="#最简单的两种Priority-Queue实现" class="headerlink" title="最简单的两种Priority Queue实现"></a>最简单的两种Priority Queue实现</h5><ol>
<li>(Unordered PQ) 每次将元素插入到队列末端，每次删除需要遍历整个Queue找出最小值<br>–插入需要O(1), 删除需要O(N)，查找最值需要O(N)</li>
<li>(Ordered PQ) 每次插入需要插入到合适位置使queue始终有序，删除操作只需删除队尾元素<br>–插入需要O(N)，删除需要O(1)，查找最值需要O(1), 分为链表和数组两种实现<br><strong>两种都需要O(N)时间复杂度</strong></li>
</ol>
<h4 id="Binary-Heap"><a href="#Binary-Heap" class="headerlink" title="Binary Heap"></a>Binary Heap</h4><h5 id="1-Complete-Binary-Tree"><a href="#1-Complete-Binary-Tree" class="headerlink" title="1. Complete Binary Tree"></a>1. Complete Binary Tree</h5><ol>
<li>Binary Tree二叉树：一个节点连接两个左右子二叉树，或者节点为空的树</li>
<li>Complete Binary Tree完全二叉树：整个树除了底层节点外，每个节点都有两个子节点<br>一个有N个节点的 CBT的层数为floor(lgN)</li>
</ol>
<h5 id="2-Binary-Heap"><a href="#2-Binary-Heap" class="headerlink" title="2. Binary Heap"></a>2. Binary Heap</h5><p>即数组形式表现的Complete Binary Tree<br>如何将CBT存储为数组形式？</p>
<ol>
<li>按照层遍历(BST)完全二叉树，并依次分配一个递增的索引index（index start from 1）</li>
<li>按照分配的索引放入数组a的对应位置<br>(以上称为Heap Ordering 堆排序，即父节点的index一定小于子节点的index，同一层左边的节点index小于右边的)</li>
</ol>
<p>通过数组形式存储，我们就无须实际生成整个完全二叉树，通过数组操作实现堆操作</p>
<h5 id="3-Properties"><a href="#3-Properties" class="headerlink" title="3. Properties"></a>3. Properties</h5><ol>
<li>index=1 (a[1]) 对应的元素为所有元素的最大值，即根节点为最大值</li>
<li>index为k的节点的父节点index为k/2，子节点index为2k和2k+1 （因此我们需要index从1开始）</li>
<li>父节点需要大于（MaxPQ）或小于（MinPQ）其子节点</li>
</ol>
<p>通过性质2我们可以很方便的通过数组访问CBT的节点</p>
<h5 id="4-Eliminate-the-Violation"><a href="#4-Eliminate-the-Violation" class="headerlink" title="4. Eliminate the Violation"></a>4. Eliminate the Violation</h5><p>e.g. (以MaxPQ为例，即堆元素从上往下减小) </p>
<p><strong>Case 1: Promotion</strong><br>前提假设：我们改变一个节点的值，使其大于父节点的值<br>方法：我们可以将其与父节点交换，交换后再将该节点与新的父节点相比较，层层向上交换直到根节点<br>(Peter Principle: node promoted to level of incompetence，类似于升职过程)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k)) &#123;</span><br><span class="line">        exch(k, k/<span class="number">2</span>);</span><br><span class="line">        k = k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Case 2: Demotion</strong><br>前提假设：我们改变一个节点的值，使其小于其两个子节点<br>方法：我们将该节点与它最大的子节点交换，交换后再将该节点与新的子节点相比较，层层向下交换直到叶子节点<br>(Power Struggle: Better subordinate promote，类似于降职过程)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j+<span class="number">1</span>)) j++; <span class="comment">// find the maximum child node</span></span><br><span class="line">        <span class="keyword">if</span> (!less(k, j)) <span class="keyword">break</span>; <span class="comment">// legal position</span></span><br><span class="line">        exch(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-Insert"><a href="#5-Insert" class="headerlink" title="5. Insert"></a>5. Insert</h5><p>基于4的Promotion原理，对于新插入的元素，我们可以将其直接插入到数组尾端（即树的叶子节点），然后判断这个新插入的节点是否violation</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key x)</span> </span>&#123;</span><br><span class="line">    pq[++N] = x;</span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该操作复杂度为logN，即我们只需要最多1 + floor(lgN)次compare</p>
<h5 id="6-Delete-the-Max"><a href="#6-Delete-the-Max" class="headerlink" title="6. Delete the Max"></a>6. Delete the Max</h5><p>基于5的Demotion原理，我们用数组中最后一个元素（即最小值）替换掉堆顶元素（即根节点最大值），然后对新的堆顶元素做Demotion操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Key max = pq[<span class="number">1</span>];</span><br><span class="line">    exch(<span class="number">1</span>, N--);</span><br><span class="line">    pq[N+<span class="number">1</span>] = <span class="keyword">null</span>; <span class="comment">// prevent loitering 记得把最后一个节点设为null</span></span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该操作复杂度为logN</p>
<h5 id="7-Total-Complexity-O-lgN"><a href="#7-Total-Complexity-O-lgN" class="headerlink" title="7. Total Complexity: O(lgN)"></a>7. Total Complexity: O(lgN)</h5><p>Insert: O(lgN); Delete: O(lgN); <strong>Max: O(1)</strong></p>
<h5 id="8-Other-Notice"><a href="#8-Other-Notice" class="headerlink" title="8. Other Notice"></a>8. Other Notice</h5><ol>
<li>我们不希望client能够随意改动已经放入PQ的Key，因此实现特定数据结构Key时需要 a. 对整个class声明final，即<code>public final class Key{}</code> b.对数据结构内部所有变量需要设置为<code>private final</code> c. 这个数据类型中所有可调用的方法都不能改变内部变量的值<br>(Some Immutable Variable: String, Integer, Double;<br>Some Mutable Variable: StringBuilder, Stack, Counter, Java array)</li>
</ol>
<h4 id="HeapSort-堆排序"><a href="#HeapSort-堆排序" class="headerlink" title="HeapSort 堆排序"></a>HeapSort 堆排序</h4><p>即利用堆顶元素最大的原理，将待排序的元素建立一个堆，每次提取堆顶元素再建立新堆，直到所有元素都提取完成</p>
<h5 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h5><p>假设存在一个数组a[N]需要排序</p>
<ol>
<li>我们将a[N]按照heap order排序，即用这些数据建立一个max heap最大堆</li>
<li>当我们获得堆后，堆顶元素即为最大值，将其与数组最后一个元素（即第N个元素）交换。<br>设置一个指针i=N指向第N个元素，表示这个元素以及之后的元素是排好序的，剩余堆为[1, i-1]。<br>对堆顶元素进行sink操作直到整个剩余堆[1,i-1]是valid的，</li>
<li>重复操作2，每次将堆顶元素放入已排好序区间的开头位置，同时移动指针i–，使得这个数组的前面一部分[1, i-1]是堆，后面一部分[i, N]是部分排好序的数组</li>
</ol>
<p>注意：为了实现in-place，我们直接在原数组上建堆，即我们从后往前，对每个节点进行sink操作以确保局部堆的合法性。即我们确保了两个局部堆是valid的，然后通过sink两个堆的父节点来确保这两个堆合并为一个大堆后是valid的<br>（实际上第N/2 + 1到第N个元素都是没有子节点的，我们可以直接从第N/2个元素开始）<br>为什么不从前往后建堆：因为所有的insert或者sink操作，前提是需要这个堆除了这个元素外其他都是in heap order的，否则通过sink操作并不能得到valid的堆；从后往前建堆以保证每个子堆vaild以及merge后也是valid的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) sink(a, k, N); <span class="comment">// Step 1：in-place heap builder</span></span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123; <span class="comment">// Step 2: put the largest element to the right and rebuild the heap</span></span><br><span class="line">        exch(a, <span class="number">1</span>, N);</span><br><span class="line">        sink(a, <span class="number">1</span>, --N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（注意这里我们的数组index是从0开始到N-1，而使用PQ的index是从1到N，因此我们需要在进行exch和sink操作时将两种索引进行对应的转换）</p>
<h5 id="Complexity-NlogN"><a href="#Complexity-NlogN" class="headerlink" title="Complexity: ~NlogN"></a>Complexity: ~NlogN</h5><p>唯一能保证worst case为NlogN的in-place算法<br>（Mergesort：non in-place；Quick Sort：worst case ~N^2）</p>
<p>补充：为什么在industry中不常用HeapSort：  </p>
<ol>
<li>其他sort访问元素都是比较连续的局部顺序访问，而HeapSort经常会需要访问数组中两个距离较远的元素（比如访问子节点依次需要访问1，2，4，8，…等相距的节点），使得CPU需要较大缓存cache（CPU缓存可能一次只能从内存中读取小部分数组，访问其他块的元素需要多次内存&lt;-&gt;缓存操作），导致效率变低</li>
<li>HeapSort需要的交换次数多于Quick Sort，因为每次建堆过程(insert / delete)都会打乱Heap Order，以致数据有序度降低</li>
<li>不是Stable的算法 （区别Merge Sort）</li>
</ol>
<h3 id="Week-5-Symbol-Table-符号表"><a href="#Week-5-Symbol-Table-符号表" class="headerlink" title="Week 5. Symbol Table 符号表"></a>Week 5. Symbol Table 符号表</h3><p>符号表主要目的就是将一个键（Key）和一个值（value）关联起来，可以将一个键值对（Key-Value Pair）插入到符号表中并能够通过key直接找到对应的value</p>
<h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    ST(); <span class="comment">// 创建一个符号表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span>; <span class="comment">// 存储键值对</span></span><br><span class="line">    <span class="function">Value <span class="title">get</span><span class="params">(Key key)</span></span>; <span class="comment">// 获得key对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>; <span class="comment">// 删去key及对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span>; <span class="comment">// 判断ST是否包括key</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 判断ST是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 获取ST中的键值对数量</span></span><br><span class="line">    <span class="function">Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>; <span class="comment">// 遍历表中的所有key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Limitation"><a href="#Limitation" class="headerlink" title="Limitation"></a>Limitation</h5><p>关于null值的几个限定：</p>
<ol>
<li>value不能为null</li>
<li>当key不存在时，get(key) 方法返回null</li>
<li>当key存在时，put(key, value)方法将覆盖旧的value</li>
</ol>
<h5 id="补充：contains和delete方法的实现"><a href="#补充：contains和delete方法的实现" class="headerlink" title="补充：contains和delete方法的实现"></a>补充：contains和delete方法的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于所有的ST，contains方法都是相同的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> get(key) != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种简单的delete方法（仅对某些实现有效）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;put(key, <span class="keyword">null</span>);  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="补充：Java-Equality-Test-相等性测试"><a href="#补充：Java-Equality-Test-相等性测试" class="headerlink" title="补充：Java Equality Test (相等性测试)"></a>补充：Java Equality Test (相等性测试)</h5><p>所有的java class内部都包含equals()函数，用于测试两个对象是否相等<br>判断对象相等的标准：</p>
<ol>
<li>Reflexive 自反性：x.equals(x) == true</li>
<li>Symmetric 对称性：x.equals(y) iff y.equals(x)</li>
<li>Transitive 传递性：x.equals(y) &amp; y.equals(z) =&gt; x.equals(z)</li>
<li>Non-null 非空：x.equals(null) == false</li>
</ol>
<p>equals实现方法：</p>
<ol>
<li>Java默认实现：x == y （即判断两个对象的地址是否相同，较不常用）</li>
<li>自定义(即根据不同对象类型自行设计各种判断来实现equals函数，注意需要满足上述四大标准)<br>e.g. 假设我们有个Date类，里面有(int month, int day, int year)三个值，需要实现equals函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object y) &#123; // 注意这里，java规范规定传入类型必须为Object而非自定义的类</span><br><span class="line"></span><br><span class="line">    if (y == this) return true; // 优化：如果两个对象地址相同，则一定相等</span><br><span class="line">    </span><br><span class="line">    if (y == null) return false; // 判断Non-null非空（标准4）</span><br><span class="line">    </span><br><span class="line">    if (y.getClass() != this.getClass()) return false; // 两个对象的类相同，两个对象才相同</span><br><span class="line">    Date that = (Date) y; // 经过上面判断后，cast操作一定成功</span><br><span class="line">    </span><br><span class="line">    // 上面的代码对任何equals函数都是必要的</span><br><span class="line">    </span><br><span class="line">    // 比较各个field的逻辑</span><br><span class="line">    if (this.day != that.day ) return false;</span><br><span class="line">    if (this.month != that.month) return false;</span><br><span class="line">    if (this.year != that.year ) return false;</span><br><span class="line">    return true;</span><br><span class="line">    </span><br><span class="line">    // 对于字段field的比较方法（上面的day，month和year）</span><br><span class="line">    // 1. 如果field为基本数据类型primitive type，则直接用==比较</span><br><span class="line">    // 2. 如果field为object类型，则用该object的equals函数进行比较</span><br><span class="line">    // 3. 如果field为数组，则我们需要遍历数组并对数组中的每一项进行equals比较</span><br><span class="line">    //      (可以采用Arrays.equals(a, b)或者Arrays.deepEquals(a, b) （适用于多维或嵌套数组），</span><br><span class="line">    //      但不能采用a.equals(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两种简单的ST实现"><a href="#两种简单的ST实现" class="headerlink" title="两种简单的ST实现"></a>两种简单的ST实现</h4><h5 id="1-无序链表"><a href="#1-无序链表" class="headerlink" title="1. 无序链表"></a>1. 无序链表</h5><p>键值对为链表的一个节点<br>search：从头至尾遍历链表，直到找到对应的key =&gt; O(n)<br>insert：每次插入先serach对应的key是否存在于链表中，如果不存在则直接插入到链表头部 =&gt; O(n)<br>注意:<br>这种实现只需通过equals()函数比较key而无需通过compareTo()进行key排序，但也无法顺序输出键值对</p>
<h5 id="2-顺序数组-二分查找"><a href="#2-顺序数组-二分查找" class="headerlink" title="2. 顺序数组 + 二分查找"></a>2. 顺序数组 + 二分查找</h5><p>需要两个并行数组keys和values来分开存储key和value<br>search：通过二分查找函数rank()来获取key在keys数组中的索引i，并以此索引i来获得value = values[i]，如果未找到对应的key则返回null =&gt; O(logN)<br>insert：通过rank()函数找到对应插入的位置i，对keys和values数组将i后面的所有元素往后移动一位，再将key-value插入到对应位置；如果key存在则直接改写对应的value值 =&gt; O(N)<br>注意：和无序链表实现相比，需要通过compareTo()函数实现二分查找，同时可以顺序输出键值对 </p>
<p>补充：当key是comparable时，还可以有其他应用（统称为ordered operations）：</p>
<ol>
<li>找到最小或最大的key （min()和max()函数）或者删除最大或最小值(deleteMin()和deleteMax()函数)</li>
<li>查找特定位置的key(select()函数)</li>
<li>找到最接近的key(ceiling()和flooring()函数)</li>
<li>获得key在ST表中的顺位(rank()函数)</li>
<li>迭代ST表</li>
</ol>
<h4 id="Binary-Search-Tree-二叉查找树"><a href="#Binary-Search-Tree-二叉查找树" class="headerlink" title="Binary Search Tree 二叉查找树"></a>Binary Search Tree 二叉查找树</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>每个节点有一个key值，每个节点的key值大于这个节点的左子树中所有节点的key值，小于这个节点右子树中所有节点的key值</p>
<p>每个node有四个field：key，value，left，right</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line">    <span class="keyword">private</span> Value val;</span><br><span class="line">    <span class="keyword">private</span> Node left, right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h5><p>与quick sort的关联：和quick sort一样有一个partition的过程，因此BST的inorder是有序的</p>
<h5 id="查找key对应的value"><a href="#查找key对应的value" class="headerlink" title="查找key对应的value"></a>查找key对应的value</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = root;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x = x.left; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x = x.right; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度：key所在的节点深度+1（Average: ~2lnN，由quick sort启发得来）</p>
<h5 id="插入一个key-value-pair"><a href="#插入一个key-value-pair" class="headerlink" title="插入一个key-value pair"></a>插入一个key-value pair</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span></span></span><br><span class="line"><span class="function"></span>&#123;  root = put(root, key, val);  <span class="comment">// re-link &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val);</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left = put(x.left, key, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = put(x.right, key, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) x.val = val;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// tricky part：注意这里我们虽然返回的是一个节点，但我们需要把他想象成一个link，让其父节点连接到这个修改后的子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度：key所在的节点深度+1 （Average: ~2lnN）<br>补充：二叉树的形状，取决于节点插入的顺序<br>如果二叉树的节点是按顺序插入的，则二叉树呈一斜线，此时二叉树的高度最大 (worst case)，等同于一个linkedlist<br>Average Height: ~4.311lnN (随机顺序插入情况下)</p>
<h5 id="删除一个key-value-pair"><a href="#删除一个key-value-pair" class="headerlink" title="删除一个key-value pair"></a>删除一个key-value pair</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123;  root = delete(root, key);  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left = delete(x.left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = delete(x.right, key);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x.left; <span class="comment">// 没有左子树，直接返回右子树</span></span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x.right; <span class="comment">// 没有右子树，直接返回左子树</span></span><br><span class="line">        <span class="comment">// 找出右子树的最小节点来替换该节点</span></span><br><span class="line">        Node t = x;</span><br><span class="line">        x = min(t.right); <span class="comment">// 找出右子树的最小节点替换该节点</span></span><br><span class="line">        x.right = deleteMin(t.right); <span class="comment">// 删掉这个最小节点（因为要替换到该节点的位置）</span></span><br><span class="line">        x.left = t.left; <span class="comment">// 将旧节点的左子树附到新节点的左子树上</span></span><br><span class="line">    &#125;</span><br><span class="line">    x.count = size(x.left) + size(x.right) + <span class="number">1</span>; <span class="comment">// 更新该节点的size()</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度：sqrt(N)<br>这种删除方法存在一个问题，因为我们总是将右子树的最小值替换到删除的节点，因此当长时间进行动态的insert和delete操作后，树变得不再balance而会偏向一边（左边），导致后面的insert、search和delete操作的复杂度变为比lgN更大的sqrt(N)<br>该问题目前无解，即使是随机的选取左子树的最大值或者右子树的最小值替换删除的节点，复杂度仍为sqrt(N)<br>另外如果delete操作是order的，也会导致BST变为完全不平衡的树（因此引入红黑树解决此问题，后续会讲）</p>
<h5 id="Ordered-Operations"><a href="#Ordered-Operations" class="headerlink" title="Ordered Operations"></a>Ordered Operations</h5><p>min() / max(): 一直递归左子树直到叶节点即为最小值；一直递归右子树直到叶节点即为最大值<br>floor()：找出比该key小的所有节点的最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    Node x = floor(root, key); <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="keyword">return</span> x.key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(x.key); </span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x; <span class="comment">// 找到exact same的值，直接返回节点</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> floor(x.left, key); <span class="comment">//当前节点比key大，说明target肯定在该节点的左子树中</span></span><br><span class="line">    Node t = floor(x.right, key); <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t;</span><br><span class="line">    <span class="comment">// 当前节点比key小，说明当前节点可能是target</span></span><br><span class="line">    <span class="comment">// 如果在他右子树中能发现target，则证明能找到更大的比key小的值，返回新的target</span></span><br><span class="line">    <span class="comment">// 否则当前节点的值就是要找的下界，直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ceiling()同理类推<br>size()：在node节点中增加一个size field，代表该节点为根的树的大小，在插入操作时同时修改每个节点的size<br>rank()：利用size()函数递归操作，对于某个节点的rank，等于其左子树的size()以及其父节点的左子树的size()依次递归</p>
<p>Ordered Iteration</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Key&gt; q = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">    inorder(root, q);</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Inorder traversal: BST的中序遍历为有序的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(Node x, Queue&lt;Key&gt; q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>; </span><br><span class="line">    inorder(x.left, q);</span><br><span class="line">    q.enqueue(x.key);</span><br><span class="line">    inorder(x.right, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度：除了Ordered Iteration为N，其他ordered operation的复杂度都为h (节点的深度，avg为lgN)</p>
<h4 id="2-3-Tree"><a href="#2-3-Tree" class="headerlink" title="2-3 Tree"></a>2-3 Tree</h4><h5 id="定义-amp-特征"><a href="#定义-amp-特征" class="headerlink" title="定义&amp;特征"></a>定义&amp;特征</h5><p>2-3 Tree是Balanced Search Tree的一种，每个节点可以有1个或两个key，分别称为2-node或3-node:<br>2-node: 包含1个key和2个子节点，其中左子树的所有节点的key小于该节点，右子树所有节点的key大于该节点<br>3-node: 包含2个key和3个子节点，假设该节点有两个key，分别为a和b，则有：  </p>
<ol>
<li>这个节点左子树的所有节点的key小于a  </li>
<li>这个节点右子树的所有节点的key大于b  </li>
<li>这个节点中子树的所有节点介于a和b之间  </li>
</ol>
<p>2-3树有如下特征：  </p>
<ol>
<li>每条从root节点到叶子节点（或null节点）路径的长度总是相等的（即Perfect Balanced）</li>
<li>2-3树的中序遍历也是有序的</li>
<li>树的高度：<ol>
<li>worst case（即全为2-node）：lgN</li>
<li>best case（即全为3-node）：log_3 N (~0.631lgN)</li>
</ol>
</li>
</ol>
<h5 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h5><p>基本方法和BST相同：</p>
<ol>
<li>如果target在一个2-node或3-node里面，表示找到target</li>
<li>如果dfs到一个2-node且target不在里面，如果2-node的key &gt; target则递归到左子树，反之递归到右子树</li>
<li>如果dfs到一个3-node且target不再里面，假设有两个key分别为a，b，如果target &lt; a则递归到左子树，如果a &lt; target &lt; b则递归到中子树，如果target &gt; b则递归到右子树</li>
<li>如果节点为null，代表没找到target，返回null</li>
</ol>
<h5 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h5><p>假设我们通过search找到key要插入的位置，为一个2-node或3-node叶子节点</p>
<ol>
<li>假设要插入的位置为2-node，我们可以直接插入到2-node使其变为一个3-node</li>
<li>如果要插入的位置为3-node：<ol>
<li>我们先将key插入到这个3-node使其变为一个临时的4-node（即含有三个key和四个子树）  </li>
<li>然后进行split操作：将这个4-node分开成3个2-node，最左边的2-node包含了原本4-node的左边两个子树，最右边的2-node包含了原本右4-node的右边两个子树，中间的2-node将其向上合并到原本4-node的父节点  </li>
<li>此时原本4-node的父节点可能是一个3-node，也有可能是一个4-node，如果是一个4-node，就继续进行split操作并向上合并。如果是3-node则无需进一步操作</li>
</ol>
</li>
</ol>
<p>补充：2-3树原理较为简单，但实现比较复杂，需要考虑到多种情况，这里暂时不需要掌握具体实现<br>另外有其他实现更简单的Balance Search Tree（e.g. 红黑树）</p>
<h5 id="Complexity-6"><a href="#Complexity-6" class="headerlink" title="Complexity"></a>Complexity</h5><p>所有操作都能保证为lgN的复杂度 (lgN guarantee)</p>
<h4 id="left-leaning-Red-Black-BSTs"><a href="#left-leaning-Red-Black-BSTs" class="headerlink" title="(left-leaning) Red-Black BSTs"></a>(left-leaning) Red-Black BSTs</h4><h5 id="定义-amp-特征-1"><a href="#定义-amp-特征-1" class="headerlink" title="定义&amp;特征"></a>定义&amp;特征</h5><p>基本思想：2-3树因为存在2-node和3-node（尤其是3-node），因此插入和查找操作相对BST比较复杂。我们希望我们的树结构能和BST一样简单,但是又能体现出2-node和3-node。即我们需要在BST中用一种简单的方法来表现3-node</p>
<p>如何在BST中表现3-node？  </p>
<p><img src="https://i.loli.net/2020/08/03/RgQrAKTNGbW3tLl.png" alt="3-node.png"></p>
<p>我们用一个称为left-leaning link（即上图红色的边）来粘结3-node，此时原本3-node的左子树为a的左子树，中子树为a的右子树，右子树为b的右子树</p>
<p>原本3-node中较大的key为新的BST中的根节点，我们用红色的边标记a和b之间的internal link，以示和其他link区别</p>
<p>e.g. 完整的2-3 Tree以及其对应的RB Tree表示</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/J1zfU7nHmVuEb6O.png" alt="2-3 Tree.png" title>
                </div>
                <div class="image-caption">2-3 Tree.png</div>
            </figure>

<p>黑色的边连接原本的2-node或3-node，红色的边为internal link，用来表现3-node</p>
<p>红黑树定义：</p>
<ol>
<li><p>任何节点不会有两个红色的边与其相连</p>
</li>
<li><p>任何从根节点到叶子节点（或null节点）的路径所包括的黑色的边的数量相同 （黑色边连接2-node和3-node，原先2-3树中每条路径的节点数相同，对应红黑树的黑边数量相同）</p>
</li>
<li><p>所有红色的边都是向左的，称为left-leaning</p>
</li>
</ol>
<h5 id="Search-amp-other-ordered-ops"><a href="#Search-amp-other-ordered-ops" class="headerlink" title="Search &amp; other ordered ops"></a>Search &amp; other ordered ops</h5><p>Search操作以及其他ordered ops和BST是完全一样的，但由于树的平衡性更好，因而效率更高</p>
<h5 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">   Key key;</span><br><span class="line">   Value val;</span><br><span class="line">   Node left, right;</span><br><span class="line">   <span class="keyword">boolean</span> color; <span class="comment">// color of parent link</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span> x.color == RED; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在BST节点的基础上增加一个color field，用来表示这个节点连接到其父节点的边颜色</p>
<p>（上图中，A, E, S节点的color为RED而其他node为BLACK）</p>
<p>补充：我们默认所有null节点都是黑色的（因为它不可能是3-node中的key）</p>
<h5 id="Basic-Operations-Required-For-Insertion"><a href="#Basic-Operations-Required-For-Insertion" class="headerlink" title="Basic Operations Required For Insertion"></a>Basic Operations Required For Insertion</h5><p>在实现insertion 操作之前，我们需要实现两个基本的rotation操作，使得将一个right-leaning的3-node变成left-leaning，或者将一个left-leaning的3-node临时变成right-leaning（再变回left-leaning）。还需要一个等效于原来4-node分裂成2-node的操作。后续Insertion操作会用到这些操作</p>
<ol>
<li>Rotate Left</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/2MnBDKL9Xu8sFTH.png" alt="rotateLeft.png" title>
                </div>
                <div class="image-caption">rotateLeft.png</div>
            </figure>

<p>假设h节点的右节点为红色（即leaning-right），rotate之后x将成为新的父节点并返回。剩余的三棵子树中，原来的左子树和右子树都不用变（还是连接在原来的h和x节点上），中子树需要从原来x节点的左子树连接到h节点的右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(h.right)</span></span>;</span><br><span class="line">    Node x = h.right; <span class="comment">// 先保存x</span></span><br><span class="line">    h.right = x.left; <span class="comment">// 将中子树从x连接到h上</span></span><br><span class="line">    x.left = h; <span class="comment">// 旋转，将h连接到x左边（变为left-leaning）</span></span><br><span class="line">    x.color = h.color; <span class="comment">//同时需要改变两个节点的颜色</span></span><br><span class="line">    h.color = RED;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回旋转后新的3-node根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Rotate Right</p>
<p>原理同Rotate Left，先调整中子树再rotate</p>
</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/rCod3OmeivpX9xS.png" alt="rotateRight.png" title>
                </div>
                <div class="image-caption">rotateRight.png</div>
            </figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(h.left)</span></span>;</span><br><span class="line">    Node x = h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    x.color = h.color; <span class="comment">// 注意这里，我们希望旋转之后除了这个3-node之外整个树其他部分都不变化（包括其他各边的颜色），因此这里我们新的根节点的颜色（即这个node连接到上面父节点的边的颜色）选择与原来一样保持不变</span></span><br><span class="line">    h.color = RED;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Color Flip</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/vrjdyOkD67PSzsM.png" alt="colorFlip.png" title>
                </div>
                <div class="image-caption">colorFlip.png</div>
            </figure>

<p>在insert的过程中可能会遇到一个节点的两个子节点都是Red节点（等价于原来的4-node）。此时我们需要将其分为两个2-node（即图中的A和S节点），并将表示中间key的节点（图中的E）向上移动。</p>
<p>将4-node分为2个2-node，可以直接将两个红色节点设为黑色即可</p>
<p>对中间节点（E节点）的颜色进行分类讨论：</p>
<ol>
<li><p>假设E的父节点表示的是一个2-node（即只有一个key），则直接将E设为红色节点可以使这个2-node变为一个3-node。即使我们不知道E是左节点还是右节点，我们也可以通过旋转操作进行调整</p>
</li>
<li><p>假设E的父节点表示的是一个3-node，则将E设为红色后，E的父节点将有两个红色节点，此时等价于左图中的4-node情况，需要继续进行color flip</p>
<p>因此我们直接将4-node的中间节点设为红色，左右节点设为黑色即可 (只需设置相应节点的颜色而无需更改link)</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> !isRed(h);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(h.left)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isRed</span><span class="params">(h.right)</span></span>;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    h.left.color = BLACK;</span><br><span class="line">    h.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h5><p>基本策略：通过上面的rotation和color flip，实现与2-3 Tree insertion一一对应的等价操作</p>
<ol>
<li><p>按照search方法找到插入位置后，我们将要插入的节点设为红色并插入到对应位置（即将原本的2-node变为3-node或原本的3-node变为4-node，因而设为红色）</p>
</li>
<li><p>如果插入后的link是right-leaning的，我们通过left-rotation使其变为left-leaning的合法RBT</p>
</li>
<li><p>如果插入后，使得存在两个连续的边（下图两种情况）</p>
<img src="https://i.loli.net/2020/08/03/M9VhyPltbc8ejd4.png" alt="2-leanLeft.png" style="zoom:50%;">

<p>左图情况下，直接以c为节点进行rotateRight使其变为一个4-node，再进行color Flip</p>
<p>右图情况下，因为a节点会比b节点优先检查到，在检查a节点时会进行第二步的left-rotate操作使其变为左图情况</p>
<p>（补充第另外两种种右左情况和右右情况，因为先检查是否存在right-leaning，因此进行left-rotate后都会变为上面两种情况，因此实际上不会存在）</p>
<p>因此任意两个node插入第三个node，最终都会归结到左图情况，进行rotateLeft再color flip即可</p>
</li>
<li><p>插入后依次向上对每个节点进行合法性检查，最终得到合法RBT</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node h, Key key, Value val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BST插入部分（同一般BST插入）</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, RED);</span><br><span class="line">    <span class="keyword">int</span> cmp = key.compareTo(h.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) h.left = put(h.left, key, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) h.right = put(h.right, key, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp == <span class="number">0</span>) h.val = val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查每个节点是否合法：调整节点使其成为合法RBT</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h);<span class="comment">//此时该节点是leaning-right的，直接左旋</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);<span class="comment">//上面case3, 等价于生成4-node</span></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); <span class="comment">//split 4-node</span></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态转换过程: 对每个非法节点进行一步步的状态转换（一共三种状态），直到转换为合法状态</p>
<img src="https://i.loli.net/2020/08/03/cHTlxWZAaKDvgO1.png" alt="caseTransfer.png" style="zoom:50%;">



<h5 id="Complexity-7"><a href="#Complexity-7" class="headerlink" title="Complexity"></a>Complexity</h5><p>Tree Height: &lt;= 2lgN in worst case (每条路径的黑边数相同，且没有两条连续的红边，假设worst case最坏情况是一条黑边一条红边交错相连，因而worst case为2lgN)；1.00lgN in average case；</p>
<p>Time Complexity: 2lgN in worst case and lgN in average case for all operations.</p>
<h4 id="（Optional）B-Tree"><a href="#（Optional）B-Tree" class="headerlink" title="（Optional）B-Tree"></a>（Optional）B-Tree</h4><h5 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h5><p>B-树是Blanced Search Tree在文件系统中的应用。通常我们需要存储大量文件和数据在external storage中，需要尽可能快的查找到所需的文件</p>
<p>基于2-3树，B-Tree一个节点设置为可以包含最多M个key（M往往很大，e.g. 1024）和M-1个link （而2-3树中每个节点只能包括1个或2个key）。B-Tree还有如下性质</p>
<ol>
<li>root节点至少要有两个key</li>
<li>其他节点至少要有M/2个key （我们不希望每个节点太空，以保证查找高度不会太高）</li>
<li>所有的数据都存储在external node（外部节点，即叶节点）中，只存储数据的key且从左到右有序排列</li>
<li>B-Tree的internal node（内部节点，即非叶节点）仅用于搜索而非存储数据和key</li>
<li>当节点填满后，将一分为两个节点，并在其父节点添加一个新key</li>
</ol>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/enNbwI3KcJOVuzC.png" alt="BTree.png" title>
                </div>
                <div class="image-caption">BTree.png</div>
            </figure>



<h5 id="Complexity-8"><a href="#Complexity-8" class="headerlink" title="Complexity"></a>Complexity</h5><p>log_{M-1} N 到 log{M/2} N，for all operations</p>
<p>（每个节点包含的边的数量总是在 M/2  到 M-1之间）</p>
<p>Avg：当M = 1024 &amp; N = 62 billion, log {M/2} N &lt;= 4，即探查次数不超过4次</p>
<h4 id="Geometric-Application"><a href="#Geometric-Application" class="headerlink" title="Geometric Application"></a>Geometric Application</h4><h5 id="1D-Range-Search"><a href="#1D-Range-Search" class="headerlink" title="1D Range Search"></a>1D Range Search</h5><p>在ST的基础上增加两个函数：</p>
<ol>
<li>Range Search：找出所有大小介于k1和k2之间的key</li>
<li>Range Count：找出所有大小介于k1和k2之间的key的数量</li>
</ol>
<p>如果将所有key排列成一条直线（即1维状况），上面两个操作等同于找出这题直线某个区间内的所有点</p>
<p>BST Implementation：</p>
<ol>
<li>count：使用rank函数，找出两个key的rank，两者之差的绝对值即为结果</li>
<li>search：中序递归，先递归查找左子树中是否包含在两个key之间的key，再检查当前key，再递归查找右子树是否包含在两个key之间的key</li>
</ol>
<p>Time Complexity:</p>
<table>
<thead>
<tr>
<th>data structure</th>
<th>Insert</th>
<th>range count</th>
<th>range search</th>
</tr>
</thead>
<tbody><tr>
<td>unordered list</td>
<td>1</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>ordered array</td>
<td>N</td>
<td>logN</td>
<td>R + logN</td>
</tr>
<tr>
<td>BST</td>
<td>logN</td>
<td>logN</td>
<td>R + logN</td>
</tr>
</tbody></table>
<p>N = number of keys</p>
<p>R = number of keys that match</p>
<p>1D Range Search的应用: Orthogonal line segment intersection</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/AqIHWrZyGQwgLtY.png" alt="Orthogonal line segment intersection.png" title>
                </div>
                <div class="image-caption">Orthogonal line segment intersection.png</div>
            </figure>

<p>如图，平面中有许多水平线和垂直线。我们需要找出所有的交点。不存在任何重合的直线。</p>
<p>方法 （Sweep-line Algorithm，线段扫描算法）：</p>
<ol>
<li>图中红色的线从左到右依次扫描。遇到一条水平线的左端点后，将这条线的y坐标插入到BST中 （图中按0，1，2，3顺序依次插入）</li>
<li>遇到一条垂直线的右端点，则将该线的y坐标从BST中移出（移出2）</li>
<li>遇到垂直线后，假设这个垂直线两端点的y坐标分别为y1和y2，对BST进行Range Search(y1, y2)可以找到与该垂线相交的直线数量（e.g. 搜索线段4在BST中的range可以得到1的y坐标在range范围内，即与线段4相交的线段数量为1）</li>
</ol>
<p>时间复杂度：NlogN （每条线需要logN复杂度的BST操作，一共N条线）</p>
<h5 id="KD-Range-Search"><a href="#KD-Range-Search" class="headerlink" title="KD Range Search"></a>KD Range Search</h5><p>即我们假设每个key有K个维度，通过KD-Tree我们可以搜索给定维度范围内的key</p>
<p>e.g. 假设二维空间内有一群数据点，每个数据点包括两个field，如一个人的收入和年龄。我们可以通过一个2-D正交搜索（2-D Orthonogal Range Search）来查找给定收入和年龄范围内（e.g. 100K &lt; income &lt; 200K, 25 &lt; age &lt; 40）的所有数据点（等价于查找二维平面内用一个长方形框住的所有点）</p>
<h5 id="Grid-Implementation"><a href="#Grid-Implementation" class="headerlink" title="Grid Implementation"></a>Grid Implementation</h5><p>Steps</p>
<ol>
<li>将二维空间分为M*M个网格</li>
<li>将每个网格中的点分别存储到对应的list中</li>
<li>用一个2-D数组来索引每个网格的list</li>
<li>对于插入操作，利用索引将点直接插入到对应的网格的点list中</li>
<li>对于range search操作，对于给出的2-d range query，我们找到在这个范围内的所有square，提取出对应square的所有点，再一一检查每个点是否在给定的2-d range query范围内</li>
</ol>
<img src="https://i.loli.net/2020/08/03/VRjczSr61unGhdb.png" alt="2DRangeSearch.png" style="zoom:50%;">   



<p>Complexity</p>
<p>Space：M^2 + N (M^2个索引，以及需要用M^2个list存储所有N个点)</p>
<p>Time：对于每个examined的网格需要平均N/M^2次检查（平均每个网格包含N/M^2个点）</p>
<p>因此对于划分的网格大小M如果过大会导致空间复杂度上升，过小会导致时间复杂度上升（即space-time tradeoff）。</p>
<p>一般我们选择M = sqrt(N)，如果数据是evenly distributed的，则初始化索引的复杂度为N（sqrt(N) ^ 2）；insert的复杂度为1，range search的复杂度为1（每个网格平均包含一个点）</p>
<p>Issue</p>
<p>通常情况下，数据往往不是evenly distributed而是clustering（即大部分数据都集中在某一片区域，见上图右），导致存在少数很长的list和大多数很空的list（range search复杂度增大至趋近于N），因此需要其他数据结构</p>
<h5 id="2-D-Tree"><a href="#2-D-Tree" class="headerlink" title="2-D Tree"></a>2-D Tree</h5><p>Example</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/WTEc2B7pPkhJqlO.png" alt="2-DTree.png" title>
                </div>
                <div class="image-caption">2-DTree.png</div>
            </figure>

<ol>
<li><p>每个点表示为一个key，包含一个二维坐标。</p>
</li>
<li><p>我们将数据点依次插入到一个二叉搜索树中：</p>
<ol>
<li><p>对于树中奇数层的点，其左子树的点为平面中在该点左边的点，其右子树中点为平面中在该点右边的点 （e.g. 以点1为例，左子树中3，4，5，6都在点1的左边，2，7，8，9，10都在点1的右边，相当于以点1为基准<strong>将平面分为左右两部分</strong>）</p>
</li>
<li><p>对于树中偶数层的点，其左子树的点为平面中在该点下边的点，其右子树中点为平面中在该点上边的点 （e.g. 以点3为例，左子树中4，5都在点1的左边，6在点1的右边，相当于以点3为基准<strong>将子平面分为上下两部分</strong>）</p>
<p>这样我们每插入一个点，就将一个平面分为两个更小的平面</p>
</li>
</ol>
</li>
</ol>
<p>Range Search in 2-D Tree</p>
<p>e.g. 假设我们需要搜索上图中绿色框范围内的点</p>
<ol>
<li>从根节点开始，判断节点是否在范围内，如果在则添加到结果集</li>
<li>对于在奇数层的节点，如果查询范围的左边界在该节点左边，则递归查找到左子树，如果查询范围的右边界在该节点右边，则递归查找到右子树</li>
<li>对于在偶数层的节点，如果查询范围的上边界在该节点下边，则递归查找到左子树，如果查询范围的下边界在该节点上边，则递归查找到右子树</li>
<li>Complexity：R + logN</li>
</ol>
<p>2-D树的补充应用：Find Nearest Neighbor </p>
<p>给出一个点，找出现存平面中离该点最近的点</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/ZXu6dF1VYMDwhPS.png" alt="KDNearestNeighbor.png" title>
                </div>
                <div class="image-caption">KDNearestNeighbor.png</div>
            </figure>

<ol>
<li>从根节点开始，计算该节点与目标节点的距离，并更新最短距离</li>
<li>目标节点应该在该节点划分的两个区域的任意一边，我们优先递归到包含目标节点的区域对应的子树（e.g. 图中目标节点在1节点的左边，因此我们先递归到左子树，即3节点）</li>
<li>递归完包含目标节点的一边后，我们再判断是否需要递归另外一边的子树（e.g. 递归完1节点左半部分后，得到最近的neighbor为节点5，此时当前最短距离小于1节点右边的理论最短距离（即红色虚线的长度），因此1节点右边的节点与目标节点的距离不可能小于当前的最短距离，因此我们不需要再递归右节点部分，相当于剪枝）</li>
<li>Complexity：logN（in average），N（worst case, even if tree is balanced）</li>
</ol>
<h5 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD Tree"></a>KD Tree</h5><img src="https://i.loli.net/2020/08/03/AUedNujB2tOkFSK.png" alt="KDTree.png" style="zoom:50%;">

<p>类似于2D-Tree，奇数层的节点将平面分为左右两部分而偶数层的节点将平面分为上下两部分，我们同样利用BST将其延伸到k维。</p>
<p>假设节点P在第i mod k 层，则P的左子树的点在第i维都比点p小，右子树的点在第i维都比p大</p>
<h5 id="Interval-Search-Tree"><a href="#Interval-Search-Tree" class="headerlink" title="Interval Search Tree"></a>Interval Search Tree</h5><p>1D Interval Search Problem</p>
<p>我们希望实现一种数据结构，能够保存一系列区间（interval），这些区间有可能存在重叠（overlap）</p>
<p>这个数据结构能够完成如下操作：</p>
<ol>
<li>insert：插入一个interval (lo, hi)</li>
<li>search：搜索一个interval (lo, hi)</li>
<li>delete：删除一个interval (lo, hi)</li>
<li>interval intersection query：给定一个interval (lo, hi)，找出所有和这个interval交错（intersect）的区间</li>
</ol>
<p>（我们假设所有interval的起点都不同）</p>
<p>Implementation</p>
<p>利用BST，每个节点存储一个interval，但只用interval的左端点（即lo值）作为BST每个节点的key。</p>
<p>另外每个node还要存储以该node为根节点的树中所有节点最大的右端点，记为max （图中蓝色部分）</p>
<img src="https://i.loli.net/2020/08/03/8tL7lSsduKjkE2p.png" alt="IntervalST.png" style="zoom:50%;">



<p>Insertion</p>
<p>插入操作等同于一般BST的插入，以interval的左端点为key查找到对应的插入位置。</p>
<p>插入到对应位置后，要延搜索路径回溯并更新路径节点上的max值</p>
<p>Interval Intersection Search</p>
<p>假设给出一个query interval  (lo, hi)，只需要查找到一个与其交错的interval</p>
<p>从根节点开始，对每个节点表示的interval</p>
<ol>
<li>if 该interval和query interval交错，则将其添加到结果集</li>
<li>else if 该节点的左子树为空，递归到右子树</li>
<li>else if 左节点的max值小于query interval的lo值，递归到右子树 （即所有左子树中的节点都在query interval的左边，不可能存在交叉）</li>
<li>else 递归到左子树</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node x = root;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (x.interval.intersects(lo, hi)) <span class="keyword">return</span> x.interval;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) x = x.right;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x.left.max &lt; lo) x = x.right;</span><br><span class="line">	<span class="keyword">else</span> x = x.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>有效性证明：</p>
<ol>
<li><p>当我们搜索右节点时，代表左子树中不可能存在任何交错的节点区间</p>
</li>
<li><p>如果我们搜索左节点，如果在左子树中找不到交错的区间，代表即使我们搜索右子树也不可能找到交错的区间节点</p>
<p>证明：假设左子树不存在交错节点，同时因为搜索左子树，代表左节点的max值大于或等于query interval的lo值（即左子树中存在右端点大于lo的区间）。</p>
<p>因此如果在左子树中找不到交错节点，代表左子树中所有区间的最左端点都在query interval的右边（即图中hi &lt; c）。又因为右子树中所有区间的左端点肯定大于左子树的最左端点，因此右子树中也不可能找到交错节点</p>
<img src="/Users/david/Documents/Note/Algorithm/pic/IISProof.png" style="zoom: 33%;">



</li>
</ol>
<p>延伸：如何找出所有与其交错的intervals</p>
<p>按上面找一个intersection的方法，每找到一个交错interval，将其删除（或标记为已找到并不再访问），直到找到所有的interval</p>
<p>Complexity：我们可以采用红黑树，使得对insert, delete, search和find one intersect interval操作的复杂度为logN，对find all intersect interval，假设最后结果集的大小为R，则复杂度为RlogN（即需要R次find one intersect interval操作）</p>
<p>Application：Orthogonal rectangle intersection</p>
<p>平面内有一系列长方形（有可能存在相互覆盖或交错），找出所有交错的长方形</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/TCto6HsWAlrfxBp.png" alt="RectIntersectSearch.png" title>
                </div>
                <div class="image-caption">RectIntersectSearch.png</div>
            </figure>



<p>算法：Sweep Line Algorithm 线性扫描法（类似于1-D range search）</p>
<p>从左到右扫描所有长方形，每个长方形有一个y-interval记录长方形的上下两边的y值区间。我们用一个Interval Search Tree存储长方形的y-interval</p>
<ol>
<li>扫描到一个长方形左边时：<ol>
<li>查找Interval Search Tree中与该长方形y-interval交错的长方形，并记录到结果集</li>
<li>将这个长方形的y-interval插入到Interval Search Tree中</li>
</ol>
</li>
<li>扫描到一个长方形右边时：将这个长方形的y-interval从Interval Search Tree中移出</li>
</ol>
<p>复杂度：NlogN + RlogN</p>
<ol>
<li>将所有长方形按x值排序以便扫描（NlogN）</li>
<li>所有长方形的y-interval插入到Interval Search Tree中（NlogN）</li>
<li>删除Interval Search Tree中的y-interval（NlogN）</li>
<li>搜索交错的区间（NlogN + RlogN）</li>
</ol>
<p>该问题为原本2D Orthogonal line segment intersection的升级版，即2D orthogonal rectangle intersection。该算法将原本问题降维至1D interval search，因而降低了时间复杂度</p>
<h5 id="BST几何应用总结"><a href="#BST几何应用总结" class="headerlink" title="BST几何应用总结"></a>BST几何应用总结</h5><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/RcU5mG7YNPSeCoK.png" alt="BSTGeometricAppConclusion.png" title>
                </div>
                <div class="image-caption">BSTGeometricAppConclusion.png</div>
            </figure>



<h3 id="Week-6-HashTable-哈希表"><a href="#Week-6-HashTable-哈希表" class="headerlink" title="Week 6. HashTable 哈希表"></a>Week 6. HashTable 哈希表</h3><p>哈希表本质是一个Space-Time Trade-Off的数据结构，相比其他Symbol Table实现（如BST，红黑树），插入和查找的速度更快，但不支持ordered operations</p>
<p>我们将key-value键值对存储在一个数组中，并实现一个hash function以获得某个key在数组中的index</p>
<p>为此我们需要解决以下问题：</p>
<ol>
<li>如何设计hash function</li>
<li>如何判断两个key是否相等（Equality Test）</li>
<li>如何解决两个不同的key具有相同的hash值（Collision Resolution）</li>
</ol>
<h4 id="Hash-Function-哈希函数"><a href="#Hash-Function-哈希函数" class="headerlink" title="Hash Function 哈希函数"></a>Hash Function 哈希函数</h4><p>我们希望Hash Function计算效率要高，且每个计算出的index出现的可能性尽可能相等（e.g. 假设key1-10十个数，key1-9的hash都为0而key10的hash为1，这样会造成大量的hash冲突）</p>
<h5 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h5><p>对于一个任意类型的对象，我们使用hashCode()函数将其简化为一串数字（介于Integer.MIN_VALUE和Integer.MAX_VALUE之间），便于之后我们设计的hash函数通用化。hashCode()函数需要满足以下要求：</p>
<ol>
<li><p>两个相等对象的hashCode相同，即当x.equals(y) == true时, x.hashCode() == y.hashCode() </p>
</li>
<li><p>尽可能满足（不一定）当两个对象不同时，其hashCode也不同。即x.equals(y) == false时x.hashCode() != y.hashCode()。</p>
<p>因此hashCode()函数如果只返回一个常数(e.g. 17)是满足要求的，但没有什么实际用途。</p>
</li>
</ol>
<p>标准方法（Horner’s method）：31x+y</p>
<p>我们先设置一个初始hash值为<strong>17</strong>（一个质数），然后对于自定义数据结构中的每一个field，我们都采用hash = <strong>31</strong> * hash + field.hashCode()来计算：</p>
<ol>
<li>如果field为原始数据类型，则将其转化为包装类型（wrapper type）再使用其hashCode()函数</li>
<li>如果field为包装类型或引用类型，则直接采用其hashCode()函数</li>
<li>如果field是一个数组，则对其中的每一项采用hashCode()函数和31x+y规则（或者直接使用Arrays.deepHashCode()函数）。</li>
</ol>
<p>补充：所有java的class都内置了hashCode()函数。默认情况下，hashCode()为对象的地址。包装数据类型有其设计好的hashCode()函数</p>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash()"></a>hash()</h5><p>假设我们可以使用的数组空间大小为M，则我们的hash()函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M; &#125; <span class="comment">// 注意</span></span><br></pre></td></tr></table></figure>

<p>注意：因为key可能存在负数，因此我们需要先转成正数后才能进行取模操作。</p>
<p>另外我们不能直接用Math.abs()取正数，因为当hashcode为Integer.MIN_VALUE时该操作会导致整数溢出</p>
<h5 id="Uniform-Hashing-Assumption"><a href="#Uniform-Hashing-Assumption" class="headerlink" title="Uniform Hashing Assumption"></a>Uniform Hashing Assumption</h5><p>假设数组空间大小为M，且每个key获得0~M-1的index的概率都是相同的</p>
<p>从概率论角度，当我们随机插入~ sqrt(πM / 2)个key后，会出现两个key有相同的index</p>
<p>当随机插入~ MlnM个key后，数组每项都会存在至少一个key</p>
<p>当随机插入M个key后，数组中包含最多key的项大概包含log <em>M /</em> log log <em>M</em>个key</p>
<h4 id="Collision-Resolution-冲突解决"><a href="#Collision-Resolution-冲突解决" class="headerlink" title="Collision Resolution 冲突解决"></a>Collision Resolution 冲突解决</h4><p>即使我们采用了均匀分布的hash函数，仍然可能存在不同的key具有相同的hash值，即hash冲突</p>
<h5 id="Separate-Chaining-链表法"><a href="#Separate-Chaining-链表法" class="headerlink" title="Separate Chaining 链表法"></a>Separate Chaining 链表法</h5><p>假设我们的index数组大小为M &lt; N（待插入的键值对数量）。我们对数组中每一项放入一个链表，对于相同hash值的key所对应的键值对将插入到对应的同一个链表。</p>
<ol>
<li>Hash：先用hash函数计算key在表中的index i （0 &lt;= i &lt;= M-1）</li>
<li>Search: 找出数组中的第i项，对其链表进行线性查找</li>
<li>Insert：如果key不存在则将键值对插入到对应的链表头部。如果存在则改变对应的value值</li>
</ol>
<p>平均情况下，每个链表的长度为N/M，因此Search和Insert的复杂度也为~N/M</p>
<p>M的选择不能过大和过小，一般我们希望平均链表长度为5，此时M ~ N/5，复杂度趋近于log 1</p>
<h5 id="Opening-Addressing-开放地址法"><a href="#Opening-Addressing-开放地址法" class="headerlink" title="Opening Addressing 开放地址法"></a>Opening Addressing 开放地址法</h5><p>又称为linear probing线性探测法</p>
<p>Insert：仍然使用hash()函数获取key-value在表中的index，当这个index在数组中已被占用时，从这个index开始向后遍历（index + 1, index + 2, …），直到找到一个空的index将键值对插入</p>
<p>（注意这里index遍历是循环的，即当index遍历到数组最后一位后，回到数组开头）</p>
<p>Search：获得index后查找对应位置是否存在key，如果key不相同则继续向后遍历，直到遇到空位置</p>
<p>注意：index数组的大小M &gt;= N，以保证所有数据都能够被插入</p>
<p>Complexity</p>
<p>当数组是半满的情况，每次插入或查找需要的平均探测次数（即依次遍历找到空位的次数）为~3/2</p>
<p>当数组是接近全满后，每次插入或查找的平均探测次数为~ sqrt(πM / 8)</p>
<p>即数组越满，插入和查找的效率越低</p>
<h4 id="HashTable-和-Balanced-BST对比"><a href="#HashTable-和-Balanced-BST对比" class="headerlink" title="HashTable 和 Balanced BST对比"></a>HashTable 和 Balanced BST对比</h4><table>
<thead>
<tr>
<th>HashTable</th>
<th>Balanced BST （R-B BST）</th>
</tr>
</thead>
<tbody><tr>
<td>代码更为简单</td>
<td>性能更稳定</td>
</tr>
<tr>
<td>对于较为简单的key而言效率更高</td>
<td>支持Ordered Operations</td>
</tr>
<tr>
<td>HashMap</td>
<td>TreeMap，TreeSet</td>
</tr>
</tbody></table>
<h4 id="几种ST实现比较"><a href="#几种ST实现比较" class="headerlink" title="几种ST实现比较"></a>几种ST实现比较</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://i.loli.net/2020/08/03/bVdYUsw6NiO8MzH.png" alt="STcomparasion.png" title>
                </div>
                <div class="image-caption">STcomparasion.png</div>
            </figure>


        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-08-03T07:11:13.000Z" itemprop="dateUpdated">2020-08-03 15:11:13</time>
</span><br>


        
        Ref link：<a href="/2020/08/03/Princeton Algorithm 1 Note/" target="_blank" rel="external">http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/</a>
        
    </div>
    
    <footer>
        <a href="http://blog.david916.com">
            <img src="/img/avatar.jpg" alt="Wei Song">
            Wei Song
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Note/">Note</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/&title=《Princeton Algorithm 1 Note》 — David's Blog&pic=http://blog.david916.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/&title=《Princeton Algorithm 1 Note》 — David's Blog&source=Developer. Computer & Information Science Graduate Student @ Cornell." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Princeton Algorithm 1 Note》 — David's Blog&url=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/&via=http://blog.david916.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/08/03/React: Debounced Textfield/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">在React中实现Debounced Textfield</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/08/02/React：一次关于onclick的debug/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">React：一次关于onclick的debug</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "jDlfbKIsIQHS3k2z9iFPSh5I-gzGzoHsz",
            appKey: "eKDvrz93AEm6TOaJznROU600",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        Total Visitors：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        Total Visits：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Wei Song &copy; 2019 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/&title=《Princeton Algorithm 1 Note》 — David's Blog&pic=http://blog.david916.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/&title=《Princeton Algorithm 1 Note》 — David's Blog&source=Developer. Computer & Information Science Graduate Student @ Cornell." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Princeton Algorithm 1 Note》 — David's Blog&url=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/&via=http://blog.david916.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.david916.com/2020/08/03/Princeton Algorithm 1 Note/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACoklEQVR42u3aQW7jMBAEQP//07vXAIGV7hnSSIDSyZAdicUDyfTM6xVf/75cyf133yaf8zvHLjw8PLzF0L9fCWM29HfPT96ejBkPDw/vNi8fbj41yaRspuP5OXh4eHi/h/e8QLcbSftLPDw8vL/ImyE3+HajwsPDw/sML4kD8ji1jW5ncfDhrAUPDw9vngwcG+69z1fqe3h4eHjrqnqyScyO1LMIuB4tHh4e3gVee0TOwXnosGn5in6Jh4eHd4G3OYU+x7v51Gy2qGQMeHh4eGd57R/Mjtezdx3YbPDw8PAu8/KIoS2ezZ6WFMB+YOPh4eEd5T0v6+0amzwnL/Yn20O9JeDh4eGtefmhuT1GzwbXHsHziAQPDw/vBi8PGvZFrLy9YBZz1NsDHh4eXszLF/18A8i/zSPaWVENDw8P7x7v2K4SBxN5OW3zRjw8PLx7vFNNUW240Bbh8qnBw8PDu8fbLPEb6qz5YDZBeHh4eLd5+dA3TVT7rDWPP/Dw8PDO8to4Nf+2jXRnpB+ehoeHh3eZ1xaf8jvPm0obPRSbEB4eHt4F3qbtaRPCtq1XSdDw9jd4eHh4R3mnCkv7EtpmEt/+FR4eHt5HeC2gLYnNyldtVIGHh4d3j5cX9U81Tm2aulZhBB4eHt4FXnLYbUPbNpZNtqi2IIeHh4d3jzdrupqlpi24bU2IIgk8PDy8Q7z8zowxiz9e5YWHh4d3j7eJADbl/xmpbXHAw8PDu8Frl9q2pSBvCDjVxDC88PDw8ErerNTUxrunJrFuycLDw8O7xmuDhjZU3U/Wak/Dw8PD+wW82TE6f9eswBal1Hh4eHgf5+2Tj034m28/eHh4eLd5m6LX8xTsm6jyIBgPDw/vM7zZUn7q//28UeBwTQ8PDw9vwvsPUb8NAdLFUGUAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
